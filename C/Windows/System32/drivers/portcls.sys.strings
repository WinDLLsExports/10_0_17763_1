 !"#$%&'
 A^_]
 A^_^
 A_A^_
 A_A^_^]
 A_A^A\
 A_A^A\_^
 A_A^A]A\_
 A_A^A]A\_^[
 A_A^A]A\_^]
 Microsoft Corporation. All rights reserved.
 MISMATCH
 Operating System
 Windows
!D$xA
!Q4!Q0H!Q H!Q(3
!This program cannot be run in DOS mode.
$P;PhP
(_^][
(void) m_MiniportMXF->DisconnectOutput(m_CaptureSinkMXF)
(void) m_MiniportMXF->PutMessage(NULL)
(void) m_MiniportMXF->SetState(NewState)
)|wBK
)D$@A
)D$@H
)D$`A
)L$PA
* 4H`
.00cfg
.bss$dk00
.bss$pr00
.bss$zz
.data
.data$00
.data$dk00$brc
.data$pr00
.data$pr00$brc
.data$zz
.data$zz$brc
.edata
.gfids
.giats
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.L9.t<L
.pdata
.rdata
.rdata$00
.rdata$00$brc
.rdata$brc
.rdata$PAGE$lp00portcls.sys!20_pri7
.rdata$PAGE$lp01portcls.sys!20_pri7
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zz
.rdata$zz$brc
.rdata$zzzdbg
.rsrc$01
.rsrc$02
.SRTeT
.text
.text$lp00portcls.sys!20_pri7
.text$lp01portcls.sys!20_pri7
.text$mn
.text$mn$00
.text$mn$21
.text$np
.text$zy
.text$zz
.xdata
;A0sUH
;D$Pr
;D$Xs&A
;D$Xs5A
;J$s[
;RrDH
?9iXu-H
@(H9C(t
@8H9C8t
@A^_^
@A^A\_
@A_A^_
@A_A^A\
@A_A^A]
@A_A^A]A\_^]
@DA9AHrpH
@HA9ADwzA
@hvl~
@INIT
@LA9AP
@PA9AL
@SUATAVH
@SUVWAUAVH
@SUVWAVAWH
@SUWH
@SVAVH
@SVWH
@USATAUH
@USVATAUAVAWH
@USVWATAVAWH
@USVWAUAVH
@USVWH
@USWH
[#\^\
[%03X]
[[[o[
[3[P[`[
[A[^[r[G\
[Filter::Close]
[Filter::Init]
[Function:calling]
[Function:returned]
[L\!]
[Pin::Close]
[Pin::DistributeDeviceState]
[Pin::Init]
[Port::Init]
[RefCount:calling]
[RefCount:returned]
[y\5]d]
[Z\r\
\$ E3
\$(fD
\[]}]
\2^]^
\Device\VerifierExt
\Q^~^
\Registry\Machine\System\CurrentControlSet\Control\Class
\Registry\Machine\System\CurrentControlSet\Services\AudioSrv
\T\q\
]#]P]
]#^`^
]$C9"D
]?]]]
]]^o^
]>]_]^^
]2^L^o^
]7^b^
]9^i^
]PH9C0u^
]Z^[_
^(^G^o^
^,_i_
^0^I^^^N_j_
__C_specific_handler
_B_d_
_purecall
_snwprintf
_streamNotification->FreeBufferWithNotification( *_pMDL, nextRequestedBufferSize)
_vsnwprintf
_wcsnicmp
`.edata
`90`G
`A_A^A\_^[]
`A_A^A]_]
`A_A^A]A\_^]
`PAGEPcVf
`XQUY
{ ATAVAWH
{ AVH
{ UAUAWH
{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
{146F1A80-4791-11D0-A5D6-28DB04C10000}
{53172480-4791-11D0-A5D6-28DB04C10000}
{642F5D00-4791-11D0-A5D6-28DB04C10000}
|$ ATAVAWH
|$ AVH
|$ AWH
|$ E3
|$ UAVAWH
|$ UH
|$@A+
|$`E3
|$0E3
|Rich
|u9H!
}8L9>
~HD9~T
~HD9vTv-H
+|$Pu
+Cx;C|
+L$pA
0;nTr
040904B0
0A^_]
0A^_^
0A^A\_
0A_A^]
0A_A^_
0A_A^A\
0A_A^A\_^[]
0A_A^A]A\_
0A_A^A]A\_^[
0A_A^A]A\_^]
10.0.17763.1
10.0.17763.1 (WinBuild.160101.0800)
8)uRH
8A_A^A]A\_^][
8fzIz^
9:u|B
9_ t.H
9Chu*
A 9B t
A D8@xu
A H9A(u
A!@`I
A!4$H
A$9B$u
A(H9B(u
A;H$s
A@H9AHu
A]A\[]
A^A\]
A^A\][
A^A\_
A^A\_^]
A^A]_
A^A]_^[]
A^A]_^]
A^A]_^][
A^A]A\
A^A]A\_]
A_A]]
A_A]A\
A_A]A\_^
A_A]A\_^[]
A_A^]
A_A^_
A_A^A\
A_A^A\_]
A_A^A\_^
A_A^A\_^[]
A_A^A]
A_A^A]_]
A_A^A]_^
A_A^A]A\]
A_A^A]A\^[]
A_A^A]A\_
A_A^A]A\_^[
A_A^A]A\_^]
A9} t)
ACQUIRE
Ap9Al
Ap9Alu
APL9IHt
ATAUAVH
ATAUAWH
ATAVAWH
AXt=L
B.reloc
B.rsrc
B@D9A@u
B@H9A@
bGFIDS
Bp9Bl
C Ic@lA;@pt>B
C(H9B
C(H9D$xt/H
C/!>0
c\D8c8u@H
C<9E8s
C8;0u*E
Callee
Caller
CFeederInMXF::PutMessage
CFeederInMXF::SetState
CFeederOutMXF::ConsumeEvents
CFeederOutMXF::SetState
Class
CompanyName
ConservationIdleTime
CoreAudioBufferDuration
CPortClockWaveCyclic::GetCurrentPhysicalTime
CPortClockWaveCyclic::GetCurrentTime
CPortClockWaveCyclic::GetResolution
CPortClockWavePci::GetCurrentPhysicalTime
CPortClockWavePci::GetCurrentTime
CPortClockWavePci::GetResolution
CPortDMus::~CPortDMus
CPortDMus::DataRangeIntersection
CPortDMus::Init
CPortDMus::PinCount
CPortDMus::PowerChangeNotify
CPortDMus::ReleaseChildren
CPortDMus::RequestService
CPortFilterDMus::~CPortFilterDMus
CPortFilterDMus::Init
CPortFilterTopology::~CPortFilterTopology
CPortFilterTopology::Init
CPortFilterWaveCyclic::~CPortFilterWaveCyclic
CPortFilterWaveCyclic::Init
CPortFilterWavePci::~CPortFilterWavePci
CPortFilterWavePci::Init
CPortFilterWaveRT::~CPortFilterWaveRT
CPortFilterWaveRT::Init
CPortPinDMus::~CPortPinDMus
CPortPinDMus::Close
CPortPinDMus::ConnectMXFGraph
CPortPinDMus::DeleteMXFGraph
CPortPinDMus::Init
CPortPinDMus::PowerNotify
CPortPinDMus::ServeCapture
CPortPinDMus::SetMXFGraphState
CPortPinTopology::~CPortPinTopology
CPortPinTopology::Init
CPortPinWaveCyclic::~CPortPinWaveCyclic
CPortPinWaveCyclic::Close
CPortPinWaveCyclic::GetPosition
CPortPinWaveCyclic::Init
CPortPinWaveCyclic::PowerNotify
CPortPinWaveCyclic::RequestService
CPortPinWaveCyclic::SetDeviceState
CPortPinWaveCyclic::SynchronizedSetFormat
CPortPinWavePci::Close
CPortPinWavePci::GetPosition
CPortPinWavePci::Init
CPortPinWavePci::IrpSubmitted
CPortPinWavePci::MappingsCancelled
CPortPinWavePci::PinPropertyAllocatorFraming
CPortPinWavePci::PowerNotify
CPortPinWavePci::RequestService
CPortPinWavePci::SetDeviceState
CPortPinWaveRT::~CPortPinWaveRT
CPortPinWaveRT::Close
CPortPinWaveRT::DistributeDeviceState
CPortPinWaveRT::GetKsAudioPosition
CPortPinWaveRT::Init
CPortTopology::~CPortTopology
CPortTopology::DataRangeIntersection
CPortTopology::GetPinName
CPortTopology::Init
CPortTopology::PinCount
CPortTopology::PnpStop
CPortTopology::PowerChangeNotify
CPortTopology::ReleaseChildren
CPortWaveCyclic::~CPortWaveCyclic
CPortWaveCyclic::DataRangeIntersection
CPortWaveCyclic::Init
CPortWaveCyclic::PinCount
CPortWaveCyclic::PowerChangeNotify
CPortWaveCyclic::ReleaseChildren
CPortWavePci::~CPortWavePci
CPortWavePci::DataRangeIntersection
CPortWavePci::Init
CPortWavePci::PinCount
CPortWavePci::ReleaseChildren
CPortWavePci::RequestService
CPortWaveRT::~CPortWaveRT
CPortWaveRT::DataRangeIntersection
CPortWaveRT::Init
CPortWaveRT::PinCount
CPortWaveRT::PnpStop
CPortWaveRT::PowerChangeNotify
CPortWaveRT::ReleaseChildren
CRIM0
D$ E3
d$ E3
D$ E3
d$ E3
D$ E3
d$ E3
D$ E3
D$(E3
D$(f90t
D$(fD
d$@A+
D$@E3
D$@fD
D$`9^
D$`E3
D$`fD
D$`Hc
D$`Ic
d$0E3
D$0E3
D$0H+C8H
D$8E3
d$PE3
D$Pf!H
D$PfD
D$PHc
D$XE3
D$xv3H
D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGWGX;;;LS)(A;;GRGWGX;;;IU)
D;{8teH
D;ctu
D;kpu
D;L$Hr
D;RHt
D;RHu
D|$hI
D8{=t
D8{=u
D8A4t
D8Ayt
D8E(t
D8E)t
D8E'tQ
D9|$x
D9~ u:D8{=u43
D9~$u
D9~0}
D9A@u
D9d$xH
D9d$xt
D9d$xu
D9Q0t
D9x u
D9x$u
DeviceCharacteristics
DeviceExtensionSize should be either 0 or no less than PORT_CLASS_DEVICE_EXTENSION_SIZE.
DeviceType
DispatchSettings
DllInitialize
DllUnload
DMusic MPU-401 In 
DMusic MPU-401 Out 
DPinPropertyGetAudioBuffer
DrmAddContentHandlers
DrmCreateContentMixed
DrmDestroyContent
DrmForwardContentToDeviceObject
DrmForwardContentToFileObject
DrmForwardContentToInterface
DrmGetContentRights
drmk.sys
E 9MH
E(+C8
E(H9]
E0f!H
E8I!>
EF-7F
Enter Driver Start
Enter Driver Stop
en-US
EtwRegister
EtwRegisterClassicProvider
EtwSetInformation
EtwUnregister
EtwWriteTransfer
EventData
ExAcquireFastMutexUnsafe
ExAcquireSpinLockShared
ExAllocatePoolWithTag
Exclusive
ExEventObjectType
ExFreePoolWithTag
ExGetPreviousMode
Exit Driver Start
Exit Driver Stop
ExReleaseFastMutexUnsafe
ExReleaseSpinLockShared
ExSetTimerResolution
f9,Qu
f9AHt$H
f9AHt*
f9Aju
f9AZu
f9iHt
f9iHt"H
f9iHt$H
f9iHt&H
f9iHt.H
f9iHtYH
f9PHt+A
f9qHt
f9qHt"H
f9qHt$H
f9qHt%H
f9qHt&H
f9qHt(H
f9qHt*H
f9QHt,H
f9qHt6H
f9yHt
f9YHt
f9yHt
f9YHt
f9yHt
f9YHt
f9YHt"H
f9yHt"H
f9yHt$H
f9yHt&H
f9yHt(H
f9YHt5H
f9yXu
f9yZu
fA9hHt*
fA9rHtPE
fA9zHt.H
Failed CreatePortPinWaveRT from miniport
Failed to call miniport - Init
Failed to query interface from miniport
FAILED!
fD9#t
fD9$Fu
fD9;t
fD9?t
fD9<Bu
fD9aHt
fD9aHt H
fD9aHt!H
fD9aHt"H
fD9aHt#H
fD9aHt$H
fD9aHt%H
fD9aHt&H
fD9aHt(H
fD9aHt)H
fD9aHt*H
fD9aHt=H
fD9aHtE
fD9gjs
fD9iHt
fD9pHt&H
fD9pHt*H
fD9qHt
fD9qHt"H
fD9qHt&H
fD9't
fD9xHt-A
fD9yHt
fD9yHt H
fD9yHt"H
fD9yHt$H
fD9yHt7I
fD9yHt8H
fD9yhu
fD9yju
fE9<Fu
fE9zH
fE9zHt?@
ffffff
fffffff
FileDescription
FileVersion
G !plH
G !pp3
H!\$ A
H!\$(D
H!\$@
H!](H9
H!|$(
H!l$ H
H!L$xH
H!o(I
H!t$ I
H.data
H.idata
h.rdata
H;Jxt(H
H_^[]
H+D$pH
H+J`H
H+K0H
H+Q`H
H+S(H
H9]xt)H
H9_hu
H9{`u
H9{`u!
H9=89
H95P8
H99u@H
H9A u
H9A(udD
H9A(uID
H9A(uxD
H9A0u
H9A0utH
H9A8u
H9A8ug
H9B u
H9B u{H
H9B(unH
H9B0uaH
H9B8u~
H9B8uT
H9C|u
H9-c<
H9C0u
H9C8u
H9Ctu
H9D$pt$M
H9Ext#H
H9G t^
H9Gdu
H9Glu
H9-K:
H9kpt>L
H9l$@tnH
H9Q t
H9Q(t
H9Q8t
H9QHE
H9QHt
H9s t:L
H9S u
H9s(t
H9s@t:L
H9s8u
H9sht3
H9sxt:L
H9w@t
H9Z@t/
HA_A^_^][
hA_A^A]A\_^[]
hA_A^A]A\_^][
HAL.dll
HcC0L
HPAGE
I+O`H
I9)u2H
I9o|uDH
IcF0L
IdlePowerState
IgnoreErrors
ImmediateIdle
imp_WppRecorderReplay
Information
InternalName
Interrupt
InterruptAffinity
IoAcquireRemoveLockEx
IoAllocateMdl
IoAllocateWorkItem
IoAttachDeviceToDeviceStack
IoBuildDeviceIoControlRequest
IoBuildPartialMdl
IoBuildSynchronousFsdRequest
IoConnectInterrupt
IoCreateDevice
IoCreateDeviceSecure
IoDeleteDevice
IoDetachDevice
IoDeviceObjectType
IoDisconnectInterrupt
IofCallDriver
IofCompleteRequest
IoFileObjectType
IoFreeMdl
IoFreeWorkItem
IoGetCurrentProcess
IoGetDeviceObjectPointer
IoGetDeviceProperty
IoGetDmaAdapter
IoInitializeRemoveLockEx
IoInitializeTimer
IoIsWdmVersionAvailable
IoOpenDeviceInterfaceRegistryKey
IoOpenDeviceRegistryKey
IoQueueWorkItem
IoRegisterDeviceInterface
IoReleaseRemoveLockAndWaitEx
IoReleaseRemoveLockEx
IoReportTargetDeviceChangeAsynchronous
IoSetDeviceInterfaceState
IoStartTimer
IoSteerInterrupt
IoStopTimer
IoValidateDeviceIoControlAccess
IoWMIRegistrationControl
IoWMIWriteEvent
IPort::GetDeviceProperty should only be called at IRQL == PASSIVE_LEVEL.
IPort::Init should only be called at IRQL == PASSIVE_LEVEL.
IPort::NewRegistryKey should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::AllocateContiguousPagesForMdl has invalid parameter on TotalBytes.
IPortWaveRTStream::AllocateContiguousPagesForMdl should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::AllocatePagesForMdl has invalid parameter on TotalBytes.
IPortWaveRTStream::AllocatePagesForMdl should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::FreePagesFromMdl should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::GetPhysicalPageAddress should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::GetPhysicalPagesCount should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::MapAllocatedPages cannot accept a NULL MDL.
IPortWaveRTStream::MapAllocatedPages should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::MapAllocatedPages: the CacheType can only be MmNonCached, MmCached or MmWriteCombined.
IPortWaveRTStream::UnmapAllocatedPages should only be called at IRQL == PASSIVE_LEVEL.
IRP_MN_CANCEL_REMOVE_DEVICE
IRP_MN_CANCEL_STOP_DEVICE
IRP_MN_EJECT
IRP_MN_FILTER_RESOURCE_REQUIREMENTS
IRP_MN_PAGING_NOTIFICATION
IRP_MN_QUERY_BUS_INFORMATION
IRP_MN_QUERY_CAPABILITIES
IRP_MN_QUERY_DEVICE_RELATIONS
IRP_MN_QUERY_DEVICE_TEXT
IRP_MN_QUERY_ID
IRP_MN_QUERY_INTERFACE
IRP_MN_QUERY_PNP_DEVICE_STATE
IRP_MN_QUERY_REMOVE_DEVICE
IRP_MN_QUERY_RESOURCE_REQUIREMENTS
IRP_MN_QUERY_RESOURCES
IRP_MN_QUERY_STOP_DEVICE
IRP_MN_READ_CONFIG
IRP_MN_REMOVE_DEVICE
IRP_MN_SET_LOCK
IRP_MN_START_DEVICE
IRP_MN_STOP_DEVICE
IRP_MN_SURPRISE_REMOVAL
IRP_MN_UNKNOWN_0x0e
IRP_MN_WRITE_CONFIG
k4fA;
KeAcquireSpinLockAtDpcLevel
KeAcquireSpinLockRaiseToDpc
KeCancelTimer
KeClearEvent
KeEnterCriticalRegion
KeGetRecommendedSharedDataAlignment
KeInitializeDpc
KeInitializeEvent
KeInitializeMutex
KeInitializeSpinLock
KeInitializeTimer
KeInsertQueueDpc
KeLeaveCriticalRegion
KeLowerIrql
KeQueryActiveProcessorCountEx
KeQueryGroupAffinity
KeQueryPerformanceCounter
KeReleaseMutex
KeReleaseSpinLock
KeReleaseSpinLockFromDpcLevel
KeRemoveQueueDpc
KeSetEvent
KeSetSelectedCpuSetsThread
KeSetTimer
KeSetTimerEx
KeStackAttachProcess
KeStallExecutionProcessor
KeSynchronizeExecution
KeUnstackDetachProcess
KeWaitForMultipleObjects
KeWaitForSingleObject
KEYWD
KfRaiseIrql
KH!|$(L
Kh#op
kpH9kxt6L
kpI9/t<L
kPkQhS
ks.sys
KsAcquireResetValue
KsAddIrpToCancelableQueue
KsAddObjectCreateItemToDeviceHeader
KsAllocateDeviceHeader
KsAllocateObjectHeader
KsCancelIo
KsCancelRoutine
KsCreateDefaultAllocator
KsDefaultDeviceIoCompletion
KsDereferenceSoftwareBusObject
KsDisableEvent
KsDispatchInvalidDeviceRequest
KsDispatchIrp
KsEnableEvent
KsFreeDeviceHeader
KsFreeEventList
KsFreeObjectHeader
KsGenerateEvent
KsoOH
KsPinDataIntersection
KsPinPropertyHandler
KsProbeStreamIrp
KsPropertyHandler
KsReferenceSoftwareBusObject
KsReleaseIrpOnCancelableQueue
KsRemoveIrpFromCancelableQueue
KsRemoveSpecificIrpFromCancelableQueue
KsSetDevicePnpAndBaseObject
KsSetMajorFunctionHandler
KsSynchronousIoControlDevice
KsTopologyPropertyHandler
KsValidateClockCreateRequest
KsValidateConnectRequest
l$ E3
L$ E3
l$ E3
L$ SUVWATAUAVAWH
L$ SUVWH
L$ SVWATAUAVAWH
L$ UVWATAUAVAWH
L$ VWAVH
l$ VWAVH
L$(E3
L$@E3
L$@H!\$@
L$@H3
L$`A+
l$`H9+
L$0E3
L$0H+K@H
L$0H3
l$0IcA0= 
l$8E3
L$8fD
L$HA;
L$HH3
L$hH3
l$hH9i
L$PE3
L$PH3
L$pH3
L$PH3
L$xH3
L$XH3
L;w0H
L+A0A
L+A0L
L9&t4L
L9|$@u
L9A0u
L9bhu
L9IHt
L9l$ptXI
Leaking resources allocated by IPortWaveRTStream::AllocatePagesForMdl/AllocateContiguousPagesForMdl.
LegalCopyright
LEVL@
m_IrpStream->Release()
m_Miniport->AddRef()
m_Miniport->Release()
m_Miniport->Service()
m_MiniportMidiStream->Release()
m_MiniportMXF->Release()
m_MiniportMXF->SetState(KSSTATE_ACQUIRE)
m_MiniportMXF->SetState(KSSTATE_PAUSE)
m_MiniportMXF->SetState(m_DeviceState)
m_MPPinCountI->PinCount(PinId,FilterNecessary,FilterCurrent,FilterPossible,GlobalCurrent,GlobalPossible)
m_MPPinCountI->Release()
m_MPPinNameI->Release()
m_pIAudioEngine->Release()
m_Stream->Release()
m_Stream->SetNotificationFreq( WAVECYC_NOTIFICATION_FREQUENCY, &m_FrameSize )
m_Stream->SetState(KSSTATE_ACQUIRE)
m_Stream->SetState(KSSTATE_PAUSE)
m_Stream->SetState(KSSTATE_STOP)
m_Stream->SetState(m_DeviceState)
m_Stream->Silence( m_DmaChannel->SystemAddress(), m_ulDmaCopy + ulBytesToSilence - ulDmaBufferSize )
m_Stream->Silence( PVOID(PUCHAR(m_DmaChannel->SystemAddress()) + m_ulDmaCopy), ulBytesToSilence)
m_Stream->Silence(m_DmaChannel->SystemAddress(),m_DmaChannel->BufferSize())
M9.t~M
M9.t<L
M9h8t
M9i8t
Microsoft
Microsoft Corporation
Microsoft.Windows.Audio.PortClass
Miniport->AddRef()
Miniport->Release()
Miniport->Service()
MmAddVerifierSpecialThunks
MmAddVerifierThunks
MmAllocatePagesForMdl
MmAllocatePagesForMdlEx
MmAreMdlPagesCached
MmBuildMdlForNonPagedPool
MmFreePagesFromMdl
MmGetSystemRoutineAddress
MmIsDriverVerifying
MmIsVerifierEnabled
MmLockPagableDataSection
MmMapLockedPagesSpecifyCache
mmres.dll
MmUnlockPagableImageSection
MmUnmapLockedPages
MOFDATA
MStatus = Miniport->GetPosition( PULONGLONG( &StreamTime ) )
MXF H
MXFbH
MXFpA
NCPortPinWavePci::~CPortPinWavePci
NewState
NoDisplayClass
NoUseClass
NPI9^
ntoskrnl.exe
ntStatus
NTStatus
ntStatus
NTStatus
ntStatus = _streamNotification->AllocateBufferWithNotification( _notificationCount, finalRequestBufferSize, _pMDL, &returnBufferSize, _pOffsetFromFirstPag, _pCacheType )
ntStatus = _streamNotification->AllocateBufferWithNotification( _notificationCount, nextRequestedBufferSize, _pMDL, &returnBufferSize, _pOffsetFromFirstPag, _pCacheType )
ntStatus = m_Miniport->DataRangeIntersection( PinId, DataRange, MatchingDataRange, OutputBufferLength, ResultantFormat, ResultantFormatLength)
ntStatus = m_Miniport->GetDescription(&m_pPcFilterDescriptor)
ntStatus = m_Miniport->Init( UnknownAdapter, ResourceList, PPORTDMUS(this), &pServiceGroup)
ntStatus = m_MiniportMXF->ConnectOutput(m_CaptureSinkMXF)
ntStatus = m_MiniportStream->SetState(State)
ntStatus = m_MiniportStream->Write(aDMKEvt->uData.abData + byteOffset,bytesRemaining,&bytesWritten)
ntStatus = m_MiniportStream->Write(aDMKEvt->uData.pbData + byteOffset,bytesRemaining,&bytesWritten)
ntStatus = m_MPPinNameI->GetPinName(_pIrp,_pKsPPin,_pvData)
ntStatus = m_Port->m_Miniport->NewStream( &m_MiniportMXF, NULL, NonPagedPoolNx, m_Id, m_StreamType, m_DataFormat, &(m_ServiceGroup), (PAllocatorMXF)m_AllocatorMXF, (PMASTERCLOCK)this->m_Port, &SchedulePreFetch )
ntStatus = m_Port->m_MiniportMidi->NewStream( &m_MiniportMidiStream, NULL, NonPagedPoolNx, m_Id, m_StreamType == DMUS_STREAM_MIDI_CAPTURE ? TRUE : FALSE, m_DataFormat, &(m_ServiceGroup) )
ntStatus = m_Port->Miniport->NewStream( &m_Stream, NULL, NonPagedPoolNx, m_Id, m_DataFlow == KSPIN_DATAFLOW_OUT, m_DataFormat, &m_DmaChannel, &m_ServiceGroup )
ntStatus = m_Stream->GetPosition(&ulDmaPosition)
ntStatus = m_Stream->SetFormat(inDataFormat)
ntStatus = m_Stream->SetState(NewState)
ntStatus = Miniport->DataRangeIntersection( PinId, DataRange, MatchingDataRange, OutputBufferLength, ResultantFormat, ResultantFormatLength )
ntStatus = Miniport->GetDescription(&m_pPcFilterDescriptor)
ntStatus = Miniport->GetDeviceDescription (&m_DeviceDescription)
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTTOPOLOGY(this))
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVECYCLIC(this) )
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVEPCI(this), &ServiceGroup )
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVERT(this) )
ntStatus = Port->Miniport->NewStream ( &Stream, NULL, NonPagedPoolNx, PPORTWAVEPCISTREAM(this), Id, Descriptor->DataFlow == KSPIN_DATAFLOW_OUT, DataFormat, &DmaChannel, &ServiceGroup )
ntStatus = Port->Miniport->NewStream ( &Stream, PPORTWAVERTSTREAM(this), Id, Descriptor->DataFlow == KSPIN_DATAFLOW_OUT, DataFormat )
ntStatus = Stream->SetState(KSSTATE_ACQUIRE)
ntStatus = Stream->SetState(KSSTATE_PAUSE)
ntStatus = Stream->SetState(KSSTATE_STOP)
ntStatus = Stream->SetState(m_DeviceState)
ntStatus = Stream->SetState(NewState)
ntStatus = that->Stream->AllocateAudioBuffer (property->RequestedBufferSize, &that->rt.AudioBuffer.Mdl, &bufferSize, &byteOffset, &cacheType)
ntStatus = that->Stream->GetClockRegister (mapping)
ntStatus = that->Stream->GetPositionRegister (mapping)
ntStatus = that->Stream->SetFormat(FilteredDataFormat)
ntStatus = that->StreamInput->GetReadPacket(&value->PacketNumber, &value->Flags, &value->PerformanceCounterValue, &value->MoreData)
ntStatus = that->StreamNotification->AllocateBufferWithNotification( that->rt.NotificationCount, propertyNotification->RequestedBufferSize, &that->rt.AudioBuffer.Mdl, &bufferSize, &byteOffset, &cacheType )
ntStatus = that->StreamNotification->RegisterNotificationEvent( pNewEntry->pNotificationEvent )
ntStatus = that->StreamNotification->UnregisterNotificationEvent( pRemovedEvent->pNotificationEvent )
ntStatus = that->StreamOutput->GetOutputStreamPresentationPosition(value)
ntStatus = that->StreamOutput->GetPacketCount(packetCount)
ntStatus = that->StreamOutput->SetWritePacket(value->PacketNumber, value->Flags, value->EosPacketLength)
ntStatus= Stream->GetPosition(&pIrpStreamPosition->ullStreamPosition)
ntStatus2 = m_MiniportStream->Read(aMidiData,sizeof(PBYTE),&bytesRead)
ntStatus2 = that->Stream->SetState(KSSTATE_PAUSE)
ntStatus2 = that->Stream->SetState(KSSTATE_RUN)
O8H9Q
ObfDereferenceObject
ObfReferenceObject
ObOpenObjectByPointer
ObReferenceObjectByHandle
OldState
OPCOp
OriginalFilename
p AWH
p WATAUAVAWH
p WATAVH
p WAVAWH
P%PZP
P(QeQ
P?QqQ!R^R
P\QlR
P^RWS
P=PwP
p0D#t$pD
PA^^[
pA^_]
PA^_]
pA_A^_^]
PA_A^A\_^
PA_A^A]A\_^]
pA_A^A]A\_^]
PAGE$lp00portcls.sys!20_pri7
PAGE$lp01portcls.sys!20_pri7
PAGE$np
PAGE$zy
PAGE$zz
PAGEPcVf$zz
PAUSE
PcAddAdapterDevice
PcAddAdapterDevice should only be called at IRQL == PASSIVE_LEVEL.
PcAddContentHandlers
PcAddContentHandlers should only be called at IRQL == PASSIVE_LEVEL.
PcAddStreamResource
PcAssignPowerFrameworkSettings
PcCiH
PcCompleteIrp
PcCompleteIrp should only be called at IRQL <= DISPATCH_LEVEL.
PcCompletePendingPropertyRequest
PcCompletePendingPropertyRequest should only be called at IRQL <= DISPATCH_LEVEL.
PcCompletePendingPropertyRequest shouldn't be called with an NtStatus value of STATUS_PENDING.
PcCrA
PcCreateContentMixed
PcCreateContentMixed should only be called at IRQL == PASSIVE_LEVEL.
PcCrH
PcDestroyContent
PcDestroyContent should only be called at IRQL == PASSIVE_LEVEL.
PcDispatchIrp
PcDispatchIrp should only be called at IRQL == PASSIVE_LEVEL.
PcEiH
PcErH
PcEtH
PcForwardContentToDeviceObject
PcForwardContentToDeviceObject should only be called at IRQL == PASSIVE_LEVEL.
PcForwardContentToFileObject
PcForwardContentToFileObject should only be called at IRQL == PASSIVE_LEVEL.
PcForwardContentToInterface
PcForwardContentToInterface should only be called at IRQL == PASSIVE_LEVEL.
PcForwardIrpSynchronous
PcForwardIrpSynchronous should only be called at IRQL == PASSIVE_LEVEL.
PcGetContentRights
PcGetContentRights should only be called at IRQL == PASSIVE_LEVEL.
PcGetDeviceProperty
PcGetDeviceProperty should only be called at IRQL == PASSIVE_LEVEL.
PcGetPhysicalDeviceObject
PcGetTimeInterval
PcIcH
PcInitializeAdapterDriver
PcInitializeAdapterDriver : Invalid Parameter.
PcInitializeAdapterDriver should only be called at IRQL == PASSIVE_LEVEL.
PcIsH
PcLNf
PcLRH
PcMqH
PcNewDmaChannel
PcNewDmaChannel should only be called at IRQL == PASSIVE_LEVEL.
PcNewInterruptSync
PcNewInterruptSync should only be called at IRQL == PASSIVE_LEVEL.
PcNewMiniport
PcNewMiniport should only be called at IRQL == PASSIVE_LEVEL.
PcNewPort
PcNewPort should only be called at IRQL == PASSIVE_LEVEL.
PcNewRegistryKey
PcNewRegistryKey should only be called at IRQL == PASSIVE_LEVEL.
PcNewResourceList
PcNewResourceList should only be called at IRQL == PASSIVE_LEVEL.
PcNewResourceSublist
PcNewResourceSublist should only be called at IRQL == PASSIVE_LEVEL.
PcNewServiceGroup
PcNewServiceGroup should only be called at IRQL == PASSIVE_LEVEL.
PcNt9Q
PcNtA
PcNtfA
PcNtt
PcPrA
PcPrH
PcPwH
PcRegisterAdapterPnpManagement
PcRegisterAdapterPowerManagement
PcRegisterAdapterPowerManagement should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterIoTimeout
PcRegisterPhysicalConnection
PcRegisterPhysicalConnection should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterPhysicalConnectionFromExternal
PcRegisterPhysicalConnectionFromExternal should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterPhysicalConnectionToExternal
PcRegisterPhysicalConnectionToExternal should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterSubdevice
PcRegisterSubdevice should only be called at IRQL == PASSIVE_LEVEL.
PcRemoveStreamResource
PcRequestNewPowerState
PcRequestNewPowerState should only be called at IRQL == PASSIVE_LEVEL.
PcRlA
PcRLH
PcRMH
PcRPH
PcRtH
PcRvI
PcSbI
PcSiH
PcSlI
PcStH
PcTcH
PcUnregisterAdapterPnpManagement
PcUnregisterAdapterPowerManagement
PcUnregisterAdapterPowerManagement should only be called at IRQL == PASSIVE_LEVEL.
PcUnregisterIoTimeout
PcUsH
PcWCH
PEQ}Q
PerformanceIdleTime
pIMiniportAudioSignalProcessing->Release()
PinPropertyDataFormat
PinPropertyGetClockRegister
PinPropertyGetHWLatency
PinPropertyGetPositionRegister
PinPropertyHandler_GetOutputStreamPresentationPosition
PinPropertyHandler_GetPacketCount
PinPropertyHandler_GetReadPacket
PinPropertyHandler_SetWritePacket
PinPropertyNotificationEvent
PinPropertyPosition
pMiniportAudioSignalProcessing->Release()
pMiniportPnpNotify->PnpStop()
PoCallDriver
PoClearPowerRequest
PoCreatePowerRequest
PoDeletePowerRequest
PoFxActivateComponent
PoFxCompleteDevicePowerNotRequired
PoFxCompleteIdleCondition
PoFxCompleteIdleState
PoFxIdleComponent
PoFxPowerControl
PoFxRegisterDevice
PoFxReportDevicePoweredOn
PoFxSetDeviceIdleTimeout
PoFxStartDevicePowerManagement
PoFxUnregisterDevice
PoRegisterPowerSettingCallback
PoRequestPowerIrp
Port Class (Class Driver for Port/Miniport Devices)
PortCls
Portcls
portcls.pdb
portcls.sys
Portcls/Analytic
Portcls/Operational
Portcls/Performance
Portcls_Device_Initialization
Portcls_Device_Read
Portcls_Device_Stop
Portcls_Device_Write
PORTCLSMOF
PortclsMof
PoSetPowerRequest
PoSetPowerState
PoStartNextPowerIrp
PoUnregisterPowerSettingCallback
PowerSettings
pPowerNotify->PowerChangeNotify( PowerState )
pPowerNotify->PowerChangeNotify(PowerState)
pPowerNotify->Release()
PpRbH
ProbeForRead
ProductName
ProductVersion
Properties
PRVA$
PsGetVersion
PUNKNOWN(pMiniportPnpNotify)->Release()
Q(H9Zht
Q(QoQ
Q/QOQ
Q}RvV
Q>Q[QkQ
QJQiRGTzT
QMRhU*V}V
QYQmQ
R"RuR
R"TsT
R"TUT
R$fA;Z*
R?UtU
R^S{S
R~R7SkS
RefCount
Resolution->Granularity = Miniport->NormalizePhysicalPosition( &OneByte )
ResourceSet
Response Time
RetryAllocateBufferWithNotification
RIS|S
RtlAbsoluteToSelfRelativeSD
RtlAddAccessAllowedAce
RtlCompareUnicodeString
RtlCreateSecurityDescriptor
RtlFreeUnicodeString
RtlGetDaclSecurityDescriptor
RtlGetGroupSecurityDescriptor
RtlGetOwnerSecurityDescriptor
RtlGetSaclSecurityDescriptor
RtlInitUnicodeString
RtlLengthSecurityDescriptor
RtlLengthSid
RtlQueryRegistryValues
RtlQueryRegistryValuesEx
RtlSetDaclSecurityDescriptor
R'TUT
s D9u
S M;P u
S TLV
s WATAUAVAWH
s WAVAWH
S`H9*u
S+TEU
S4SDS
S7TjT
SBSnS
SeAccessCheckWithHint
SeAlA
SeCaptureSecurityDescriptor
SeCaptureSubjectContext
SeConvertStringSecurityDescriptorToSecurityDescriptor
Security
SeExports
SeReleaseSubjectContext
SeSdH
SeTsI
ShD9[d
SingleComponentMultiFxStates
SlfD+
SSTxTjU
Start
state
status
Status = Miniport->GetPosition( PULONGLONG( &PhysicalTime ))
Status = Miniport->NormalizePhysicalPosition( &PhysicalTime )
Status = Miniport->NormalizePhysicalPosition( &StreamTime )
status = Stream->SetState(state)
Status = WavePciPin->Stream->GetAllocatorFraming( AllocatorFraming )
Stream->FreeAudioBuffer (rt.AudioBuffer.Mdl, rt.AudioBufferSize)
Stream->GetPosition( &ullCurrentPosition )
Stream->GetPosition(&m_ullStreamSleepPosition)
Stream->GetPosition(pKsAudioPosition)
Stream->MappingAvailable()
Stream->Release()
Stream->RevokeMappings(FirstTag, LastTag, MappingsCancelled)
Stream->Service()
StreamInput->Release()
StreamNotification->FreeBufferWithNotification( rt.AudioBuffer.Mdl, rt.AudioBufferSize )
StreamNotification->Release()
StreamNotification->UnregisterNotificationEvent( pCurrentEntry->pNotificationEvent )
StreamOutput->Release()
StringFileInfo
SUVWATAUAVAWH
SVWATAUAVAWH
t$ ATAVAWH
t$ AWH
t$ E3
t$ UWATAVAWH
t$ UWAUAVAWH
t$ UWAWH
t$ WATAUAVAWH
t$ WAVAWH
t$ WH
t$(E3
t$(fA
T$@E3
T$`;n
t$pE3
t$PE3
t$pE3
T$pE3
T$XH9Z@uLH
t%H9X
T(UYU
t)H+Q
T*UaU
T.UWU
t?H9kxt9L
t@L!|$pM
t[H9s
t[H9y(tUL
t^8Q)rYI
t^H!D$pM
t|H9s
t1H9j
ta9{$r\
tAH9w
TASKD
t-H9Y
that->Stream->FreeAudioBuffer (that->rt.AudioBuffer.Mdl, bufferSize)
that->Stream->FreeAudioBuffer( that->rt.AudioBuffer.Mdl, bufferSize )
that->Stream->FreeAudioBuffer(that->rt.AudioBuffer.Mdl, bufferSize)
that->Stream->GetHWLatency (hwLatency)
that->Stream->MappingAvailable()
that->StreamNotification->FreeBufferWithNotification( that->rt.AudioBuffer.Mdl, bufferSize )
The MDL has been mapped already.
The MDL isn't unmapped before free.
The miniport driver should not call PoRequestPowerIrp with IRP_MN_SET_POWER.
The unmapped BaseAddress doesn't match the MDL.
This device is already registered by PcRegisterAdapterPowerManagement.
This device is not registered by PcRegisterAdapterPowerManagement.
Thread
Timeout on state transition by AVStrMiniPinSetDeviceState.
Timeout on state transition from KSSTATE_PAUSE to KSSTATE_RUN by AVStrMiniPinSetDeviceState.
Timeout on state transition from KSSTATE_STOP to KSSTATE_ACQUIRE by AVStrMiniPinSetDeviceState.
tJ;*sFH
tJH9q@t/H
tM8Q)rHI
tQ8Q)rLI
tr@8y)rlI
Translation
tSL9q@tMH
TsV,Y_Y
ttH!t$PL
TuU,X_X
tVHcG0L
twE8x0t
tYL92t
u A9J
U.UFU_U
u:fA9XZt3A
u;D9cht(H
u@M9y8u:A
U@VbX
u[f9kjtU
u+@8{=u
u0@8k=u
u0fD;
U3V7W
U6VrV
u8D9{
UATAVH
UAVAWH
uhM9x8ubA
UHWQ[
ulRefCount = m_Miniport->Release()
ulRefCount = m_MiniportMXF->Release()
Unknown
UNKNOWN
UsePositionLock
USVWATAUAVAWH
USVWATAUAWH
USVWATAVAWH
UtVdW
UVWATAUAVAWH
UVWATAVH
UVWAUAVH
UVWAVAWH
UWATAUAVH
UWATAVAWH
UWAUAVAWH
UWAVH
UYZauds
V$WDWTWzW
v(9^$
V(W;W]W
V)V@V
V.VIVbV
V.VOVoV
V@V}V
VarFileInfo
VeV}V
vo"Z6jwS
VS_VERSION_INFO
VWATAUAWH
VWATAVAWH
VWAUAVAWH
VWAVH
VZW)XUXpX
W,X3Y
W.WOW
W?WLY
W0WbW
W6XQX
WATAUAVAWH
WATAVH
WAUAVH
WAVAWH
wcschr
WCXDY
WDXgX
WEVT_TEMPLATE
win:Informational
win:ResponseTime
win:Start
win:Stop
WKXbX
WmiCompleteRequest
WMILIB.SYS
WmiQueryTraceInformation
WmiSystemControl
WmiTraceMessage
-WOWqW
WpH9_h
WppAutoLogStart
WppAutoLogStop
WppAutoLogTrace
WppRecorder.sys
WRYSZ
wx;CDt
W-YRYj\
x ATAUAVH
x ATAVAWH
x ATH
x AUAVAWH
x AVH
x AWH
x UATAUAVAWH
x UATAVH
x UAUAWH
X"[_[
X"Y<Z)\I\
X)XJXoX
X?XZX
x}L9u8
x+D8u0u/L
x+D8u0ukL
XA_A^A]A\_^][
xA8L$@t
XdvTimedFactor
Y!Z[ZzZ
Y#ZNZoZ
Y$Y;Y
Y/ZpZi^
Y:Z[ZoZJ]`]t]
Y>[\\
Y>[_[
YZZ}Z
Z*[I[
Z@ZVZ
Z=ZMZ
Z9[\[~[
ZK[a[1\l\h]
zpL1^0
zPMeSsk
ZwClose
ZwCreateKey
ZwDeleteKey
ZwEnumerateKey
ZwEnumerateValueKey
ZwOpenKey
ZwQueryKey
ZwQueryValueKey
ZwSetSecurityObject
ZwSetValueKey
