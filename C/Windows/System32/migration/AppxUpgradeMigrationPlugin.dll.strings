 A^_]
 A^_^
 A^A\_
 A_A^_
 A_A^_^]
 A_A^A\
 A_A^A\_^
 A_A^A]A\_
 A_A^A]A\_^]
 and backup manifest
 H3E H3E
 http://www.microsoft.com/windows0
 Microsoft Corporation. All rights reserved.
 Operating System
 Windows
!(wil::verify_bool(CopyFileW(srcPath.GetChars(), destPath.GetChars(), 0)))
!(wil::verify_bool(hKeepRunningThread))
!(wil::verify_bool(QueryServiceStatus(service.get(), &serviceStatus)))
!(wil::verify_bool(versionSize > 0))
!0H!t$ I
!AddAccessAllowedAceEx(acl, ACL_REVISION, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, KEY_READ, packageSid)
!CreatePrivateObjectSecurityEx( oldSecurityDescriptor, securityDescriptorToAppend, &newSecurityDescriptor, nullptr, TRUE, SEF_DACL_AUTO_INHERIT | SEF_DEFAULT_GROUP_FROM_PARENT | SEF_DEFAULT_OWNER_FROM_PARENT | SEF_AVOID_OWNER_CHECK, nullptr, &mapping)
!D$HI
!D$HM
!InitializeAcl(acl, requiredSize, ACL_REVISION)
!InitializeSecurityDescriptor(securityDescriptorToAppend, SECURITY_DESCRIPTOR_REVISION)
!SetSecurityDescriptorControl(newSecurityDescriptor, SE_DACL_AUTO_INHERIT_REQ, SE_DACL_AUTO_INHERIT_REQ)
!SetSecurityDescriptorDacl(securityDescriptorToAppend, TRUE, acl, FALSE)
!t$pE
!This program cannot be run in DOS mode.
"Microsoft Window
"system">
"user">
$`2X`F
$Microsoft Ireland Operations Limited1
$Microsoft Ireland Operations Limited1&0$
%|fUN<
%CSIDL_LOCAL_APPDATA%\Microsoft\Windows\Notifications
%CSIDL_LOCAL_APPDATA%\Packages\$\SystemAppData
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%d)\%hs!%p: 
%Microsoft Windows Production PCA 2011
%Microsoft Windows Production PCA 20110
%ProgramData%\Microsoft\Windows\AppRepository
%ProgramData%\Microsoft\Windows\AppRepository\CheckPoint.VPN_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\f5.vpn.client_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\FileManager_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\JuniperNetworks.JunosPulseVpn_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\Microsoft.MoCamera_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\SonicWALL.MobileConnect_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\windows.immersivecontrolpanel_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\winstore_*_cw5n1h2txyewy.xml
%ProgramFiles%\WindowsApps\
%s file does not exist
%s file exists
%s package is paused so its package root%s will be excluded
%s service status = 0x%x
%s\%s
%s_%s_%s_%s
%SystemRoot%\System32\
%ws: %ws
&@8~8t
(_^][
(caller: %p) 
(D$PL
(u0U0
)_% z
)Microsoft Root Certificate Authority 20100
)onecore\base\appmodel\runtime\src\systemmetadatainternal.cpp
*L9e8t:M
,45rTznX0lCJdFgP1NgKPJscHxGueerKGk4X4KXxqhMU=0Z
... Package %ws is all-user installed so no need to write its upgrade key
... Package %ws is being end of lifed so it's being written to the EndOfLife key
... Package %ws is dev mode. Writing to upgrade keys
... Package %ws is LOB so no need to write its upgrade key
... Package %ws is NOT being end of lifed so it's being written to the Downlevel Installed key
... Package %ws is not installed. Nothing to do
... Package %ws is OEM so no need to write its upgrade key
... Package's root is %ws
... Unable to process recovery info for package 0x%x. Assume this app is fully on system volume
.?AVexception@@
.?AVResultException@wil@@
.00cfg
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.data
.data$brc
.data$r$brc
.edata
.gfids
.giats
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.pdata
.rdata
.rdata$brc
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.recovery
.rsrc$01
.rsrc$02
.text
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.xdata
.xdata$x
.xn--
/OfflineSoftwareHive:"
:%|fUu3
:97t6A
??0exception@@QEAA@AEBV0@@Z
??0exception@@QEAA@XZ
??1exception@@UEAA@XZ
??1type_info@@UEAA@XZ
?terminate@@YAXXZ
@.data
@.reloc
@.rsrc
@8,1u
@8|$0t
@8|$0u2M
@8t$@u\
@8y(t
@A^_]
@A^_^][
@A_A^_^]
@A_A^A\_^
@A_A^A]_^
@A_A^A]A\_^[
@A_A^A]A\_^]
@FamilyName
@FullName
@IsLOBApp
@PackageType
@ProvisionSourceIsBundle
@SUVWATAUAVAWH
@SUVWAVH
@SVWH
@USVWATAUAVAWH
@USVWATAUAVH
@USVWATAVAWH
@USVWAUAVAWH
@USVWAVAWH
@USVWAVH
@USWH
@UVWATAUAVAWH
@UVWAVAWH
@UVWH
[ UVWH
[%hs(%hs)]
[%hs]
[Desktop Only]Package family %ws is end-of-lifed
\$ E3
\$ UH
\$ UVWAVAWH
\$pE3
\* [*]</pattern>
\*.xml
\\?\UNC\
\Applications\
\AppxManifest.xml
\AppxMetadata\AppxBundleManifest.xml
\Autogen
\Frameworks\
\InfusedApps
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Families
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
\microsoft.system.package.metadata
\OSRollbackPackages.txt
\Packages\
\PluginExecutedFixStateRepository
]</pattern>
]8H!]0H!]@H
]HD8}8
]HfA;
__C_specific_handler
__CxxFrameHandler3
__dllonexit
_amsg_exit
_Classes
_CxxThrowException
_initterm
_lock
_onexit
_purecall
_unlock
_vsnprintf_s
_vsnwprintf
_wcsicmp
_wcsnicmp
_XcptFilter
` UAVAWH
`.rdata
`A_A^_^]
`A_A^A\^]
`A_A^A]A\_^]
{8uOH
|$ AVH
|$ E3
|$ UH
|$@L9t$8u
|$`D8|$@
|$<98
|hK,_
}0H+}(H
}7H9u/u
}7L9}/u
}bwu3
}HD8}8
~0uUH
</objectSet></exclude>
</objectSet></include>
</objectSet></locationModify>
</objectSet></merge>
</objectSet></unconditionalExclude>
</rules></migXml>
<?xml version="1.0" encoding="utf-8"?><xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:element name="AppxProvisionList">  <xs:complexType>    <xs:all>      <xs:element name="EndOfLife" type="CT_EndOfLife" minOccurs="0"/>      <xs:element name="Provisioned" type="CT_Provisioned" minOccurs="0"/>    </xs:all>  </xs:complexType>  <xs:unique name="Package_FamilyName">    <xs:selector xpath="m:EndOfLife/m:Package"/>    <xs:field xpath="@FamilyName"/>  </xs:unique>  <xs:unique name="Package_FullName">    <xs:selector xpath="m:Provisioned/m:Package"/>    <xs:field xpath="@FullName"/>  </xs:unique></xs:element><xs:complexType name="CT_EndOfLife">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FamilyName" type="ST_FamilyName" use="required"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:complexType name="CT_Provisioned">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FullName" type="ST_FullName" use="required"/>        <xs:attribute name="PackageType" type="ST_PackageType"/>        <xs:attribute name="ProvisionSourceIsBundle" type="xs:boolean"/>        <xs:attribute name="IsLOBApp" type="xs:boolean"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:simpleType name="ST_FamilyName">  <xs:restriction base="xs:string">    <xs:minLength value="17"/>    <xs:maxLength value="64"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_FullName">  <xs:restriction base="xs:string">    <xs:minLength value="30"/>    <xs:maxLength value="127"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_PackageType">  <xs:restriction base="xs:string">    <xs:enumeration value="resource"/>    <xs:enumeration value="framework"/>    <xs:enumeration value="bundle"/>  </xs:restriction></xs:simpleType></xs:schema>
<D9?t
<exclude><objectSet>
<include><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%ProgramFiles%\WindowsApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime&apos;)"><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%windir%\InfusedApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime\InfusedApps&apos;)"><objectSet>
<merge script="MigXmlHelper.DestinationPriority()"><objectSet>
<merge script="MigXmlHelper.SourcePriority()"><objectSet>
<migXml xmlns=""><rules context=
<pattern type="File">
<pattern type="Registry">
<String too big>
<unconditionalExclude><objectSet>
>ARI8u
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>http://www.microsoft.com/pki/certs/MicTimStaPCA_2010-07-01.crt0
040904B0
0A^_^
0A_A^]
0A_A^_
0A_A^_^]
0A_A^A\
0A_A^A\_^
0A_A^A\_^[]
0A_A^A]A\_
0A_A^A]A\_^]
1(0&0
1/0-0
10.0.17763.1
10.0.17763.1 (WinBuild.160101.0800)
100701213655Z
111019184142Z
1234567890abcdefghjkmnpqrstvwxyzABCDEFGHJKMNPQRSTVWXYZ
180703204550Z
180823202654Z
190726204550Z0p1
191123202654Z0
1http://www.microsoft.com/PKI/docs/CPS/default.htm0@
20180915013602.039Z0
20180915065459Z
20180916065459Z0w0=
229879+4379540
250701214655Z0|1
261019185142Z0
5fD9g
8A^_^[
90v&H
9A98u6A9x
9N4t<
9N4tJ
9O$tE
9O4t<
9O4t2
9O4t6
a tMH
A!4$I
A(;A,H
A(t&H
A,9A(
A^_^[]
A^A\]
A^A]]
A^A]_^]
A^A]A\_]
A^A]A\_^[]
A_A\]
A_A]]
A_A]A\_]
A_A^]
A_A^_^[]
A_A^_^]
A_A^_^][
A_A^A\
A_A^A\_]
A_A^A\_^
A_A^A\_^[]
A_A^A]_]
A_A^A]_^
A_A^A]_^[]
A_A^A]A\]
A_A^A]A\_
A_A^A]A\_^[]
A_A^A]A\_^]
A_A^A]A\_^][
A8_8t
A9~(v'
A9~0u
A9u0t?
A9u0t5H!t$ H
AcquireSRWLockExclusive
AcquireSRWLockShared
AddAccessAllowedAceEx
AddPackageRegistryKeyToArray(fullName, &bundleFullNames)
AddPackageRegistryKeyToArray(fullName, &packageFullNames)
AddUplevelPackageToDelete(subKey, keysToDelete)
ADVAPI32.dll
AllowRegistryKeyReadForPackage failed: [%s]0x%x
allUserApplicationsKey.CopyTree(packageToWrite, mainPackageKey)
allUserApplicationsKey.DeleteSubKeyTree(keysToDelete[i]->GetChars())
allUserApplicationsKey.Open(HKEY_LOCAL_MACHINE, allUserStoreApplicationsPath.GetChars(), KEY_READ)
allUserApplicationsKey.OpenSubKey(subKey, KEY_READ, &mainPackageKey)
allUserApplicationsKey.SetUInt32Value(regIuiPolicyCheckedString, 1)
allUserKey.Open(HKEY_LOCAL_MACHINE, allUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &deprovisionedKey)
allUserStoreKey.GetKeySecurity(DACL_SECURITY_INFORMATION, allUserStoreSD)
allUserStoreKey.Open( HKEY_LOCAL_MACHINE, allUserStorePath, KEY_READ | KEY_WRITE | WRITE_DAC)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, allUserStorePath.GetChars(), KEY_READ | KEY_WRITE)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, offlineAllUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.OpenSubKey( L"Applications", KEY_READ | KEY_WRITE | WRITE_DAC, &allUserApplicationsKey)
allUserStoreKey.OpenSubKey( L"EndOfLife", KEY_READ | KEY_WRITE | WRITE_DAC, &endOfLifeKey)
allUserStoreKey.OpenSubKey( L"Staged", KEY_READ | KEY_WRITE | WRITE_DAC, &stagedKey)
allUserStoreKey.OpenSubKey(L"Staged", KEY_READ, &allUserStagedKey)
api-ms-win-appmodel-runtime-l1-1-1.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-heap-obsolete-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-0.dll
api-ms-win-core-libraryloader-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-version-l1-1-0.dll
api-ms-win-core-winrt-error-l1-1-0.dll
api-ms-win-core-winrt-l1-1-0.dll
api-ms-win-core-winrt-string-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-security-base-l1-1-0.dll
api-ms-win-security-provider-l1-1-0.dll
api-ms-win-security-sddl-l1-1-0.dll
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-winsvc-l1-1-0.dll
AppDataVolumeKey
AppDataVolumeName
AppDB
appdb.dat
AppendPackagePathAndApplyTrustLabel(offlinePackagePath.GetChars(), applicationPath, offlineSoftwareHive, cmdLineBuilder)
APPID
Applications
applicationsPathBuilder.AppendString(Common::Deployment::applicationsDir)
applicationsPathBuilder.AppendString(infusedAppsFolder.GetChars())
ApplySuccessFailed
ApplyTrustLabel(cmdLineBuilder.GetChars())
ApplyTrustLabelToPackages failed 0x%x
ApplyTrustLabelToPackagesUnderRegistryKey(&packageFamilyKey, applicationPath, offlineSoftwareHive, cmdLineBuilder)
ApplyTrustOffline.exe
AppModelPackageRepository
AppReadiness
Appx Migration Plugin called RtlGetDeviceFamilyInfoEnum: downlevelOSVersion=0x%x
Appx Migration Plugin called SRCheckIntegrity(%s): Entrypoint not found (0x%x)
Appx Migration Plugin called SRCheckIntegrity(%s): Module not loaded (0x%x)
Appx Migration Plugin version number is %d.%d.%d.%d
Appx Migration Plugin will not perform re-registration of Packages (OSupgradeInPlace)
Appx Migration Plugin will perform re-registration of Packages (OSswap)
Appx Upgrade Migration Plugin
AppX*
AppxAllUserStore
AppxAllUserStore::GetAllUserApplicationsFullPath(&allUserStoreApplicationsPath)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePath)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePathBuffer)
AppxAllUserStore::GetAllUserStoreFullPath(&usersPath)
AppxAllUserStore::GetDeprovisionedFullPath(&deprovisionKeyPath)
AppxAllUserStore::GetDeprovisionedFullPath(&deprovisionKeyPathBuffer)
AppxAllUserStore::GetEndOfLifeApplicationsFullPath(&endOfLifePath)
AppxAllUserStore::GetInboxApplicationsFullPath(&inboxPackagesBuffer)
AppxAllUserStore::GetStagedApplicationsFullPath(&allUserStoreStagedPath)
AppxAllUserStore::GetUpgradeApplicationsFullPath(&upgradePath)
AppxCleanupOrphanPackages
AppxCleanupOrphanPackages()
AppxCleanupSystemAppsMigratedToFOD
AppxCleanupSystemAppsMigratedToFOD()
AppxDeploymentClient.dll
AppxDestagePackage
appxFactory->CreateBundleManifestReader(manifestStream.Get(), bundleManifestReader.GetAddressOf())
AppxManifest.xml
AppxMetadata\AppxBundleManifest.xml
AppxPackageVolumes
AppxPreRegisterAllInboxPackages
AppxPreRegisterAllInboxPackages failed: 0x%x
AppxPreRegisterPackage
AppxProvisioning.xml
AppxProvisionList
AppxRoot
AppxStateChange
AppxSvc
AppxUpgradeMigration discontinuing plug-in timeout extension.
AppxUpgradeMigration executing longer than expected.
AppXUpgradeMigration exiting.
AppXUpgradeMigration signaling extension thread.
AppxUpgradeMigration::Discover called
AppxUpgradeMigration::Discover done (0x%x)
AppxUpgradeMigration::Gather called
AppxUpgradeMigrationPlugin.dll
APPXUPGRADEMIGRATIONPLUGIN.dll
AppxUpgradeMigrationPlugin.dll
AppxUpgradeMigrationPlugin.pdb
arm64
ATAVAWH
ATL$__a
ATL$__m
ATL$__z
AutoCheckIntegrity
Autogen
backupManifestPathBuilder.AppendString(backupManifestDir.GetString())
backupManifestPathBuilder.AppendString(L".xml")
backupManifestPathBuilder.AppendString(L"\\")
backupManifestPathBuilder.AppendString(package)
bstrOnlineFilePath.CopyFromString(onlineFilePath)
bstrOnlineRegistryPath.CopyFromString(onlineRegistryPathBuffer.GetChars())
bstrPath.CopyFromString(path.GetChars())
bstrSisPath.CopyFromString(sisPath)
bundle
Bundle %ws is being written to the downlevel installed key
bundleFullName->SetValueFromString(packageFullName.GetRawBuffer(nullptr))
bundleInfo->get_Id(&packageId)
bundleManifestReader->GetPackageInfoItems(&packages)
BX9A4t
C @8}Wu
C9fD9?u-
callContext
CallContext:[%hs] 
Calling ApplyTrustLabel
Calling DeleteOSRollbackPackagesRegistry
Calling SavePackageListFromFileToRegistry
CallRtlGetDeviceFamilyInfoEnumIfFunctionAvailable(nullptr, &deviceFamily, nullptr)
Cannot find package %ws in SIS, not writing to Staged Key
CheckIfLowerVersionPackageShouldBePreserved(packageManager, existingFullName, packageFamilyName->GetChars(), &preservePackage)
CheckIfLowerVersionPackageShouldBePreserved(packageManager, packageFullName, familyName.GetChars(), &preservePackage)
CheckIfLowerVersionPackageShouldBePreserved(packageManager, packageFullName, packageFamilyName->GetChars(), &preservePackage)
CheckOrFixStateRepositoryViaExport called to %s
CheckOrFixStateRepositoryViaExport done %s. Disposition: %d
CheckRepository(Fix) reports Disposition=%d, #ErrorsCorrected=%I64u
Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a
Cleaning up orphan packages from downlevel OS
Cleaning up SystemApps migrated to FOD
CloseHandle
CloseServiceHandle
CloseThreadpoolTimer
cmdLine.get() != nullptr
cmdLineBuilder.AppendChar(L' ')
cmdLineBuilder.AppendChar(L'\"')
cmdLineBuilder.AppendString(applicationPath)
cmdLineBuilder.AppendString(offlineSoftwareHive)
cmdLineBuilder.AppendString(offlineSoftwareHiveParam)
cmdLineBuilder.AppendString(packagePath)
CoCreateInstance
CoCreateInstance( __uuidof(AppxBundleFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IAppxBundleFactory), &appxFactory)
CoCreateInstance( __uuidof(OpcFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IOpcFactory), &opcFactory)
CoGetApartmentType
com1.
com2.
com3.
com4.
com5.
com6.
com7.
com8.
com9.
Common::Deployment::Configuration::GetPackageRepositoryRoot(&repositoryRoot)
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&endOfLifeKey, [&](PCWSTR userSid, Common::RegistryKey* key) -> HRESULT { RETURN_HR_IF(S_OK, *isPackageEndOfLife); Common::RegistryKey userSidKey; RETURN_IF_FAILED(key->OpenSubKey(userSid, KEY_READ, &userSidKey)); RETURN_IF_FAILED(userSidKey.KeyExists(packageFullName, isPackageEndOfLife)); return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&packageFamilyKey, [&](PCWSTR fullName, Common::RegistryKey*) -> HRESULT { bool exists = false; RETURN_IF_FAILED(PackageDirectoryExists(fullName, &exists)); if (!exists) { WriteLog(0, L"Package %ws does not exist in SIS. Don't carry it forward", fullName); Common::StringBuffer fullPath; Common::StringBufferBuilder pathBuilder(&fullPath); RETURN_IF_FAILED(pathBuilder.AppendString(path->GetString())); RETURN_IF_FAILED(pathBuilder.AppendString(familyName)); RETURN_IF_FAILED(pathBuilder.AppendString(L"\\")); RETURN_IF_FAILED(pathBuilder.AppendString(fullName)); RETURN_IF_FAILED(this->excludeRegistriesSet.InsertIgnoreDuplicates(fullPath.GetChars())); } else { foundAnyPackagesInFamily = true; } return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&packageFamilyKey, [&](PCWSTR fullName, Common::RegistryKey*) -> HRESULT { WriteLog(0, L"Processing Staged package %ws for preregister", fullName); this->indent++; const HRESULT hrEnsureAutogenDeleted = EnsureAutogenDeleted(fullName); if (FAILED_LOG(hrEnsureAutogenDeleted)) { WriteLog(1, L"Ignoring error: Package %ws failed to ensure deleted Autogen: 0x%x", fullName, hrEnsureAutogenDeleted); } if (Common::Deployment::IsPackageFullNameBundle(fullName)) { RETURN_IF_FAILED(AddPackageRegistryKeyToArray(fullName, &bundleFullNames)); } else { RETURN_IF_FAILED(AddPackageRegistryKeyToArray(fullName, &packageFullNames)); } this->indent--; return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&packageFamilyKey, [&](PCWSTR fullName, Common::RegistryKey*) -> HRESULT { WriteLog(0, L"Processing Staged package %ws to copy metadata", fullName); Common::StringBuffer metadataFolderInSharedLimitedTime; RETURN_IF_FAILED(GetMetadataFolderForPackage(fullName, true , &metadataFolderInSharedLimitedTime)); bool packageExistsInSharedLimitedTime = false; RETURN_IF_FAILED(Common::DirectoryExists(metadataFolderInSharedLimitedTime.GetChars(), &packageExistsInSharedLimitedTime)); if (!packageExistsInSharedLimitedTime) { return S_OK; } WriteLog(0, L"SharedLimitedTime metadata directory exists: Preparing to copy metadata"); Common::StringBuffer metadataFolder; RETURN_IF_FAILED(GetMetadataFolderForPackage(fullName, false , &metadataFolder)); bool metadataExistsInPackageRoot = false; RETURN_IF_FAILED(Common::DirectoryExists(metadataFolder.GetChars(), &metadataExistsInPackageRoot)); if (!metadataExistsInPackageRoot) { WriteLog(0, L"SharedLimitedTime metadata directory exists but metadata directory does not exist for %ws. Not copying files", fullName); return S_OK; } RETURN_IF_FAILED(RecursiveCopyDirectoryExceptAutogen(metadataFolderInSharedLimitedTime.GetChars(), metadataFolder.GetChars())); return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&stagedKey, [&](PCWSTR familyName, Common::RegistryKey* key) -> HRESULT { Common::RegistryKey packageFamilyKey; RETURN_IF_FAILED(key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)); Common::Array<Common::StringBuffer> packageFullNames; Common::Array<Common::StringBuffer> bundleFullNames; RETURN_IF_FAILED(Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&packageFamilyKey, [&](PCWSTR fullName, Common::RegistryKey*) -> HRESULT { WriteLog(0, L"Processing Staged package %ws to copy metadata", fullName); Common::StringBuffer metadataFolderInSharedLimitedTime; RETURN_IF_FAILED(GetMetadataFolderForPackage(fullName, true , &metadataFolderInSharedLimitedTime)); bool packageExistsInSharedLimitedTime = false; RETURN_IF_FAILED(Common::DirectoryExists(metadataFolderInSharedLimitedTime.GetChars(), &packageExistsInSharedLimitedTime)); if (!packageExistsInSharedLimitedTime) { return S_OK; } WriteLog(0, L"SharedLimitedTime metadata directory exists: Preparing to copy metadata"); Common::StringBuffer metadataFolder; RETURN_IF_FAILED(GetMetadataFolderForPackage(fullName, false , &metadataFolder)); bool metadataExistsInPackageRoot = false; RETURN_IF_FAILED(Common::DirectoryExists(metadataFolder.GetChars(), &metadataExistsInPackageRoot)); if (!metadataExistsInPackageRoot) { WriteLog(0, L"SharedLimitedTime metadata directory exists but metadata directory does not exist for %ws. Not copying files", fullName); return S_OK; } RETURN_IF_FAILED(RecursiveCopyDirectoryExceptAutogen(metadataFolderInSharedLimitedTime.GetChars(), metadataFolder.GetChars())); return S_OK; })); return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&this->pluginPackagesToCheckForStagingCompletionKey, [&](PCWSTR subKeyName, Common::RegistryKey*) -> HRESULT { this->indent++; WriteLog(0, L"PackagesToCheckForStagingCompletion: %ws", subKeyName); this->indent--; RETURN_IF_FAILED(packagesToCheckForStagingCompletion->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())); return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&this->pluginPackagesToRemoveKey, [&](PCWSTR packageFullName, Common::RegistryKey*) -> HRESULT { this->context->ResetPluginTimer(); const HRESULT hrDestagePackage = AppxDestagePackage(Microsoft::WRL::Wrappers::HStringReference(packageFullName).Get()); WriteLog(0, L"Package %ws destage completed with hr = 0x%x.\n", packageFullName, hrDestagePackage); return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&upgradeKey, [&](PCWSTR userSid, Common::RegistryKey*) -> HRESULT { Common::RegistryKey userSidKey; RETURN_IF_FAILED(upgradeKey.OpenSubKey(userSid, KEY_READ, &userSidKey)); Common::StringBuffer fullPathToUserSidKey; Common::StringBufferBuilder pathBuilder(&fullPathToUserSidKey); RETURN_IF_FAILED(pathBuilder.AppendString(upgradePath.GetString())); RETURN_IF_FAILED(pathBuilder.AppendString(userSid)); RETURN_IF_FAILED(pathBuilder.AppendString(L"\\")); RETURN_IF_FAILED(ExcludePackagesWithinKey(&userSidKey, &fullPathToUserSidKey)); return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(key, [&](PCWSTR familyName, Common::RegistryKey*) -> HRESULT { Common::RegistryKey packageFamilyKey; RETURN_IF_FAILED(key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)); bool foundAnyPackagesInFamily = false; RETURN_IF_FAILED(Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&packageFamilyKey, [&](PCWSTR fullName, Common::RegistryKey*) -> HRESULT { bool exists = false; RETURN_IF_FAILED(PackageDirectoryExists(fullName, &exists)); if (!exists) { WriteLog(0, L"Package %ws does not exist in SIS. Don't carry it forward", fullName); Common::StringBuffer fullPath; Common::StringBufferBuilder pathBuilder(&fullPath); RETURN_IF_FAILED(pathBuilder.AppendString(path->GetString())); RETURN_IF_FAILED(pathBuilder.AppendString(familyName)); RETURN_IF_FAILED(pathBuilder.AppendString(L"\\")); RETURN_IF_FAILED(pathBuilder.AppendString(fullName)); RETURN_IF_FAILED(this->excludeRegistriesSet.InsertIgnoreDuplicates(fullPath.GetChars())); } else { foundAnyPackagesInFamily = true; } return S_OK; })); if (!foundAnyPackagesInFamily) { WriteLog(0, L"Package family %ws does not exist in SIS. Don't carry it forward", familyName); Common::StringBuffer fullPath; Common::StringBufferBuilder pathBuilder(&fullPath); RETURN_IF_FAILED(pathBuilder.AppendString(path->GetString())); RETURN_IF_FAILED(pathBuilder.AppendString(familyName)); RETURN_IF_FAILED(this->excludeRegistriesSet.InsertIgnoreDuplicates(fullPath.GetChars())); } return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(registryKey, [&](PCWSTR familyName, Common::RegistryKey* key) -> HRESULT { Common::RegistryKey packageFamilyKey; RETURN_IF_FAILED(key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)); Common::Array<Common::StringBuffer> packageFullNames; Common::Array<Common::StringBuffer> bundleFullNames; RETURN_IF_FAILED(Common::Deployment::EnumKeyAndDoActionForAllSubkeys(&packageFamilyKey, [&](PCWSTR fullName, Common::RegistryKey*) -> HRESULT { WriteLog(0, L"Processing Staged package %ws for preregister", fullName); this->indent++; const HRESULT hrEnsureAutogenDeleted = EnsureAutogenDeleted(fullName); if (FAILED_LOG(hrEnsureAutogenDeleted)) { WriteLog(1, L"Ignoring error: Package %ws failed to ensure deleted Autogen: 0x%x", fullName, hrEnsureAutogenDeleted); } if (Common::Deployment::IsPackageFullNameBundle(fullName)) { RETURN_IF_FAILED(AddPackageRegistryKeyToArray(fullName, &bundleFullNames)); } else { RETURN_IF_FAILED(AddPackageRegistryKeyToArray(fullName, &packageFullNames)); } this->indent--; return S_OK; })); Common::Array<Common::StringBuffer>* fullNameListToPreRegister = bundleFullNames.IsEmpty() ? &packageFullNames : &bundleFullNames; for (size_t i = 0; i < fullNameListToPreRegister->Count(); i++) { PCWSTR fullName = (fullNameListToPreRegister->At(i))->GetChars(); WriteLog(0, L"PreRegistering Staged package %ws", fullName); this->context->ResetPluginTimer(); const HRESULT hrAppxPreRegisterPackage = this->AppxPreRegisterPackage(fullName, preRegisterOptions); if (FAILED_LOG(hrAppxPreRegisterPackage)) { WriteLog(1, L"Ignoring error: Package %ws failed to preregister: 0x%x", fullName, hrAppxPreRegisterPackage); } } return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(registryKey, [&](PCWSTR familyName, Common::RegistryKey* key) -> HRESULT { Common::RegistryKey packageFamilyKey; RETURN_IF_FAILED(key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)); RETURN_IF_FAILED(ApplyTrustLabelToPackagesUnderRegistryKey(&packageFamilyKey, applicationPath, offlineSoftwareHive, cmdLineBuilder)); return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(registryKey, [&](PCWSTR fullName, Common::RegistryKey*) -> HRESULT { WriteLog(0, L"Processing package %ws for ApplyTrustLabel", fullName); this->indent++; Common::RegistryKey packageFullNameKey; RETURN_IF_FAILED(registryKey->OpenSubKey(fullName, KEY_READ, &packageFullNameKey)); Common::StringBuffer packagePath; RETURN_IF_FAILED(packageFullNameKey.GetStringValue(L"Path", &packagePath)); Common::StringBufferBuilder packagePathBuilder(&packagePath); if (Common::String::CaseInsensitiveEndsWith(packagePathBuilder.GetChars(), packagePathBuilder.GetLength(), appxManifestRelativePath, (ARRAYSIZE(appxManifestRelativePath) - 1))) { RETURN_IF_FAILED(packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxManifestRelativePath) - 1))); } else { if (Common::String::CaseInsensitiveEndsWith(packagePathBuilder.GetChars(), packagePathBuilder.GetLength(), appxBundleManifestRelativePath, (ARRAYSIZE(appxBundleManifestRelativePath) - 1))) { RETURN_IF_FAILED(packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxBundleManifestRelativePath) - 1))); } else { WriteLog(1, L"Registry Package entry has invalid Path"); return E_UNEXPECTED; } } Common::StringBuffer offlinePackagePath; RETURN_IF_FAILED(GetOfflineFilePath(packagePath.GetChars(), &offlinePackagePath)); Common::StringBufferBuilder offlinePathBuilder(&offlinePackagePath); RETURN_IF_FAILED(offlinePathBuilder.InsertChars(0, L" \"", 2)); RETURN_IF_FAILED(offlinePathBuilder.AppendChar(L'\"')); RETURN_IF_FAILED(AppendPackagePathAndApplyTrustLabel(offlinePackagePath.GetChars(), applicationPath, offlineSoftwareHive, cmdLineBuilder)); this->indent--; return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(registryKey, [&](PCWSTR subKeyName, Common::RegistryKey*) -> HRESULT { WriteLog(0, L"%ws", subKeyName); this->indent++; Common::RegistryKey subKey; RETURN_IF_FAILED(registryKey->OpenSubKey(subKeyName, KEY_READ, &subKey)); LogAllSubKeys(&subKey); this->indent--; return S_OK; })
Common::Deployment::EnumKeyAndDoActionForAllSubkeys(regKey, [&](PCWSTR subKeyName, Common::RegistryKey*) -> HRESULT { this->indent++; WriteLog(0, L"%ws: %ws", logPrefix, subKeyName); this->indent--; RETURN_IF_FAILED(stringVector->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())); return S_OK; })
Common::Deployment::GetPackageIDFromPackageMoniker( existingFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( packageFullName, nullptr, &currentPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( packageFullName, nullptr, &highestVersionPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( provisionedInstalledPackageFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( uplevelProvisionedPackage, nullptr, &provisionedPackageID)
Common::Deployment::GetVersionlessNameFromPackageFullName( fullName, &versionlessName)
Common::Deployment::GetVersionlessNameFromPackageFullName( packageFullName, &versionlessName)
Common::Deployment::ManifestCache::UpdateOptions(Common::Deployment::ManifestCache::Options_ReloadAllInbox)
Common::DirectoryExists(autogenDirectoryPath.GetChars(), &folderExists)
Common::DirectoryExists(fullPathDirectory.GetChars(), exists)
Common::DirectoryExists(metadataFolder.GetChars(), &metadataExistsInPackageRoot)
Common::DirectoryExists(metadataFolderInSharedLimitedTime.GetChars(), &packageExistsInSharedLimitedTime)
Common::DirectoryExists(systemMetadataDirectoryForPackage, &systemMetadataForPackageExists)
Common::FileExists(applyTrustLabelAppFullPath.GetChars(), &fileExists)
Common::FileExists(fileName.GetChars(), &fileExists)
Common::FileExists(recoveryFileFullPath.GetChars(), &recoveryFileExists)
Common::FileExists(sourceBackupManifestFilePathBuilder.GetChars(), &sourceFileExists)
Common::FileExists(targetBackupManifestFilePath.GetChars(), &targetFileExists)
Common::StateSeparation::GetPackageRepositoryPackagesPath(nullptr, &packageRepositoryPackagesKeyPath)
Common::String::CaseInsensitiveStartsWith(subKey, L"S-", &isUserSid)
CompanyName
CompareStringOrdinal
Completed AppxPreRegisterAllInboxPackages
Completed EnsureAppRootPermissions - processed %i of %i directories.
Completed EnsureFamiliesRegistryKeyPermissions
Completed EnsureRegistryKeyPermissions
Completed FixStateRepositoryIntegrity -- was already run so no action needed.
Completed FixStateRepositoryIntegrity successfully.
Completed RepairPackageRepositoryKeyInHKLM
Completed RepairPackageRootFolderPathInRepositoryRegistryKey
Completed RepairStateRepository successfully.
context->GetOfflineStatus(&offlineExecution)
ConvertStringSidToSid(packageContentsCapabilitySid, &packageContentsSid)
ConvertStringSidToSidW
CopyFile(sourceBackupManifestFilePath.GetChars(), targetBackupManifestFilePath.GetChars(), FALSE)
CopyFileW
CoTaskMemAlloc
CoTaskMemFree
Could not open %ws: 0x%x -- not performing EOL and provisioned-package cleanup
CreateAppxProvisionFactory(&appxProvisionFactory)
created
CreateEventW
CreateFileW
CreateMutexExW
CreatePrivateObjectSecurityEx
CreateProcessW
CreateSemaphoreExW
CreateThread
CreateThreadpoolTimer
CreateWellKnownSid
Current bundle %ws is lower version than the existing %ws
Current package %ws is lower version than the existing %ws
currentContextId
currentContextMessage
currentContextName
currentPackage.SetValueFromString(packageFullName)
D!t$$H
D$ E3
d$ E3
D$ E3
D$ fD
D$(E3
D$@!D$HL
D$@E3
D$@fD
D$`!D$hH
D$`!D$hL
D$`E3
D$0E3
D$8!D$@H
D$8!D$@I
D$8!D$@L
D$H t*L
D$h!D$pH
D$H!D$PH
D$HE3
D$hE3
D$HE3
D$P!D$XH
D$P!D$XL
D$pE3
D$PH;
D$PH9t$Hu
D$T9p
D$X!D$`H
D$x!E
D$X9F4
D$xE3
D$XL9|$Pu
D;}(r
D;A,sOA
D;G,s)H
D8|$@
D8|$@t5L
D8|$A
D8|$Xt
D8}wu
D8l$0t
D8l$Pt
D9 u:L
D9|$Du
D90v(H
D9l$\v
D9l$8t
DeleteCriticalSection
Deleted\
DeleteFileW
Deleting Uplevel all-user key %ws because downlevel had a higher version
Deprovision key not found, nothing to copy
Deprovisioned
deprovisionedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, deprovisionedSD)
deprovisionKey.CopyTree(nullptr, this->pluginDeprovisionedKey)
deprovisionKey.KeyExists(familyName, packageDeprovisioned)
DestroyPrivateObjectSecurity
Determining if no re-registration of packages is needed failed with 0x%x. We will just default to re-registering all apps.
DeviceIoControl
DirectoryPaths::CreateFullFileName(destDirectory, findFileData.cFileName, &destPath)
DirectoryPaths::CreateFullFileName(sourceDirectory, findFileData.cFileName, &srcPath)
DisableThreadLibraryCalls
DiscoverFailed
DllCanUnloadNow
DllGetClassObject
Downlevel OS already had package %ws registered for user %ws, writing to UserSid Key
Downlevel OS already had package %ws registered, not writing to Staged Key
DownlevelInstalled
downlevelInstalledKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
DownlevelOSVersion
E !E(H
E'!E/L
E(=csm
E;f(r
E?!EGH
E0!E8H
E8=csm
Eh=csm
EH=csm
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
Ehttp://crl.microsoft.com/pki/crl/products/MicTimStaPCA_2010-07-01.crl0Z
Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0
EndOfLife
endOfLifeKey.GetKeySecurity(DACL_SECURITY_INFORMATION, endOfLifeSD)
endOfLifeKey.Open(HKEY_LOCAL_MACHINE, endOfLifePath.GetChars(), KEY_READ)
EnsureACLOnObject(SE_FILE_OBJECT, fullFilePath.GetChars(), packageContentsSid.get())
EnsureACLOnObject(SE_FILE_OBJECT, targetPath.GetChars(), packageContentsSid.get())
EnsureACLOnObject(SE_REGISTRY_KEY, perUserACLPathBuffer.GetChars(), packageContentsSid.get())
EnsureAppRootPermissions(offlineMode)
EnsureAppxDeploymentClientDllLoaded(&deploymentClientModule)
EnterCriticalSection
EnumAndAddSubKeysToStringVector(&inboxPackagesKey, packagesToReRegister.Get(), L"PackagesToReRegister")
EnumAndAddSubKeysToStringVector(&userPackagesToRegisterKey, packagesToReRegister.Get(), L"PackagesToReRegister")
EnumerateAndCachePackagesInAllUserStore()
EnumerateFolderAndDoActionForSubFolders(packagePath, [&](PCWSTR packageFullName, PCWSTR packageFullPath) -> HRESULT { WriteLog(0, L"Excluding InfusedApps folder %ws", packageFullPath); RETURN_IF_FAILED(this->excludeInfusedAppsFolderSet.InsertIgnoreDuplicates(packageFullPath)); return S_OK; })
EnumerateFolderAndExcludeInfusedApps(applicationsFolder.GetChars())
EnumerateFolderAndExcludeInfusedApps(frameworksFolder.GetChars())
EnumerateFolderAndExcludeInfusedApps(packagesFolder.GetChars())
EnumKey for [%s] failed: 0x%x
eolPackages->GetCurrent(&package)
error != ERROR_NO_MORE_FILES
Error getting effective rights from ACL for %ws - 0x%x
Error getting SD for %ws - 0x%x
Error retrieving IRepositoryManager 0x%x
Error retrieving IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
Erroring adding to ACL to %ws - 0x%x
Erroring setting new SD for %ws - 0x%x
EtwEventRegister
EtwEventUnregister
EtwEventWrite
EventRegister
EventSetInformation
EventUnregister
EventWriteTransfer
everyoneSid.Initialize( Common::Deployment::EveryoneSid.chars, Common::Deployment::EveryoneSid.length)
EX;0r
EX=csm
Ex=csm
Exception
Exclude infused apps failed with 0x%x. Ignoring this error.
Exclude leftover invalid registries failed with 0x%x. Ignoring this error.
Exclude leftover manifest files failed with 0x%x. Ignoring this error.
ExcludePackagesWithinKey(&stagedKey, &allUserStoreStagedPath)
ExcludePackagesWithinKey(&userSidKey, &fullPathToUserSidKey)
Excluding InfusedApps folder %ws
EXD;0r
Existing bundle %ws and current bundle %ws have same main package
Existing bundle %ws has a lower version app than %ws
Existing package %ws is lower version than %ws so its package root will be excluded
exists
Expanded Path value: %s, value length: %u
Expanded SIS path: %s
ExpandEnvironmentStrings(appRepositoryPath, appRepositoryExpandedPath, ARRAYSIZE(appRepositoryExpandedPath)) == 0
ExpandEnvironmentStrings(appRepositoryPath, expandedPath, ARRAYSIZE(expandedPath)) == 0
ExpandEnvironmentStringsW
ext-ms-onecore-appmodel-staterepository-internal-l1.dll
f)x{F
f.get() == INVALID_HANDLE_VALUE
F0D8#ukD8c
f9,Au
f9,Ku
f94Au
f94Gu
f94Ou
fA9|E
fA9<Bu
fA9<Xu
Failed Processing inbox or devmode package for user with 0x%x. Ignoring failure to continue with processing
Failed Processing optional package with 0x%x. Ignoring failure to continue with processing
Failed Processing package for user with 0x%x. Ignoring failure to continue with processing
Failed Processing package with 0x%x. Ignoring failure to continue with processing
Failed to ApplyTrustLabel - CreateProcess Failed - 0x%x - %s
Failed to ApplyTrustLabel - GetExitCodeProcess Failed - 0x%x - %s
Failed to ApplyTrustLabel - InitializeProcThreadAttributeList Failed - 0x%x - %s
Failed to ApplyTrustLabel - UpdateProcThreadAttribute Failed - 0x%x - %s
Failed to ApplyTrustLabel offline to Plugin Staged Packages - 0X%x
Failed to ApplyTrustLabel offline to Plugin Staged User Acquired Packages - 0X%x
Failed to ApplyTrustLabel offline to PreInstalled Packages - 0X%x
Failed to check whether reg value %ws exists with 0x%x. Try to rewrite the value.
Failed to create or open reg key %ws with 0x%x
Failed to create per-machine keys 0x%x
Failed to create reg key %ws with 0x%x
Failed to create top level registry keys 0x%x
Failed to enumerate all users with 0x%x
Failed to enumerate downlevel installed packages for the user %ws with 0x%x, will re-install all apps
Failed to enumerate packages for the user %ws with 0x%x
Failed to exclude file %ws in XML Writer: 0x%x
Failed to exclude registry %ws in XML Writer: 0x%x
Failed to get junction target for : %ws - 0x%x
Failed to get package family name from full name %ws. Package will not be preserved
Failed to get reg value %ws from plugin key with 0x%x.
Failed to get Registry key value [%s]
Failed to get WorkingDir 0x%x
Failed to include directory %ws in XML Writer: 0x%x
Failed to include directory %ws, file %ws in XML Writer: 0x%x
Failed to include registry %ws in XML Writer: 0x%x
Failed to include registry key %ws, value %ws in XML Writer: 0x%x
Failed to merge registry %ws in XML Writer: 0x%x
Failed to merge registry key %ws, value %ws in XML Writer: 0x%x
Failed to move directory %ws to backup folder in XML Writer: 0x%x
Failed to open reg key %ws with 0x%x
Failed to PerformApplySuccessOnlinePerMachineTasks with 0x%x
Failed to process all installed packages with 0x%x
Failed to process all user store packages with 0x%x
Failed to process AppxProvisioning XML for end of life packages 0x%x. Proceeding as if AppxProvisioning XML does not exist so user acquired apps get processed
Failed to process bundle manifest packages: 0x%x. Excluding Bundle.
Failed to processing all packages during AppxUpgradeMigration ApplySuccess with 0x%x
Failed to repair reg value [%s] for package %s, hr: 0x%x
Failed to SaveWindowsAppsPackageListToFile: 0x%x
Failed to set the FlushInboxCachedManifests in the AppxAllUserStore with 0x%x
Failed to update registry ACLs for '%s': 0x%x.
Failed to write oem uninstalled packages for user %ws with 0x%x
Failed to write out migration XML with 0x%x
Failed to write packages to re-register for user %ws with 0x%x
Failed to write provisioned packages to staged list with 0x%x
Failed with 0x%08lx reading %ws value PackageStatus, assuming package has no in-place update pending
Failed with 0x%x to set %ws key value
FailFast
failureCount
failureId
failureType
FallbackError
false
familiesKey.OpenSubKey(familyName.GetChars(), KEY_ALL_ACCESS, &packageKey)
FamilyName
familyName->GetLength() == familyNameLength
familyName->SetLength(familyNameLength)
familyName->SetValue(fullName, nameLength)
familyNameBuffer.SetValueFromString(familyName.GetChars())
familyNameBuffer.SetValueFromString(packageFamilyName)
familyNameBuilder.AppendString(cursor)
familyNameString.Initialize(packageFamilyName, static_cast<ULONG>(wcslen(packageFamilyName)))
fD9 t
fD9$Cu
fD9(t
fD9,Vu
fD9,Wu
fD9,Xu
fD9}0
fD9+thH
fD9+u
fD90t
fD90t,
fD98t
fD9dE
fD9e0
fD9e0tJL
fD9mwtBL
fD9t]
fD9u 
fD9u@u
fD9u0ucH
fD9ugt-
fE9$Fu
fE9,Pu
fF9,Fu
File %s in working dir: %s
FileDescription
fileName
fileName.SetLength(fileName.GetLength() - wcslen(L".xml"))
fileName.SetValueFromString(findFileData.cFileName)
fileNameBuilder.AppendChar('\\')
fileNameBuilder.AppendString(expandedPath)
filenameBuilder.AppendString(OSRollbackPackagesFilename)
fileNameBuilder.AppendString(stateRepositoryMachineDatabase)
fileNameBuilder.AppendString(stateRepositoryWalFile)
filenameBuilder.AppendString(workingDir)
FileVersion
FindClose
FindFirstFileW
FindNextFileW
Finished AppxUpgradeMigration ApplySuccess for %s with 0x%x
Finished AppxUpgradeMigration ApplySuccess offline with 0x%x
Fixing
FixStateRepositoryIfPossible called
FixStateRepositoryIfPossible done (0x%x) Disposition=%d
FixStateRepositoryIfPossible(disposition)
FixStateRepositoryIntegrity(repositoryManager)
FixStateRepositoryIntegrityCompleted
FixStateRepositoryOrResetMaintenance already executed
FixStateRepositoryOrResetMaintenance called
FixStateRepositoryOrResetMaintenance done
FixStateRepositoryOrResetMaintenance()
FixStateRepositoryViaExport(disposition)
FixStateRepositoryViaRepositoryManager called
FixStateRepositoryViaRepositoryManager done. Disposition %d
FixStateRepositoryViaRepositoryManager(disposition)
FlushInboxCachedManifests
folderPathBuilder.AppendString(backupFolderNameWithSlash)
folderPathBuilder.AppendString(fullName)
folderPathBuilder.AppendString(L"\\")
folderPathBuilder.AppendString(systemMetadataFolder)
folderPathBuilder.AppendString(this->singleInstanceStore.GetChars())
FormatMessageW
Found Ghosts Entries: %d. Repaired Ghost Entries: %d.
Found IRepositoryManager
Found IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
Found path value [%s] that needs repair: %s
framework
Framework
frameworksPathBuilder.AppendString(Common::Deployment::frameworksDir)
frameworksPathBuilder.AppendString(infusedAppsFolder.GetChars())
FreeLibrary
fullFilePath->SetValue( moduleFullPath, static_cast<ULONG>(lastBackslash + 1 - moduleFullPath))
fullFilePathBuilder.AppendString(backupManifestDir.GetString())
fullFilePathBuilder.AppendString(expandedSystem32Path)
fullFilePathBuilder.AppendString(findFileData.cFileName)
fullFilePathBuilder.AppendString(L"\\")
fullFilePathBuilder.AppendString(packagePath)
fullFilePathBuilder.AppendString(path)
fullFilePathBuilder.AppendString(systemSisPath.GetChars())
FullName
fullName.Initialize(packageFullName)
fullNameBuffer.SetValueFromString(fullName)
fullNameBuffer.SetValueFromString(fullNameToWrite)
fullNames->bundle.SetValueFromString(packageFullName)
fullNames->mainPackage.SetValueFromString(packageFullName)
fullPathDirectoryBuilder.AppendChar(L'\\')
fullPathDirectoryBuilder.AppendString(packageFullName)
fullPathDirectoryBuilder.AppendString(this->singleInstanceStore.GetString())
function
FX9G4t/
Gather.FixStateRepositoryOrResetMaintenance.Failed
GatherFailed
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetEffectiveRightsFromAclW
GetExitCodeProcess
GetFamilyNameFromFullName(fullName, &familyName)
GetFamilyNameFromFullName(packageFullName, &familyName)
GetFamilyNameFromFullName(packageFullName, &packageFamilyName)
GetFamilyNameFromFullName(subKey, &packageFamilyName)
GetFileAttributesW
GetFileVersionInfoEx(FILE_VER_GET_LOCALISED | FILE_VER_GET_NEUTRAL, appxUpgradeMigrationPluginFileName, 0, versionSize, versionData)
GetFileVersionInfoExW
GetFileVersionInfoSizeExW
GetLastError
GetMetadataFolderForPackage(fullName, false , &metadataFolder)
GetMetadataFolderForPackage(fullName, true , &metadataFolderInSharedLimitedTime)
GetModuleFileName failed 0x%x -- unable to create full file path for %s
GetModuleFileNameW
GetModuleHandleW
GetNamedSecurityInfoW
GetOfflineFilePath(packagePath.GetChars(), &offlinePackagePath)
GetOfflineFilePath(systemSisPath.GetChars(), &offlineSystemSisPath)
GetOfflineRegistryPath( RegistryHive::HKU, perUserRegistryPathBuffer.GetChars(), &perUserRegistryPathOfflineBuffer)
GetOfflineRegistryPath( RegistryHive::HKU, userPath.GetChars(), &userOfflinePath)
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePath.GetChars(), &offlineAllUserStorePath)
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), &offlineAllUserStorePathBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, Common::Deployment::AppXRegKeyPath.chars, &offlineAppxRegKeyPath)
GetOfflineRegistryPath(RegistryHive::HKLM, packageRepositoryPackagesKeyPath, &offlinePackageRepositoryPackagesKeyPathBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, pluginAllUserStoreRegistryKeyString, &offlinePluginApplicationsPathBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, pluginAllUserStoreRegistryKeyString, &regPath)
GetOfflineRegistryPath(RegistryHive::HKLM, softwareHive, &offlineSoftwareHive)
GetPackageInstallState(packageManager, fullName, nullptr , &packageInstallState)
GetPackageInstallState(packageManager, packageFullName, userSid, &packageInstallState)
GetPackageInstallState(packageManager, packageFullNameAsString, nullptr, &packageInstallState)
GetPackageInstallState(packageManager.Get(), fullName, nullptr, &packageInstallState)
GetPackageRepositoryRoot(&backupManifestDir)
GetPersistedRegistryLocationW
GetPluginHasExecutedOffline(executedOffline)
GetPluginHasExecutedOffline: %d for context %ws
GetPluginHasExecutedOfflineValueName(valueName)
GetPluginRelativeFullPath failed 0x%x -- not performing EOL and provisioned-package cleanup
GetPluginRelativeFullPath(L"", &manifestPathBuffer)
GetProcAddress
GetProcessHeap
GetServiceStatus(serviceName, &status)
GetStagedPackagePathByFullName
GetSystem32FullPath(applyTrustLabelApplication, &applyTrustLabelAppFullPath)
GetSystemSisFullPath(&autogenDirectoryPath)
GetSystemSisFullPath(&packageRoot)
GetSystemSisFullPath(&systemSisPath)
GetSystemSisFullPath(&this->singleInstanceStore)
GetSystemSisManifestPathFromPackageFullName( bundleFullName, &manifestPath)
GetSystemSisManifestPathFromPackageFullName( packageFullName, &manifestPath)
GetSystemSisManifestPathFromPackageFullName( packageToWrite, &packageManifestPath)
GetSystemTimeAsFileTime
GetSystemWindowsDirectory(systemWindowsDirectory, ARRAYSIZE(systemWindowsDirectory)) == 0
GetSystemWindowsDirectoryW
GetTickCount
GetTickCount64
GetVersionInfo(&osVersion)
H UATAUAVAWH
h UAVAWH
H!\$0H!\$(H!\$ 3
H!\$83
H!\$8H!\$0H!\$(H!\$ 3
H!\$8H!\$0H!\$(H!\$ L
H!|$x
H!t$x
H!w(H
H!w03
H!w8H!w@3
H9D$x
H9D$xvl@8
H9EHvYL
hA_A^A]A\_^][
HcD$ H
HeapAlloc
HeapFree
highestVersionMap->Insert(packageFamilyName->GetChars(), fullNames.Value())
highestVersionMap->Insert(packageLineageName->GetChars(), currentPackage.GetChars())
highestVersionMap->Remove(packageLineageName->GetChars())
HKCU\
HKLM\
hrActivateInstance
hrAllUserStoreKeySetKeySecurity
hrAppendFullName
hrApplyTrustLabelToPackages
hrApplyTrustLabelToPluginStagedPackages
hrApplyTrustLabelToPluginStagedUserAcquiredPackages
hrApplyTrustLabelToPreInstalledPackages
hrAppxPreRegisterPackage
hrCleanupOrphanPackages
hrCleanupSystemAppsMigratedToFOD
hrCopyBackupManifestForEndOfLifePackagesIfNecessary
hrCopyMetadataIfRequired = CopyMetadataIfRequired()
hrCreateKey
hrCreatePerMachineKeys
hrCreatePluginAppxKey
hrCreateProvisionStreamingReaderFromFile
hrCreateTopLevelKeys
hrDeleteOSRollbackPackagesRegistry
hrDeprovisionedKeySetKeySecurity
hrEndOfLifeKeySetKeySecurity
hrEnsureAutogenDeleted
hrEnsureFamiliesRegistryKeyPermissions
hrEnsureRegistryKeyPermissions
hrEnumerate
hrEnumerateUsersAndPopulateUserSids
HResult
hresult
HResult
hresult
HRESULT_FROM_WIN32(GetLastError())
hrExcludeAllInfusedApps
hrExcludeFile
hrExcludeKey
hrExcludeLeftoverInvalidRegistries
hrExcludeLeftoverManifestFiles
hrGet
hrGetPackageIDFromPackageMoniker
hrGetTarget
hrGetUInt32Value
hrGetValue
hrGetWorkingDir
hrIncludePath
hrIncludeRegistryKey
hrIncludeRegistryValue
hrInitializeUpgradeSettings
hrIsInSingleInstanceStore
hrMarkUplevelProvisionedPausedPackagesAsStaged = MarkUplevelProvisionedPausedPackagesAsStaged()
hrMergeRegistryKey
hrMergeRegistryValue
hrMovePathToBackupFolder
hrOpen
hrOpenKey
hrOpenPackagesToRemove
hrPluginAllUserStoreKeyOpenStaged
hrPluginAppxKeyOpen
hrPluginAppxKeyOpenAppxAllUserStore
hrPluginAppxKeyOpenStagedUserAcquired
hrPluginAppxKeyOpenSubKeyApplications
hrPluginOpenPackagesToCheckForStagingCompletion
hrPluginOpenPackagesToReRegister
hrPopulateAppxProvisionXmlLists
hrPreRegister
hrPreRegisterAllInboxPackages
hrPreRegisterAllPackages
hrProcessAllInstalledPackages
hrProcessAllUserStorePackages
hrProcessBundleManifestPackages
hrProcessInboxOrDevModePackageForUser
hrProcessPackage
hrProcessPackageForUser
hrProcessRecoveryData
hrReadAppXMigrationStores
hrRegValueExists
hrReIndexPackagesForFeatureLightUp = ReIndexPackagesForFeatureLightUp()
hrRemoveUplevelProvisionedUnneededPackages = RemoveUplevelProvisionedUnneededPackages()
hrRepairPackageRepository
hrRepairPackageRootFolderPath
hrRepairStateRepository
hrSavePackageListFromFileToRegistry
hrSaveWindowsAppsPackageListToFile
hrSetMigXmlValue
hrSetupPackagesForReRegistration
hrSetValue
hrStagedKeySetKeySecurity
hrUserPackagesToReRegisterKey
hrWrite
hrWriteAllUserStoreKeys
hrWriteOutPerMachineMigrationXml
hrWriteOutPerUserMigrationXml
hrWritePackagesToReRegisterKeys
hrWriteUninstalledKeys
http://schemas.microsoft.com/appx/2013/appxprovisionpackage
I0G1-0+
If the OS doesn't support packageManager2 interface then no resource and bundles can be installed--no bundles and resources to process. 
Ignoring error: Package %ws failed to ensure deleted Autogen: 0x%x
Ignoring error: Package %ws failed to preregister: 0x%x
Ignoring package %ws with unknown property type %x
InboxApplications
inboxPackagesKey.Open(HKEY_LOCAL_MACHINE, inboxPackagesBuffer.GetChars(), KEY_READ)
infusedPathBuilder.AppendString(Common::Deployment::infusedAppsDir)
infusedPathBuilder.AppendString(systemWindowsDirectory)
InitializeAcl
InitializeAppxUpgradeNeeded(&osVersion)
InitializeAppxUpgradeNeeded(nullptr )
InitializeCmdLine(applicationPath, offlineSoftwareHive, cmdLineBuilder)
InitializeCriticalSection
InitializeCriticalSectionEx
InitializePluginRegistryKeys(false , &pluginAppxKeyFound)
InitializePluginRegistryKeys(true , &pluginAppxKeyFound)
InitializeProcThreadAttributeList
InitializeSecurityDescriptor
InitializeSRWLock
InitOnceBeginInitialize
InitOnceComplete
Inserting %ws since it was brought by a bundle %ws 
InsertToHighestVersionMap( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false, nullptr , &comparison)
InsertToHighestVersionMap( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false, packageManager, &comparison)
InsertToHighestVersionMap( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false, packageManager, containedPackageComparison)
InsertToHighestVersionMap( packageFullName, &versionlessName, &this->frameworkMap)
InsertToHighestVersionMap(fullName, &familyNameBuffer, &this->combinedProvisionedMap, true, nullptr , &comparison)
InsertToHighestVersionMap(fullName, &versionlessName, &this->frameworkMap)
InsertToHighestVersionMap(fullName, &versionlessName, &this->resourceMap)
InsertToHighestVersionMap(packageFullName, &versionlessName, &this->resourceMap, packageManager)
installedLocation.As(&installedLocationStorageItem)
installedLocationStorageItem->get_Path(path.ReleaseAndGetAddressOf())
internal\onecorebase\inc\appmodel\package\processorarchitecture.hpp
internal\sdk\inc\wil\Resource.h
internal\sdk\inc\wil\staging.h
InternalName
Is a framework package
Is a LOB app
Is a main or bundle package
Is a resource package
Is a top level package
Is being DROPPED because it is a de-provisioned package
IsDebuggerPresent
IsDevModeApp
IsFixStateRepositoryAlreadyExecuted(alreadyExecuted)
iSHp6
IsInboxPackage(packageFullName.GetRawBuffer(nullptr), &isInboxPackage)
IsLOBApp
IsPackageDeprovisionedInAllUserStore(familyName.GetChars(), false , &packageDeprovisioned)
IsPackageDeprovisionedInAllUserStore(packageFamilyName, false , &packageDeprovisioned)
IsPackageInEndOfLifeKey(endOfLifeMissingManifestFixablePackageFullNames[i], &isInEndOfLifeKey)
IsPluginDeprovisionedPackage(&allUserStoreKey, packageFamilyName, &isDeprovisioned)
IUIPolicyChecked
K SUVWAVAWH
K SVWH
k,swT
KERNEL32.dll
kernelbase.dll
key.ValueExists(valueName.GetChars(), &hasExecutedOffline)
key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)
key->OpenSubKey(userSid, KEY_READ, &userSidKey)
keysToDelete.Add(uplevelPackageToDelete)
KfD9u0uvH
L!u0H
l$ E3
L$ E3
L$ SUVWH
L$ SVWH
L$ UVWATAUAVAWH
L$ VWAVH
L$(E3
L$@I+
l$\fD
L$`9L$Pu
L$`D;
L$`H3
L$0E3
L$0H3
L$8E3
L$8H3
L$hH3
L$PD9
L$PH+
L$XL+
L9{@u
L9{0t#H
L9|$`u
L9|$8u
L9d$pt
LastReturnValue
LcA<E3
Lct$$H
LeaveCriticalSection
Legal_Policy_Statement
LegalCopyright
lineNumber
LoadLibraryExW
LoadLibraryW
Local\SM0:%d:%d:%hs
LocalFree
LOG_IF_FAILED(%S) failed with 0x%x
Logging Downlevel OS's AppxAllUserStore key:
LogHr
lpt1.
lpt2.
lpt3.
lpt4.
lpt5.
lpt6.
lpt7.
lpt8.
lpt9.
m:AppxProvisionList
m:AppxProvisionList/m:EndOfLife/m:Package/@FamilyName
m:AppxProvisionList/m:Provisioned/m:Package/@FullName
m:EndOfLife
m:EndOfLife/m:Package
m:Package
m:Provisioned
m:Provisioned/m:Package
M0K0I
MACHINE
mainPackageKey.SetStringValue( AppxAllUserStore::regValuePath, packageManifestPath.GetStringRef())
mainPackageKey.SetUInt32Value(AppxAllUserStore::regValueIsLOBApp, 1)
MaintenanceLastPerformed
malloc
ManifestCacheOptions
manifestPackageID->GetPackageFullName(&packageFullName)
manifestPathBuilder.AppendChar(L'\\')
manifestPathBuilder.AppendString(&Common::Deployment::BundleManifestFileName)
manifestPathBuilder.AppendString(&Common::Deployment::ExtendedPathPrefix)
manifestPathBuilder.AppendString(&Common::Deployment::ManifestFileName)
manifestPathBuilder.AppendString(packageFullName)
manifestPathBuilder.AppendString(systemSisPath.GetChars())
memcmp
memcpy
memcpy_s
memmove
memmove_s
memset
message
metadataPathBuilder.AppendString(fullName)
metadataPathBuilder.AppendString(sisPath)
metadataPathBuilder.AppendString(systemMetadataFolder)
Microsoft
Microsoft Corporation
Microsoft Corporation1
Microsoft Corporation1&0$
Microsoft Corporation1.0,
Microsoft Corporation1-0+
Microsoft Corporation1200
Microsoft Time-Stamp PCA 2010
Microsoft Time-Stamp PCA 20100
Microsoft Time-Stamp service
Microsoft Time-Stamp service0
Microsoft Windows0
Microsoft.CommsPhone_8wekyb3d8bbwe
Microsoft.Windows.AppxMigrationPlugin
Microsoft.Windows.SecondaryTileExperience_10.0.0.0_neutral__cw5n1h2txyewy
Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\
MigXml
MigXmlWriter::Create(false , &xmlWriter)
MigXmlWriter::Create(true , &xmlWriter)
module
Msg:[%ws] 
msvcrt.dll
N0L0J
ND8|$@
neutral
NewParser
No %s found - cannot apply trust labels
No Applications Plugin key found--downlevel had no OEM apps or newer all-user apps to copy over
No need to write Applications Key because uplevel provisioned package %ws is the latest version
No PackagesToCheckForStagingCompletion Plugin key found
No PackagesToRemove Plugin key found
No PackagesToReRegister Plugin key found
No Plugin Applications key found. Downlevel had no OEM apps or newer all-user apps to copy over
No Plugin key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
No Plugin key found--downlevel had no apps or Discover/Gather failed.
No Plugin Staged key found. As far as we know, user had no packages to ApplyTrustLabel
No Plugin Staged key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
No Plugin StagedUserAcquired key found. As far as we know, User had no packages
No Plugin StagedUserAcquired key found. As far as we know, user had no packages to ApplyTrustLabel
No work to do for DEFAULT user. Skipping.
NoReRegisterOnUpgrade
Not Removing up-level provisioned deprovisioned Package because a user has it still installed: %ws
NtClose
NtCreateSection
ntdll.dll
NtMapViewOfSection
NtQueryWnfStateData
NtUnmapViewOfSection
NtUpdateWnfStateData
O0M0K
offlineFilePath->SetValueFromString(reinterpret_cast<PCWSTR>(bstrOfflineFilePath.Value()))
offlinePathBuilder.AppendChar(L'\"')
offlinePathBuilder.InsertChars(0, L" \"", 2)
offlineRegistryPath->SetValueFromString((reinterpret_cast<PCWSTR>(bstrOfflineRegistryPath.Value())) + hivePrefixLength)
oK0D$"<
OLEAUT32.dll
onecore\admin\appmodel\appxupgrademigrationplugin\src\appxupgrademigrationpluginclass.cpp
onecore\admin\appmodel\appxupgrademigrationplugin\src\migxmlwriter.cpp
onecore\admin\appmodel\appxupgrademigrationplugin\src\recoveryreader.cpp
onecore\admin\appmodel\common\alluserstorepaths.cpp
onecore\admin\appmodel\common\configuration.cpp
onecore\admin\appmodel\common\directorypaths.cpp
onecore\admin\appmodel\common\downlevelhelper.cpp
onecore\admin\appmodel\common\manifestcache.hpp
onecore\admin\appmodel\common\mountedfolder.cpp
onecore\admin\appmodel\common\packagefullnameutilities.cpp
onecore\admin\appmodel\common\PackageID.inl
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackage.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackageenumerator.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionreader.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionwriter.cpp
onecore\base\appmodel\appxprovisionpackage\src\commonhelpers.cpp
onecore\base\appmodel\common\autocotaskmemstring.cpp
onecore\base\appmodel\common\bytebuffer.cpp
onecore\base\appmodel\common\registrykey.cpp
onecore\base\appmodel\common\stateseparation.cpp
onecore\base\appmodel\common\stringbuilder.cpp
onecore\base\appmodel\common\stringset.cpp
onecore\base\appmodel\common\widestring.cpp
opcFactory->CreateStreamOnFile( manifestPath.GetChars(), OPC_STREAM_IO_READ, NULL, FILE_ATTRIBUTE_NORMAL, &manifestStream)
OpenFileInWorkingDirectory(PluginExecutedFixStateRepositoryFilename, false , &file)
OpenFileInWorkingDirectory(PluginExecutedFixStateRepositoryFilename, true , &fileHandle)
Opening reg key HKEY_LOCAL_MACHINE\%s to enumerate
Opening reg key HKEY_USERS\%s to enumerate
OpenPerUserClassesSubKey(userSid, appxMiniRepositoryFamiliesSubkey, offlineMode, &familiesKey)
OpenPerUserClassesSubKey(userSid, appxMiniRepositoryPackagesSubkey, offlineMode, &packagesKey)
OpenSCManagerW
OpenSemaphoreW
OpenServiceW
OriginalFilename
originatingContextId
originatingContextMessage
originatingContextName
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running ApplySuccess.
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Discover.
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Gather.
OSDATA\Software\
OSRollbackPackages
OutputDebugStringW
p AWH
p WATAUAVAWH
p WAVAWH
PA^_]
pA^_]
pA^A\_^]
PA^A\_^]
pA_A^_^]
pA_A^A\_]
pA_A^A]A\_[]
pA_A^A]A\_^]
PA_A^A]A\_^]
Package
Package %ws destage completed with hr = 0x%x.
Package %ws does not exist in SIS. Don't carry it forward
Package %ws has an in-place update pending, can't move it away.
Package %ws is being end of lifed so its package root will be excluded
Package %ws is End Of Life and missing a backup manifest, but we could not fix this.
Package %ws is End Of Life and was missing a backup manifest, but we were able to replace the backup manifest.
Package %ws is not installed by any users. No need to preserve it
Package %ws is not needed, not writing to Staged Key
Package %ws will be preserved as uplevel OS image does not have any version of it and it has been installed by at least 1 user
Package family %ws does not exist in SIS. Don't carry it forward
Package family %ws is end-of-lifed
Package is being end of lifed so its package root will be excluded
Package is in paused state. This package will be treated the same as if it were staged
Package is LOB and will be carried forward.
Package is not uplevel provisioned or LOB and will be carried forward. Since it's downlevel provisioned, but not uplevel provisioned implies this is an OEM package
Package is uplevel provisioned.
Package root of bundle %ws will be excluded as it is lower version
Package root of current bundle %ws will be excluded as it is lower version
Package root of current package %ws will be excluded as it is lower version
package->GetPackageFamilyName(&familyName)
package->GetPackageFullName(&fullName)
package->GetPackageId(&manifestPackageID)
package->GetPackageType(&packageType)
package->GetProperties(&packageProperty)
PackageDirectoryExists(fullName, &exists)
PackageDirectoryExists(packageFullName, &exists)
PackageDirectoryExists(packageFullNameElement->GetValue(), &exists)
packageFamilyKey.CopyTree(nullptr, allUserApplicationsKey)
packagefamilyNameAsInternalString.Initialize( packageFamilyName, static_cast<ULONG>(wcslen(packageFamilyName)))
PackageFamilyNameFromFullName
packageFullNameKey.GetStringValue(L"Path", &packagePath)
packageId->get_FullName(fullName.GetAddressOf())
packageId->get_FullName(packageFullName.GetAddressOf())
packageId->get_FullName(packageFullNameAsString.GetAddressOf())
packageInfo->get_Id(&packageId)
packageInfo->get_InstalledLocation(&installedLocation)
packageInfo->get_IsFramework(&isFrameworkValue)
packageInfoCollection->First(&packageInfoIterator)
packageInfoCollection->First(packageInfoIterator.GetAddressOf())
packageInfoCollection->First(packageInfoIterator.ReleaseAndGetAddressOf())
packageInfoCurrent->get_Id(&packageId)
packageInfoIterator->get_Current(&packageInfoCurrent)
packageInfoIterator->get_Current(bundleInfo.GetAddressOf())
packageInfoIterator->get_Current(packageInfo.GetAddressOf())
packageInfoIterator->get_HasCurrent(&hasCurrent)
packageInfoIterator->get_HasCurrent(&hasCurrentPackage)
packageInfoIterator->MoveNext(&hasCurrent)
packageInfoIterator->MoveNext(&hasCurrentPackage)
packageKey.SetKeySecurity(DACL_SECURITY_INFORMATION, newSecurityDescriptor)
packageKey.SetStringValue(pathValueName, expandedPath)
PackageList
packageManager.As(&packageManager2)
packageManager->FindPackagesByUserSecurityId( everyoneSid, packageInfoCollection.GetAddressOf())
packageManager->FindPackagesByUserSecurityId( userSidAsInternalString, packageInfoCollection.GetAddressOf())
packageManager->FindUsers(packageFullName, userInfoCollection.GetAddressOf())
packageManager->SetupOutdatedPackagesForReRegistration(userSidString.Get(), packagesToReRegister.Get())
packageManager2.As(&packageManager1)
packageManager2->FindPackagesByPackageFamilyNameWithPackageTypes( familyNameString, isBundle ? Windows::Management::Deployment::PackageTypes_Bundle : Windows::Management::Deployment::PackageTypes_Main, &packageInfoCollection)
packageManager2->FindPackagesByUserSecurityIdPackageFamilyNameWithPackageTypes( userSidAsInternalString, packagefamilyNameAsInternalString, Windows::Management::Deployment::PackageTypes_Bundle, packageInfoCollection.GetAddressOf())
packageManager2->FindPackagesWithPackageTypes( Windows::Management::Deployment::PackageTypes_Bundle, packageInfoCollection.GetAddressOf())
packageManager2->FindPackagesWithPackageTypes( Windows::Management::Deployment::PackageTypes_Optional, packageInfoCollection.ReleaseAndGetAddressOf())
packageManager2->FindPackagesWithPackageTypes( Windows::Management::Deployment::PackageTypes_Resource, packageInfoCollection.ReleaseAndGetAddressOf())
packageManifestPath->InitializeFromString(manifestPath.GetChars())
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxBundleManifestRelativePath) - 1))
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxManifestRelativePath) - 1))
PackageRepositoryRoot
packageRepositoryRoot->InitializeFromString(repositoryRoot.GetChars())
PackageRoot
packageRoot.SetLength(packageRootLength)
packageRoot.SetValueFromString(WindowsGetStringRawBuffer(path, NULL))
packageRootBuilder.AppendChar(L'\\')
packageRootBuilder.AppendString(Common::Deployment::ManifestFileName.chars)
packageRootBuilder.AppendString(package)
PackageRootFolder
Packages
packages->GetCurrent(&package)
packagesKey.Open(HKEY_LOCAL_MACHINE, packagesKeyPath, KEY_READ | KEY_WOW64_64KEY)
packagesKey.OpenSubKey(packageFullName.GetChars(), KEY_READ | KEY_WRITE, &packageKey)
packagesPathBuilder.AppendString(Common::Deployment::packagesDir)
packagesPathBuilder.AppendString(infusedAppsFolder.GetChars())
PackageStatus
PackagesToCheckForStagingCompletion
PackagesToCheckForStagingCompletion: %ws
packagesToCheckForStagingCompletion->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
PackagesToRemove
PackagesToReRegister
packagesToReRegister->get_Size(&vectorCount)
packageSubKey->SetValueFromString(packageFullName)
packageSubKeyBuilder.AppendChar(L'\\')
packageSubKeyBuilder.AppendString(packageFamilyName)
packageSubKeyBuilder.AppendString(packageFullName)
packageSubKeyBuilder.AppendString(packageToWrite)
packageSubKeyBuilder.AppendString(userSid)
PackageType
PackageVolumeKey
PackageVolumeName
pathBuilder.AppendChar('\\')
pathBuilder.AppendChar(L'\\')
pathBuilder.AppendString(&RecoveryReader::recoveryExtension)
pathBuilder.AppendString(appRepositoryExpandedPath)
pathBuilder.AppendString(autogenDirectorySubPath)
pathBuilder.AppendString(familyName)
pathBuilder.AppendString(fullName)
pathBuilder.AppendString(L"\\")
pathBuilder.AppendString(packageFullName)
pathBuilder.AppendString(path)
pathBuilder.AppendString(path->GetString())
pathBuilder.AppendString(systemMetadataDirectoryForPackage)
pathBuilder.AppendString(systemMetadataFolder)
pathBuilder.AppendString(upgradePath.GetString())
pathBuilder.AppendString(userSid)
PerformApplySuccessPerMachineTasks(false )
PerformApplySuccessPerMachineTasks(true )
PerformApplySuccessPerUserTasks(userSidString, false )
PerformApplySuccessPerUserTasks(userSidString, true )
Performing AppxUpgradeMigration Plugin offline tasks
perUserACLPathBufferBuilder.AppendString(L"USERS\\")
perUserACLPathBufferBuilder.AppendString(perUserRegistryPath)
perUserInstalledKey.CreateSubKey(package, KEY_READ | KEY_WRITE, &perUserInstalledSubKey)
perUserInstalledSubKey.SetUInt32Value(lastReturnValueRegistryValueName, S_OK)
perUserRegistryPathBufferBuilder.AppendString(appContainerStorageRegistrySubKey)
perUserRegistryPathBufferBuilder.AppendString(registryClassesPrefix)
perUserRegistryPathBufferBuilder.AppendString(userSid)
perUserReRegistrationKey.CreateSubKey(mainPackageFullName, KEY_READ | KEY_WRITE, &perUserReRegistrationSubKey)
Plugin Appx key not found which should be present on up-level -- abandoning FixStateRepositoryIntegrity.
Plugin sub key found -- we're on uplevel system during apply phase for system context. Retrieve MigXml for Discover.
Plugin sub key found -- we're on uplevel system during apply phase for user context. Skip running Discover.
pluginAllUserStoreKey->OpenSubKey(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
pluginAppxKey.Create( HKEY_LOCAL_MACHINE, pluginAllUserStoreRegistryKeyString, KEY_READ | KEY_WRITE | WRITE_DAC)
pluginAppxKey.CreateSubKey( allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &this->pluginAllUserStoreKey)
pluginAppxKey.CreateSubKey( L"Applications", KEY_READ | KEY_WRITE, &this->pluginApplicationsKey)
pluginAppxKey.CreateSubKey( L"PackagesToCheckForStagingCompletion", KEY_READ | KEY_WRITE, &this->pluginPackagesToCheckForStagingCompletionKey)
pluginAppxKey.CreateSubKey( L"PackagesToRemove", KEY_READ | KEY_WRITE, &this->pluginPackagesToRemoveKey)
pluginAppxKey.CreateSubKey( L"PackagesToReRegister", KEY_READ | KEY_WRITE, &this->pluginPackagesToReRegisterKey)
pluginAppxKey.CreateSubKey( L"StagedUserAcquired", KEY_READ | KEY_WRITE, &this->pluginStagedUserAcquiredKey)
PluginExecutedInOfflineMode
PluginHasExecutedOffline
PreRegisterAllInboxPackages failed 0x%x
PreRegistering Staged package %ws
PreRegisterPackagesInRegistryKey(&stagedKey, PreRegisterOptions::ReIndex)
PreRegisterPackagesInRegistryKey(&this->pluginStagedKey)
PreRegisterPackagesInRegistryKey(&this->pluginStagedUserAcquiredKey)
PreRegisterUplevelImagePackages()
PreserveMetadataForPackage(fullName)
ProcessAllBundleResourceAndOptionalPackages()
ProcessAllMainAndFrameworkPackages()
ProcessBundleForUser( packageFamilyName, userSid, &bundleFullName)
ProcessFramework(packageFullName)
Processing %s
Processing all installed packages
Processing all Packages for user %ws
Processing all user store packages
Processing DevMode or Inbox Package %ws for user %ws
Processing downlevel all-user framework package %ws 
Processing downlevel all-user provisioned package %ws 
Processing Package %ws
Processing package %ws for ApplyTrustLabel
Processing Package %ws for user %ws
Processing Staged package %ws for preregister
Processing Staged package %ws to copy metadata
ProcessMainOrBundlePackage(packageFullName, packageManager)
ProcessPackagesForUser(this->userSids.At(i)->GetChars())
ProcessResource(packageFullName, packageManager)
ProductName
ProductVersion
Provisioned
provisionedAttemptedPackageFamilies->InsertIgnoreDuplicates(packageFamilyName.GetChars())
provisionedInstalledPackageFullNames->Insert(familyNameBuffer.GetChars(), fullNameBuffer.GetChars())
provisionedPackages->GetCurrent(&package)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(bundleFullName)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(mainPackageFullName)
ProvisionSourceIsBundle
QueryPerformanceCounter
QueryServiceStatus
R!s4Z
r~akow
RaiseException
RCV2E
ReadAppXMigrationStores()
reader->GetListEnumerator( ProvisionPackageList_EndOfLife, &eolPackages)
reader->GetListEnumerator( ProvisionPackageList_Provisioned, &provisionedPackages)
ReadFile
Reading Appx Migration Stores failed with 0x%x. Ignoring this error so we attempt to write migration XML.
realloc
RecursiveCopyDirectoryExceptAutogen(metadataFolderInSharedLimitedTime.GetChars(), metadataFolder.GetChars())
RecursiveCopyDirectoryExceptAutogen(srcPath.GetChars(), destPath.GetChars())
Redmond1
RegCloseKey
RegCopyTreeW
RegCreateKeyExW
RegDeleteTreeW
RegDeleteValueW
RegEnumKeyExW
RegGetKeySecurity
RegGetValueW
Registry key value [%s] does not exist. The package may not be fully registered yet.
Registry Package entry has invalid Path
registry.GetStringValue(L"PackageRepositoryRoot", MAX_EXTENDED_PATH, &repositoryRoot)
registry.GetStringValue(L"PackageRoot", MAX_EXTENDED_PATH, &sisPath)
registry.Open(HKEY_LOCAL_MACHINE, Common::Deployment::AppXRegKeyPath.chars, KEY_READ)
registry.Open(HKEY_LOCAL_MACHINE, offlineAppxRegKeyPath.GetChars(), KEY_READ)
registryKey->CreateSubKey(packageSubKey.GetChars(), KEY_READ | KEY_WRITE, subKey)
registryKey->Open(HKEY_USERS, userRegistryPath, KEY_READ | KEY_WOW64_64KEY)
registryKey->OpenSubKey(fullName, KEY_READ, &packageFullNameKey)
registryKey->OpenSubKey(subKeyName, KEY_READ, &subKey)
registryPathBuilder.AppendString(hivePrefix)
registryPathBuilder.AppendString(onlineRegistryPath)
regkey.DeleteValueIfExists(L"MaintenanceLastPerformed")
regkey.Open(HKEY_LOCAL_MACHINE, stateRepositoryRegistryStatusSubkey, KEY_READ | KEY_WRITE)
regkey.SetUInt32Value(stateRepositoryRegistryNameAutoCheckIntegrity, autoCheckIntegrityOptions_FixIntegrity)
RegOpenKeyExW
RegQueryInfoKeyW
RegQueryValueExW
RegSetKeySecurity
RegSetValueExW
ReleaseMutex
ReleaseSemaphore
ReleaseSRWLockExclusive
ReleaseSRWLockShared
Removed deprovisioned package %ws from uplevel key.
RemoveDirectoryW
Removing uplevel provisioned unneeded packages
Replacing path value [%s] with: %s
repositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa->CheckIntegrity(Windows::Internal::StateRepository::Management::IntegrityOptions_Fix)
repositoryManager->CheckIntegrity(options, &integrityDisposition, &countOfErrorsCorrected)
repositoryManager->Repair(Windows::Internal::StringReference(userSid == nullptr ? L"" : userSid).Get(), userSid == nullptr ? Windows::Internal::StateRepository::Management::RepairOptions_NoUser : Windows::Internal::StateRepository::Management::RepairOptions_NoMachine, &found, &deleted)
ResetStateRepositoryMaintenance called
ResetStateRepositoryMaintenance done
ResetStateRepositoryMaintenance()
resource
result == 0
RETURN_HR_IF_FALSE(%S) failed with 0x%x
RETURN_IF_FAILED(%S) failed with 0x%x
RETURN_IF_FAILED_MSG(%S) failed with 0x%x. Message is below:
RETURN_IF_WIN32_BOOL_FALSE(%S) failed with 0x%x
RETURN_LAST_ERROR_IF(%S) failed with 0x%x
RETURN_LAST_ERROR_IF_NULL(%S) failed with 0x%x
ReturnHr
Rich]*
rMfD9?w
RoActivateInstance
RoOriginateError
RoTransformError
RtlAcquireSRWLockExclusive
RtlAcquireSRWLockShared
RtlAllocateHeap
RtlCaptureContext
RtlCompareUnicodeString
RtlDeleteElementGenericTableAvl
RtlEnumerateGenericTableWithoutSplayingAvl
RtlFreeHeap
RtlGetDeviceFamilyInfoEnum
RtlGetVersion
RtlGetVersion failed with error code: 0x%x
RtlInitializeGenericTableAvl
RtlInitUnicodeString
RtlInsertElementGenericTableAvl
RtlIsGenericTableEmptyAvl
RtlIsStateSeparationEnabled
RtlLengthSid
RtlLookupElementGenericTableAvl
RtlLookupFunctionEntry
RtlNtStatusToDosErrorNoTeb
RtlReAllocateHeap
RtlReleaseSRWLockExclusive
RtlReleaseSRWLockShared
RtlSubscribeWnfStateChangeNotification
RtlUnsubscribeWnfNotificationWaitForCompletion
RtlVirtualUnwind
S-1-0-0
S-1-1-0
S-1-15-3-1024-3635283841-2530182609-996808640-1887759898-3848208603-3313616867-983405619-2501854204
S-1-5-18
searchPathBuilder.AppendString(L"\\*")
searchPathBuilder.AppendString(offlineSystemSisPath.GetChars())
searchPathBuilder.AppendString(systemSisPath.GetChars())
searchString.SetValueFromString(sourceDirectory)
searchStringBuilder.AppendString(backupManifestDir.GetString())
searchStringBuilder.AppendString(L"\\*")
searchStringBuilder.AppendString(L"\\*.xml")
searchStringBuilder.AppendString(packagePath)
SelectionNamespaces
SetEntriesInAclW
SetEvent
SetFileAttributesW
SetFixStateRepositoryAlreadyExecuted()
SetLastError
SetNamedSecurityInfoW
SetPluginHasExecutedOffline succeeded for value-name: %ws.
SetPluginHasExecutedOffline()
SetSecurityDescriptorControl
SetSecurityDescriptorDacl
SetThreadpoolTimer
SetUnhandledExceptionFilter
SharedLimitedTime metadata directory exists but metadata directory does not exist for %ws. Not copying files
SharedLimitedTime metadata directory exists: Preparing to copy metadata
SharedLimitedTime\
SisPath
Skipping AppxPreRegisterAllInboxPackages
Skipping package root folder path value not in single instance store (for example, system apps): %s. Value length: %u
Sleep
Software
Software\
Software\Classes\ActivatableClasses
Software\Classes\AppX$
Software\Classes\Extensions
Software\Classes\Folder
Software\Classes\FolderTypes
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Mappings
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Families
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\SystemAppData
Software\Classes\PackagedCom
Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Microsoft\Windows\CurrentVersion\AppHost\IndexedDB
Software\Microsoft\Windows\CurrentVersion\AppModel\Origins
Software\Microsoft\Windows\CurrentVersion\AppModel\StateChange
SOFTWARE\Microsoft\Windows\CurrentVersion\AppModel\StateRepositoryStatus
Software\Microsoft\Windows\CurrentVersion\AppSync
Software\Microsoft\Windows\CurrentVersion\Appx
Software\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore
Software\Microsoft\Windows\CurrentVersion\AppX\ByteCodeQueue
Software\Microsoft\Windows\CurrentVersion\Appx\PackageVolumes
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Alarm
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\BackgroundCapability
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Badge
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Tile
Software\Microsoft\Windows\CurrentVersion\DeviceCapabilities
Software\Microsoft\Windows\CurrentVersion\Explorer\AutoplayHandlers\Handlers
Software\Microsoft\Windows\CurrentVersion\PushNotifications
Software\RegisteredApplications
sourceBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
sourceBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
sourceBackupManifestFilePathBuilder.AppendString(manifestPathBuffer.GetChars())
SRCheckIntegrity
srCheckIntegrity(options, &disposition)
Staged
stagedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, stagedSD)
stagedKey.Open( HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ | KEY_WRITE | WRITE_DAC)
stagedKey.Open(HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ)
StagedUserAcquired
Starting AppxPreRegisterAllInboxPackages
Starting AppxUpgradeMigration Plugin during Apply Success
Starting AppxUpgradeMigration Plugin during Discover
Starting AppxUpgradeMigration Plugin during Gather
Starting EnsureAppRootPermissions
Starting EnsureFamiliesRegistryKeyPermissions
Starting EnsureRegistryKeyPermissions
Starting FixStateRepositoryIntegrity.
Starting RepairPackageRepositoryKeyInHKLM
Starting RepairPackageRootFolderPathInRepositoryRegistryKey
Starting RepairStateRepository for %s.
StateRepository
staterepository-machine.srd
storeKey.Open(HKEY_LOCAL_MACHINE, inboxPackagesBuffer.GetChars(), KEY_READ)
stringArray->Add(packageSubKey)
stringBufferToModify->SetValueFromString(packageFullName)
StringCchCopy(packageFullNameChunk, packageFullNameChunkLength, trimmedChunk)
StringCchLengthW(expandedPath, Common::String::MaxLength, &expandedPathLength)
StringCchLengthW(expandedSisPath, Common::String::MaxLength, &sisPathLength)
StringCchPrintfW(pathname.get(), pathnameLength, L"%s\\%s", workingDir.get(), filename)
StringFileInfo
stringVector->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
subFolderActionFunction(findFileData.cFileName, fullFilePath.GetChars())
subKey->SetStringValue(AppxAllUserStore::regValuePath, *packagePath)
SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
Successful delay-load of GetStagedPackagePathByFullName
Successfully finished processing all packages during AppxUpgradeMigration ApplySuccess
Successfully finished processing all packages during AppxUpgradeMigration Discover
Successfully finished processing all users and packages during AppxUpgradeMigration Gather
SVWATAUAVAWH
SVWAVH
SYSTEM\Setup\Upgrade\Appx
systemSisFullPath->InitializeFromString(sisPath.GetChars())
t"D8=l
t$ UWATAVAWH
t$ UWAVH
t$ WATAUAVAWH
t$ WAVAWH
t$ WH
T$$D!t$ H
T$@E3
t$@L9|$8u
t$`!t$hL
T$`fA;
T$0E3
t$0E3
t$0H;
t$8E3
T$8H!t$8H
T$HD8
t$PE3
T$PL;
t$XE3
t&L9h
t*D8}wu
t*H9X
t?H9X
t^@8=
t_L9h
t+H9^
t2H9X
targetBackupManifestFilePathBuilder.AppendChar('\\')
targetBackupManifestFilePathBuilder.AppendString(appRepositoryExpandedPath)
targetBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
targetBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
TerminateProcess
tffD9e
Thales TSS ESN:AB41-4B27-F0261%0#
this->allUserFrameworkSet.InsertIgnoreDuplicates(subKey)
this->allUserPackages.InsertIgnoreDuplicates(subKey)
this->AppxPreRegisterAllInboxPackages
this->AppxPreRegisterPackage
this->context->ExpandEnvironmentVariables(bstrPath, &bstrExpandedPath)
this->context->ExpandEnvironmentVariables(bstrSisPath, &bstrExpandedSisPath)
this->context->get_WorkingDir(&workingDir)
this->context->GetOfflineFileLocation( bstrOnlineFilePath.Value(), &bstrOfflineFilePath)
this->context->GetOfflineRegistryLocation( bstrOnlineRegistryPath.Value(), &bstrOfflineRegistryPath)
this->deploymentClientDllModule
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(familyName)
this->excludeFilesSet.InsertIgnoreDuplicates(fullFilePath.GetChars())
this->excludeInfusedAppsFolderSet.InsertIgnoreDuplicates(packageFullPath)
this->excludePackageFullNameSet.InsertIgnoreDuplicates(existingFullName)
this->excludePackageFullNameSet.InsertIgnoreDuplicates(fullName)
this->excludePackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
this->excludeRegistriesSet.InsertIgnoreDuplicates(fullPath.GetChars())
this->GetContext()->get_UserSidString(&userSid)
this->GetContext()->GetOfflineStatus(&offlineExecution)
this->includeMetadataSet.InsertIgnoreDuplicates(metadataPath.GetChars())
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates( familyNameBuffer.GetChars())
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->noReRegisterOnUpgrade
this->oemProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->pluginAllUserStoreKey.CopyTree(nullptr, allUserStoreKey)
this->pluginAllUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &this->pluginDeprovisionedKey)
this->pluginAllUserStoreKey.CreateSubKey( L"DownlevelInstalled", KEY_READ | KEY_WRITE, &this->pluginDownlevelInstalledKey)
this->pluginAllUserStoreKey.CreateSubKey( L"EndOfLife", KEY_READ | KEY_WRITE, &this->pluginEndOfLifeKey)
this->pluginAllUserStoreKey.CreateSubKey( L"Staged", KEY_READ | KEY_WRITE, &this->pluginStagedKey)
this->pluginAllUserStoreKey.CreateSubKey( L"Upgrade", KEY_READ | KEY_WRITE, &this->pluginUpgradeKey)
this->pluginAllUserStoreKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserInstalledKey)
this->pluginApplicationsKey.CreateSubKey( packageSubKey.GetChars(), KEY_ALL_ACCESS, &mainPackageKey)
this->pluginApplicationsKey.GetUInt64Value(downlevelOSVersionValueName, &this->downlevelOSVersion)
this->pluginApplicationsKey.OpenSubKey(subKey, KEY_READ, &packageFamilyKey)
this->pluginApplicationsKey.SetUInt32Value(noReRegisterOnUpgradeValueName, 1)
this->pluginApplicationsKey.SetUInt64Value(downlevelOSVersionValueName, this->downlevelOSVersion)
this->pluginPackagesToCheckForStagingCompletionKey.CreateSubKey( packageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( provisionedPackageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( uplevelProvisionedPackage, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToReRegisterKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserReRegistrationKey)
this->stagedOnlyManifestPackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
this->uplevelProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(familyName.GetChars())
this->uplevelProvisionedPackageMap.Insert( familyNameBuffer.GetChars(), fullNameBuffer.GetChars())
this->userSids.Add(userSid)
threadId
t-L9h
TlP0X
tnfD9"thH
TOC8uN
TotalTimeTaken
Translation
twL9x
u HcA<H
U0S0Q
UATAUAVAWH
UATAVH
UATAWH
UAUAVH
UAUAWH
UAVAWH
Unable to clean-up orphan packages: 0x%x
Unable to clean-up SystemApps migrated to FOD: 0x%x
Unable to copy backup manifest for end of life packages if necessary: 0x%x
Unable to copy metadata: 0x%x
Unable to DeleteOSRollbackPackagesRegistry: 0x%x
Unable to determine whether package %ws is in single instance store. Skipping.
Unable to Mark up-level provisioned paused packages as staged: 0x%x
Unable to pre register packages: 0x%x
Unable to re index packages for feature light up: 0x%x
Unable to Remove up-level provisioned unneeded packages: 0x%x
Unable to repair Package Repository registry key values for packages: 0x%x
Unable to repair PackageRootFolder values for packages: 0x%x
Unable to repair StateRepository for %s: 0x%x
Unable to SavePackageListFromFileToRegistry: 0x%x
Unable to set security descriptor for all user store key with 0x%x
Unable to set security descriptor for deprovisioed key with 0x%x
Unable to set security descriptor for end of life key with 0x%x
Unable to set security descriptor for staged key with 0x%x
Unable to set up packages for re-registration: 0x%x
Unable to update families registryKey ACLs: 0x%x
Unable to write all user store keys 0x%x
Unexpected failure from ExpandEnvironmentStrings on string %s. Buffer size %u characters. Required size %u characters
Unexpected failure from ExpandEnvironmentVariables on string %s
unH9A
UnhandledExceptionFilter
unknown
UpdateProcThreadAttribute
Upgrade
upgradeKey.Open(HKEY_LOCAL_MACHINE, upgradePath.GetChars(), KEY_READ | KEY_WRITE)
upgradeKey.Open(HKEY_LOCAL_MACHINE, upgradePath.GetChars(), KEY_READ)
upgradeKey.OpenSubKey(userSid, KEY_READ, &userSidKey)
upgradeKey.SetUInt64Value(timeElapsedValueName, timeElapsed)
upgradeKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
Uplevel OS image has a version of package %ws. No need to preserve it
Uplevel Provisioned package: %ws found in appxprovisioning.xml
uplevelPackageToDelete->SetValueFromString(fullNameKey)
userInfo.Get()->get_InstallState(&installStateValue)
userInfo->get_UserSecurityId(userInfoSid.Address())
userInfoCollection->First(userInfoIterator.GetAddressOf())
userInfoIterator->get_Current(userInfo.GetAddressOf())
userInfoIterator->get_HasCurrent(&hasCurrent)
userInfoIterator->MoveNext(&hasCurrent)
userInfoSid.GetLpcwstr(&userAsLpcwstr)
userPathBuilder.AppendString(registryClassesPrefix)
userPathBuilder.AppendString(subKey)
userPathBuilder.AppendString(userSid)
USERS\
userSid->SetValueFromString(subKey)
userSidAsInternalString.Initialize(userSid, static_cast<ULONG>(wcslen(userSid)))
userSidKey.KeyExists(packageFullName, isPackageEndOfLife)
usersKey.Open(HKEY_LOCAL_MACHINE, usersPath.GetChars(), KEY_READ)
usersPathBuilder.AppendString(userSid)
USVWATAVAWH
USVWAVH
USWATAUAVAWH
UVATAVAWH
UVWATAUAVAWH
UVWATAVH
UVWAUAVH
UVWAVAWH
UWATAUAVH
UWATAUAWH
UWATAVAWH
UWAUAVAWH
UWAVH
UWAWH
valueNameBuilder.AppendString(pluginHasExecutedOfflineValueName)
valueNameBuilder.AppendString(userSid ? userSid.get() : L"")
VarFileInfo
VerQueryValueW
version="1.0" encoding="utf-8"
VS_VERSION_INFO
VWATAVAWH
VWAUAVAWH
VWAVH
WaitForSingleObject
WaitForSingleObjectEx
WaitForThreadpoolTimerCallbacks
Washington1
WATAUAVAWH
WATAVH
WAVAWH
wcscmp
wcsrchr
wcsstr
wilResult
WilStaging_02
Windows.Foundation.Collections.IIterator`1<String>
Windows.Foundation.Collections.IVector`1<String>
Windows.Foundation.Collections.IVectorView`1<String>
Windows.Internal.StateRepository.Management.RepositoryManager
Windows.Management.Deployment.Internal.PackageManagerInternal
Windows.Management.Deployment.PackageManager
Windows.MiracastView_6.3.0.0_neutral_neutral_cw5n1h2txyewy
Windows::Foundation::ActivateInstance( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Management_Deployment_Internal_PackageManagerInternal).Get(), &packageManager)
Windows::Foundation::ActivateInstance( Windows::Internal::StringReference(RuntimeClass_Windows_Internal_StateRepository_Management_RepositoryManager).Get(), &repositoryManager)
Windows::Foundation::ActivateInstance(acid.Get(), &inspectable)
Windows::Foundation::ActivateInstance(strActivatableClassId.Get(), &packageManager)
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToCheckForStagingCompletion)
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToReRegister)
WindowsCreateString
WindowsCreateStringReference
WindowsDeleteString
WindowsDuplicateString
WindowsGetStringRawBuffer
WindowsStringHasEmbeddedNull
WriteAllProvisionedUninstalledPackageKeysToList( userSid, provisionedInstalledPackageFullNames, &provisionedUninstalledPackageFullNames)
WriteDependencyMapToStagedPackageKeys(&this->frameworkMap, [&](_In_ PCWSTR frameworkFullName) -> bool { if (IsPackageRegistrationPreservedAcrossUpgrade() && this->allUserFrameworkSet.HasElement(frameworkFullName)) { return false; } return true; })
WriteDependencyMapToStagedPackageKeys(&this->resourceMap, [&](_In_ PCWSTR resourceFullName) -> bool { if (!IsPackageRegistrationPreservedAcrossUpgrade()) { return true; } WCHAR packageFamilyName[PACKAGE_FAMILY_NAME_MAX_LENGTH + 1] = { 0 }; UINT32 packageFamilyNameLength = ARRAYSIZE(packageFamilyName); LONG result = ERROR_SUCCESS; if (PackageFamilyNameFromFullName(resourceFullName, &packageFamilyNameLength, packageFamilyName) != ERROR_SUCCESS) { return false; } Common::RegistryKey familyNameKey; const HRESULT hrOpenSubKey = this->pluginStagedKey.OpenSubKey(packageFamilyName, KEY_READ, &familyNameKey); if (SUCCEEDED(hrOpenSubKey)) { return true; } return false; })
WriteDeprovisionListToPluginAllUserStore()
WriteFile
WriteOutRegistryIncludeRules( MigXmlRules::perMachineRegistryRules, ARRAYSIZE(MigXmlRules::perMachineRegistryRules), true, xmlWriter)
WriteOutRegistryIncludeRules( MigXmlRules::perUserRegistryRules, ARRAYSIZE(MigXmlRules::perUserRegistryRules), false, xmlWriter)
WriteOutRegistryMergeRules( MigXmlRules::perMachineRegistryMergeRules, ARRAYSIZE(MigXmlRules::perMachineRegistryMergeRules), true, MergePriority::DestinationPriority, xmlWriter)
WriteOutRegistryMergeRules( MigXmlRules::perUserRegistryMergeRules, ARRAYSIZE(MigXmlRules::perUserRegistryMergeRules), false, MergePriority::SourcePriority, xmlWriter)
WritePackageAlreadyInstalledForUserKey(userSid, fullNameToWrite)
WritePackageAlreadyInstalledForUserKey(userSid, package)
WritePackageRegistryKey( packageElement->GetKey(), bundleFullName, userSid, &this->pluginStagedKey, L"Staged")
WritePackageRegistryKey( packageElement->GetKey(), mainPackageFullName, userSid, &this->pluginStagedKey, L"Staged")
WritePackageRegistryKey( packageFamilyName, fullNameToWrite, userSid, &this->pluginUpgradeKey, L"Upgrade", &createdKey)
WritePackageRegistryKey( packageFamilyName, packageFullName.GetRawBuffer(nullptr), userSid, &this->pluginDownlevelInstalledKey, L"DownlevelInstalled")
WritePackageRegistryKey( packageFamilyName, packageFullNameElement->GetValue(), userSid, &this->pluginStagedKey, L"Staged")
WritePackageRegistryKey( packageFamilyName.GetChars(), packageFullName, userSid, &this->pluginStagedUserAcquiredKey, L"Staged")
WritePackageRegistryKey( packageFullName.GetRawBuffer(nullptr), userSid, &this->pluginEndOfLifeKey, L"EndOfLife")
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, registryKey, keyName, manifestPath.GetString(), createdKey)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName.GetRawBuffer(nullptr), userSid, &this->pluginDownlevelInstalledKey, L"DownlevelInstalled", packageRoot.GetString(), &downlevelInstalledKey)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName.GetRawBuffer(nullptr), userSid, &this->pluginUpgradeKey, L"Upgrade", packageRoot.GetString(), &upgradeKey)
WritePackagesToCheckPostUpgradeToSetupKey()
Writing %ws Key %ws
Writing %ws Key %ws\%ws
Writing Applications Key %ws
Writing Downlevel all-user key %ws to uplevel key
Writing out to exclude file %ws in XML Writer.
Writing out to include directory %ws in XML Writer.
Writing out to include directory %ws, file %ws in XML Writer.
Writing out to include registry key %ws in XML Writer.
Writing out to include registry key %ws, value %ws in XML Writer.
Writing out to merge registry key %ws in XML Writer.
Writing out to merge registry key %ws, value %ws in XML Writer.
Writing out to move directory %ws to backup folder in XML Writer for OS downgrade.
Writing out to registry %ws in XML Writer.
Writing Package to PackagesToCheckForStagingCompletion Key: %ws
Writing up-level provisioned deprovisioned Package to PackagesToRemove Key: %ws
Writing up-level provisioned lower version Package to PackagesToRemove Key: %ws
x ATAVAWH
x AVH
X L9x
x UATAUAVAWH
x UAVAWH
x86a64
xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage"
Y@H9;u%L
z.9Wv
