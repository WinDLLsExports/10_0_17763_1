        
            
                
                 
                  
                    
                          
                              
                                        
                                                               
                                                                        <Group>Administrators</Group>
                                                                        <Name>{1}</Name>
                                                                       <PlainText>true</PlainText>
                                                                       <Value>{0}</Value>
                                                                      <PlainText>true</PlainText> 
                                                                      <Value>{0}</Value> 
                                                                    </DomainAccount>
                                                                    <Domain>{0}</Domain>
                                                                    <DomainAccount wcm:action="add">
                                                                   </AdministratorPassword>
                                                                   </Password>
                                                                   <AdministratorPassword>
                                                                   <Enabled>true</Enabled>
                                                                   <LogonCount>100</LogonCount>
                                                                   <Password>
                                                                   <Username>Administrator</Username>
                                                                  <Active>true</Active>
                                                                  <Group>Remote Desktop - RemoteFX</Group>
                                                                  <Profile>all</Profile>
                                                                </AutoLogon>
                                                                </DomainAccountList>
                                                                </UserAccounts>
                                                                <AutoLogon>
                                                                <DomainAccountList wcm:action="add">
                                                                <UserAccounts>
                                                               </FirewallGroup>
                                                               <FirewallGroup wcm:action="add" wcm:keyValue="RemoteDesktopRemoteFx">
                                                               <PlainText>true</PlainText> 
                                                               <Value>{2}</Value> 
                                                              <Description>Additional reboot required to complete installing integration services</Description>
                                                              <Description>Install Integration Services</Description>
                                                              <Order>6</Order>
                                                              <Order>7</Order>
                                                              <Path>CMD /C Echo Reboot</Path>
                                                              <Path>CMD /C START /WAIT %Windir%\Temp\IntegrationServices\support\%ARCH%\setup.exe /quiet /norestart</Path>
                                                              <PlainText>true</PlainText>
                                                              <Value>{1}</Value>
                                                              <WillReboot>Always</WillReboot>
                                                              <WillReboot>Never</WillReboot>
                                                            </AdministratorPassword>
                                                            </DomainAccounts>
                                                            </Password>
                                                            </RunSynchronousCommand>
                                                            <AdministratorPassword>
                                                            <DomainAccounts>
                                                            <Group>Administrators</Group>
                                                            <Name>{0}</Name>
                                                            <Password>
                                                            <RunSynchronousCommand wcm:action="add">
                                                           <PlainText>true</PlainText> 
                                                           <Value>{1}</Value> 
                                                          <LocalAccount wcm:action="add">
                                                         </LocalAccount>
                                                        </AdministratorPassword>
                                                        </LocalAccounts>
                                                        <AdministratorPassword>
                                                        <LocalAccounts>
                                                       </UserAccounts>
                                                    $windowsFolder = $Drive.DriveLetter + ':\Windows';
                                                    Get-Item $windowsFolder -ErrorAction SilentlyContinue -ErrorVariable windowsFolderError;
                                                    if ($windowsFolderError.Count -gt 0) {{ continue; }} else {{ $DriveLetter = $Drive.DriveLetter; break; }};
                                               $DriveLetter = $Drives.DriveLetter;
                                               {{
                                               }}
                                               foreach($Drive in $Drives)
                                              <Description>Additional reboot required to complete installing integration services</Description>
                                              <Order>5</Order>
                                              <Path>CMD /C Echo Reboot</Path>
                                              <WillReboot>Always</WillReboot>
                                             %WINDIR%\system32\sysprep\sysprep.exe %SYSPREPOPTIONS%
                                             DEL %WINDIR%\SYSTEM32\SYSPREP\UNATTEND.XML
                                            </RunSynchronousCommand>
                                            <RunSynchronousCommand wcm:action="add">
                                          #
                                          # Check if mount succeeded
                                          # If the VHD has multiple partitions, returned variable will have an array of mounted drives.
                                          # Mount Station VHD and get mounted drive.
                                          # Pick the system/primary drive letter from the mounted drives.
                                          # Script to execute after mounting VHD
                                          # Script to execute before mounting VHD
                                          $DriveLetter = $null;
                                          $Drives = Mount-VHD -Path '{1}' -PassThru {4} | Get-Disk | Get-Partition | Get-Volume;
                                          $Type = $Drives.GetType();
                                          {{
                                          {0}
                                          {3}
                                          }}
                                          else
                                          if ($DriveLetter -eq $null) {{ throw new-object Microsoft.SharedComputing.Utils.WmsCmdletException({2}, 'Unexpected error: Failed to mount station VHD file') }};
                                          if ($Drives -eq $null) {{ throw new-object Microsoft.SharedComputing.Utils.WmsCmdletException({2}, 'Unexpected error: Failed to mount station VHD file') }};
                                          if ($Type.IsArray -eq $True)
                                    <AccountData>{0}</AccountData>
                                </Provisioning>
                                <JoinDomain>{1}</JoinDomain>
                                <Provisioning>
                              #
                              # Cleanup Old Station VM & VHD
                              Remove-Item -Path '{1}' -ErrorAction SilentlyContinue -WarningAction SilentlyContinue;
                              Remove-VM -Name '{0}' -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue;
                            "Convert-WindowsImage cannot run against unstaged builds. Please try again with a staged build.",
                            "Error"
                            "OK",
                            "Unable to register message callback."
                            "Unable to unregister message callback."
                            "WIM is incompatible!",
                            $sysprepOptions = '/generalize /shutdown /oobe /quiet /mode:vm';
                            $sysprepOptions = '/generalize /shutdown /oobe /quiet';
                            </Identification>
                            <Identification>
                            CultureInfo.CurrentCulture,
                            language="neutral"
                            new WimImage(this, (uint)i + 1));
                            processorArchitecture="%ARCH%">
                            publicKeyToken="31bf3856ad364e35" 
                            status = (uint)ImageEventMessage.Abort;
                            versionScope="nonSxS"
                          #
                          # Stop VM
                          Get-VM -Name '{0}' | Stop-VM -Force -Turnoff -ErrorAction SilentlyContinue -WarningAction SilentlyContinue;
                         0,
                         attachVirtualDiskFlags,
                         IntPtr.Zero);
                         m_virtualHardDiskHandle,
                        "size",
                        "size", 
                        "The size of the virtual disk must be a multiple of 512."
                        "Unable to find the source file.",
                        "Unable to initialize the security descriptor for the virtual disk."
                        "VirtualStorageDeviceType must be VHD or VHDX."
                        "virtualStorageDeviceType",
                        $cmbSkuList.SelectedIndex = 0
                        $openFileDialog1.FileName = "$($env:Temp)\$(Split-Path $openFileDialog1.FileName -Leaf)"
                        $tempOpenWim.ImageNames.Contains("Windows Longhorn Server Core")) {
                        $tempOpenWim.ImageNames.Contains("Windows Longhorn Server") -or
                        $tempOpenWim.Images | %{ $cmbSkuList.Items.Add($_.ImageFlags) }
                        (int)returnCode
                        )
                        .FirstOrDefault<WimImage>();
                        // Get rid of the unicode file marker at the beginning of the XML.
                        // Load up each image so it's ready for us.
                        // This isn't likely to change while we have the image open, so cache it.
                        : NativeMethods.VirtualDiskAccessMask.None,
                        ? NativeMethods.VirtualDiskAccessMask.All
                        [Windows.Forms.MessageBox]::Show(
                        }
                        break;
                        builder.EnsureCapacity(charCount - 1);
                        builder.Length = charCount - 1;
                        builder.Remove(0, 1);
                        Copy-Item -Path $openFileDialog1.FileName -Destination $env:Temp -Force
                        ErrorEvent(this, eventArgs);
                        i.ImageFlags.ToUpper() == ImageName.ToUpper() ))
                        i.ImageName.ToUpper()  == ImageName.ToUpper() ||
                        if (fileToProcess.Abort == true) {
                        m_imageList.Add(
                        m_virtualHardDiskHandle,
                        m_xmlInfo = null;
                        m_xmlInfo = XDocument.Parse(builder.ToString().Trim());
                        path);
                        ProcessFileEvent(this, fileToProcess);
                        ProcessFileEventArgs fileToProcess = new ProcessFileEventArgs(fileToImage, lParam);
                        return
                        SetPosEvent(this, eventArgs);
                        SetRangeEvent(this, eventArgs);
                        size,
                        size, 
                        source
                        StepItEvent(this, eventArgs);
                        string fileToImage = Marshal.PtrToStringUni(wParam);
                        string.Format(
                        this.Close();
                        throw "The specified ISO does not appear to be valid Windows installation media."
                        throw new Win32Exception((int)returnCode);
                        throw new Win32Exception();
                        throw new-object Microsoft.SharedComputing.Utils.WmsCmdletException({1}, '{2}')
                        virtualStorageDeviceType,
                        Write-W2VInfo "Copying ISO $(Split-Path $openFileDialog1.FileName -Leaf) to temp folder..."
                        Write-W2VWarn "The UI may become non-responsive while this copy takes place..."                        
                      #
                      # Check for the presence of Windows\SysWow64 folder - to determine if the VHD is x86/amd64.
                      # Copy template & station unattend file(s) to sysprep folder
                      # Read the contents of sysprep file, and update architecture
                      # VM OS is not Win 8, remove /mode:vm
                      $completeCustomizationCommand = $completeCustomizationCommand.Replace('%SYSPREPOPTIONS%',$sysprepOptions);
                      $completeCustomizationCommand = '{3}';
                      $completeCustomizationScriptFile = $DriveLetter + ':\Windows\Temp\CompleteCustomization.cmd';
                      $CustomizeUnattendFile = $DriveLetter + ':\Windows\System32\sysprep\unattend.xml';
                      $immersiveControlPanelFolder = $DriveLetter + ':\Windows\ImmersiveControlPanel';
                      $sysprepCommand = '{2}';
                      $sysprepShortcutFile = $DriveLetter + ':\Windows\Temp\SysprepShortcut.cmd';
                      $sysWow64Folder = $DriveLetter + ':\Windows\SysWow64';
                      $unattendContent | foreach {{$_ -replace '%ARCH%',$architecture}} | Set-Content $CustomizeUnattendFile -Encoding Unicode;
                      $unattendContent = Get-Content -path $CustomizeUnattendFile;
                      {{
                      }}
                      }};
                      Copy-Item -Force '{0}' $CustomizeUnattendFile;
                      else
                      Get-Item $immersiveControlPanelFolder -ErrorAction SilentlyContinue -ErrorVariable immersiveControlPanelError;
                      Get-Item $sysWow64Folder -ErrorAction SilentlyContinue -ErrorVariable wow64Error;
                      if ($immersiveControlPanelError.Count -gt 0)
                      if ($wow64Error.Count -gt 0) {{ $architecture = 'x86' }} else {{ $architecture = 'amd64' }};
                      Set-Content -Path $completeCustomizationScriptFile -Value $completeCustomizationCommand;
                      Set-Content -Path $sysprepShortcutFile -Value $sysprepCommand;
                    # Check to see if there's a WIM file we can muck about with.
                    # Let's see if we're running against an unstaged build.  If we are, we need to blow up.
                    # Refresh the DiskImage object so we can get the real information about it.  I assume this is a bug.
                    $driveLetter = ($openIso | Get-Volume).DriveLetter
                    $openIso     = Get-DiskImage -ImagePath $isoPath
                    $openIso     = Mount-DiskImage -ImagePath $isoPath -StorageType ISO -PassThru
                    $SourcePath  = "$($driveLetter):\sources\install.wim"
                    $tempOpenWim   = New-Object WIM2VHD.WimFile $SourcePath
                    $tempOpenWim.Close()
                    $txtSourcePath.Text = $isoPath = (Resolve-Path $openFileDialog1.FileName).Path
                    $txtSourcePath.Text = $SourcePath = "$($env:Temp)\$(Split-Path $SourcePath -Leaf)"
                    $txtSourcePath.Text = $SourcePath = $openFileDialog1.FileName
                    (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                    .DefaultIfEmpty(null)
                    // And, since we were asked to detach it anyway, we can assume that the system
                    // Dispose managed resources.
                    // Ensure the length of the returned bytes to avoid garbage characters at the end.
                    // is already in the desired state.
                    // really good chance that it wasn't attached to begin with.
                    // There's nothing to do here.  The device wasn't found, which means there's a 
                    : 0,
                    ? NativeMethods.DEFAULT_BLOCK_SIZE
                    }
                    } else {
                    0
                    0);
                    0,
                    accessMask,
                    arch = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/ARCH").Value);
                    break;
                    build = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/BUILD").Value);
                    case NativeMethods.ERROR_NOT_FOUND:
                    case NativeMethods.ERROR_SUCCESS:
                    Container.Handle.DangerousGetHandle(),
                    Copy-Item -Path $SourcePath -Destination $env:Temp -Force
                    default:
                    Environment.ExpandEnvironmentVariables("%TEMP%")
                    flags,
                    for (int i = 0; i < imageCount; i++) {
                    if (!(Test-Path $SourcePath)) {
                    if (!NativeMethods.WimGetImageInformation(Handle, out builder, out bytes)) {
                    if ($tempOpenWim.ImageNames.Contains("Windows Longhorn Client") -or
                    if (null != builder) {
                    if (null != ErrorEvent) {
                    if (null != ProcessFileEvent) {
                    if (null != SetPosEvent) {
                    if (null != SetRangeEvent) {
                    if (null != StepItEvent) {
                    if (Test-IsNetworkLocation $openFileDialog1.FileName) {
                    if (this.DiskIndex != 0) {
                    ImageIndex);
                    Images.Where(i => (
                    int charCount = (int)bytes / sizeof(char);
                    int imageCount = (int)ImageCount;
                    lang = XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/LANGUAGES/DEFAULT").Value;
                    m_imageList = new List<WimImage>(imageCount);
                    m_virtualHardDiskHandle,
                    major = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/MAJOR").Value);
                    Match match = Regex.Match(path, @"\d+$"); // look for the last digits in the path
                    minor = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/MINOR").Value);
                    nameList.Add(image.ImageName);
                    NativeMethods.CreateVirtualDiskFlags.FullPhysicalAllocation,
                    NativeMethods.CreateVirtualDiskFlags.None,
                    NativeMethods.DetachVirtualDiskFlag.None,
                    NativeMethods.WimActionFlags.WimIgnored,
                    NativeMethods.WimCompressionType.WimIgnored,
                    NativeMethods.WimCreateFileDesiredAccess.WimGenericRead,
                    NativeMethods.WimCreationDisposition.WimOpenExisting,
                    new ArgumentOutOfRangeException(
                    new InvalidOperationException(
                    new SecurityException(
                    new System.IO.FileNotFoundException(
                    new Win32Exception(
                    out creationResult
                    overlapped,
                    path,
                    ProgressEvent(this, eventArgs);
                    ref  attachParameters,
                    ref  securityDescriptor,
                    ref pathSize,
                    return -1;
                    return null;
                    return path.ToString();
                    return System.Convert.ToInt32(match.Value, CultureInfo.InvariantCulture);
                    revision = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/SPBUILD").Value);
                    StringBuilder builder;
                    stringToReturn = m_FilePath;
                    System.Threading.Thread.Sleep(1000);
                    this,
                    this.m_virtualHardDiskHandle,
                    throw "Unable to load WIM metadata!"
                    throw (new SecurityException("Unable to initialize the security descriptor for the virtual disk."));
                    throw new ArgumentNullException("Container");
                    throw new ArgumentNullException("The handle to the WIM file has already been closed, or is invalid.", "Container");
                    throw new ArgumentNullException("wimPath");
                    throw new ArgumentOutOfRangeException("ImageIndex", "The index does not exist in the specified WIM file.");
                    throw new FileNotFoundException((new FileNotFoundException()).Message, wimPath);
                    throw new Win32Exception((int)returnCode);
                    throw new Win32Exception();
                    uint bytes;
                    wimPath,
                    Write-W2VInfo "Copying WIM $(Split-Path $SourcePath -Leaf) to temp folder..."
                    Write-W2VInfo "Looking for $($SourcePath)..."
                    Write-W2VInfo "Opening ISO $(Split-Path $isoPath -Leaf)..."
                    Write-W2VTrace "Closing WIM metadata..."
                    Write-W2VWarn "The UI may become non-responsive while this copy takes place..."
                  #
                  # and ready to be associated as a parent VHD for station VHDs.
                  # Check for the presence of Windows\SysWow64 folder - to determine if the VHD is x86/amd64.
                  # Configure Resolution
                  # Configure station VM to not start by default (on host reboot) and
                  # Configure vGPU if there is atleast one GPU that supports RemoteFX and that meets
                  # Copy remote connection RDP files for WMS Manager & Dashboard
                  # Copy template & station unattend file(s) to sysprep folder
                  # Create a differencing VHD
                  # Create SetupBinaries folder, if not present
                  # Create Virtual Machine for Virtual Desktop Template
                  # Create WMS startMenuFolder folder, if not present
                  # Delete previous instance(s) of the VM to be created.
                  # Enable dynamic memroy for station VM
                  # Enable dynamic memroy for the template VM
                  # End of script.
                  # End of script. 
                  # Load system registry hive from the vhd.
                  # minimum requirements for DirectX
                  # Note: Station Virtual Machine will be started when the station is configured.
                  # Query generalization state value
                  # Read the contents of sysprep file, and add reboot task for Win7
                  # Read the contents of sysprep file, and update architecture
                  # Read the contents of sysprep file, and update architecture and sysprep options
                  # Remove old station disk that uses the same template prefix, ignore if not found.
                  # Return values
                  # Script currently will not start station virtual machine.
                  # Script to create virtual desktop template
                  # Start the VM - this will go through OS configuration phase and auto-sysprep itself
                  # Start VM - 
                  # to shutdown when the host is shutdown
                  # Update computer name in station's unattend file
                  $editionIDkey = Get-ItemProperty 'HKLM:\{0}\Microsoft\Windows NT\CurrentVersion' EditionID;
                  $eduEditionID = 'Education';
                  $enterpriseEditionID = 'Enterprise';
                  $GeneralizationState = Get-ItemProperty HKLM:\{0}\SETUP\STATUS\SYSPREPSTATUS GeneralizationState;
                  $GeneralizationState = Get-ItemProperty HKLM:\{1}\SETUP\STATUS\SYSPREPSTATUS GeneralizationState;
                  $GeneralizationState.GeneralizationState;
                  $immersiveControlPanelFolder = $DriveLetter + ':\Windows\ImmersiveControlPanel';
                  $majorVersionkey = Get-ItemProperty 'HKLM:\{0}\Microsoft\Windows NT\CurrentVersion' CurrentMajorVersionNumber;
                  $minorVersionkey = Get-ItemProperty 'HKLM:\{0}\Microsoft\Windows NT\CurrentVersion' CurrentMinorVersionNumber;
                  $proEditionID = 'Professional';
                  $rebootTask = '';
                  $rfxAdapter = Get-VMRemoteFxPhysicalVideoAdapter;
                  $SetupBinariesPath = $DriveLetter + ':\Windows\Setup\Scripts';
                  $startMenuFolder = $DriveLetter + ':\ProgramData\Microsoft\Windows\Start Menu\Programs\Windows MultiPoint Server';
                  $StationUnattendFile = $DriveLetter + ':\Windows\System32\sysprep\unattend-s.xml';
                  $SysprepGeneralizeSucceeded = 4;
                  $sysWow64Folder = $DriveLetter + ':\Windows\SysWow64';
                  $TempBinariesPath = $DriveLetter + ':\Windows\Temp';
                  $TemplateUnattendFile = $DriveLetter + ':\Windows\System32\sysprep\unattend.xml';
                  $unattendContent | foreach {{$_ -replace '%ARCH%',$architecture}} | Set-Content $StationUnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%ARCH%',$architecture}} | Set-Content $TemplateUnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%ARCH%',$architecture}} | Set-Content $UnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%HOSTCOMPUTERNAME%','{6}'}} | Set-Content $UnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%INSTALLINTEGRATIONSERVICES%',$installIntegrationServices}} | Set-Content $TemplateUnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%REBOOTTASKFORWINDOWS7%',$rebootTask}} | Set-Content $UnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%REMOTEDESKTOPREMOTEFXFIREWALL%',$remoteDesktopRemoteFxFirewall}} | Set-Content $TemplateUnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%STATIONCOMPUTERDOMAINJOINBLOB%','{4}'}} | Set-Content $UnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%STATIONCOMPUTERNAME%','{1}'}} | Set-Content $UnattendFile -Encoding Unicode;
                  $unattendContent | foreach {{$_ -replace '%SYSPREPOPTIONS%',$sysprepOptions}} | Set-Content $TemplateUnattendFile -Encoding Unicode;
                  $unattendContent = Get-Content -path $StationUnattendFile;
                  $unattendContent = Get-Content -path $TemplateUnattendFile;
                  $unattendContent = Get-Content -path $UnattendFile;
                  $UnattendFile = $DriveLetter + ':\Windows\System32\sysprep\unattend.xml';
                  $VHDMountLocation = $DriveLetter + ':\';
                  $win10MajorVersion = 10;
                  $win10MinorVersion = 0;
                  {{
                  }};
                  Copy-Item -Force '{1}' $TemplateUnattendFile;
                  Copy-Item -Force '{5}' $StationUnattendFile;
                  Copy-Item -Force '{6}' $startMenuFolder'\MultiPoint Manager.RDP';
                  Copy-Item -Force '{7}' $startMenuFolder'\MultiPoint Dashboard.RDP';
                  Get-Item $sysWow64Folder -ErrorAction SilentlyContinue -ErrorVariable wow64Error;
                  Get-VM -Id '{0}' | Start-VM;
                  Get-VM -Name '{0}' | Start-VM;
                  if ($GeneralizationState.GeneralizationState -eq $SysprepGeneralizeSucceeded)
                  if ($wow64Error.Count -gt 0) {{ $architecture = 'x86' }} else {{ $architecture = 'amd64' }};
                  if (($editionIDkey -eq $null) -or (($editionIDkey.EditionID.Contains($enterpriseEditionID) -eq $false) -and ($editionIDkey.EditionID.Contains($proEditionID) -eq $false) -and ($editionIDkey.EditionID.Contains($eduEditionID) -eq $false)))
                  if (($majorVersionkey -eq $null) -or ($minorVersionkey -eq $null) -or ($majorVersionkey.CurrentMajorVersionNumber -ne $win10MajorVersion) -or ($minorVersionkey.CurrentMinorVersionNumber -ne $win10MinorVersion))
                  if($rfxAdapter -ne $null) {{ Add-VMRemoteFx3dVideoAdapter -VMName '{1}'; }};
                  if($rfxAdapter -ne $null) {{ Set-VMRemoteFx3dVideoAdapter -VMName '{1}' -MaximumResolution 1920x1200; }};
                  New-Item -Force $SetupBinariesPath -Type Directory;
                  New-Item -Force $startMenuFolder -Type Directory;
                  New-VHD -Path '{0}' -ParentPath '{1}' -Differencing;
                  New-VM -Name '{0}' -VHDPath '{1}' -MemoryStartupBytes {2}MB -SwitchName WMS;
                  New-VM -Name '{1}' -VHDPath '{0}' -MemoryStartupBytes {3}MB -SwitchName WMS;
                  REG LOAD HKLM\{0} ${{DriveLetter}}:\Windows\System32\Config\SOFTWARE;
                  REG LOAD HKLM\{0} ${{DriveLetter}}:\Windows\System32\Config\SYSTEM;
                  REG LOAD HKLM\{1} ${{DriveLetter}}:\Windows\System32\Config\SYSTEM;
                  REG UNLOAD HKLM\{0};
                  REG UNLOAD HKLM\{1};
                  Remove-Item -Path '{0}' -ErrorAction SilentlyContinue;
                  Remove-VM -Name '{0}' -Force -ErrorAction SilentlyContinue;
                  Remove-VM -Name '{1}' -Force -ErrorAction SilentlyContinue;
                  Set-VM -Name '{1}' -AutomaticStartAction Nothing -AutomaticStopAction ShutDown;
                  Set-VMMemory -VMName '{0}' -DynamicMemoryEnabled 1;
                  Set-VMMemory -VMName '{1}' -DynamicMemoryEnabled 1;
                  Set-VMProcessor -VMName '{1}' -Count {5};
                # Check to see if the WIM is local, or on a network location.  If the latter, copy it locally.
                $SourcePath = (Resolve-Path $SourcePath).Path
                $tempOpenWim = $null
                $UnattendPath = $txtUnattendFile.Text = $openFileDialog1.FileName
                $WorkingDirectory = $txtWorkingDirectory = $openFolderDialog1.SelectedPath
                (overlapped != IntPtr.Zero && NativeMethods.ERROR_IO_PENDING != returnCode)) {
                (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD) 
                ));
                );
                // and unmanaged resources.
                // Call the appropriate methods to clean up
                // Check results.
                // For attach, the correct version is always Version1 for Win7 and Win8.
                // Get the current disk index.  We need it later.
                // If disposing equals true, dispose all managed
                // If disposing is false,
                // If it's not updated after that, it's probably not our fault.
                // If the disk index isn't updated, keep checking once per second for five seconds.
                // Note disposing has been done.
                // only the following code is executed.
                // Set the temporary path.
                // There's apparently a bit of a timing issue here on some systems.
                // Throw an exception if something bad happened on the Win32 end.
                // unmanaged resources here.
                : base(IntPtr.Zero, true) {
                : NativeMethods.CreateVirtualDiskVersion.Version2;
                : NativeMethods.OpenVirtualDiskVersion.Version2;
                : virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorMicrosoft;
                ? NativeMethods.CreateVirtualDiskVersion.Version1
                ? NativeMethods.OpenVirtualDiskVersion.Version1
                ? virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorUnknown
                }
                } catch {
                } catch { }
                } else {
                } else if (NativeMethods.ERROR_SUCCESS == returnCode) {
                } finally {
                </component>
                <component name="Microsoft-Windows-UnattendedJoin"
                0,
                ApplyToPath,
                attachParameters.Reserved = 0;
                attachParameters.Version = NativeMethods.AttachVirtualDiskVersion.Version1;
                availableDrives.Add((char)i);
                availableDrives.Remove(drive.ToUpper(CultureInfo.InvariantCulture)[0]);
                case ImageEventMessage.Error:
                case ImageEventMessage.Process:
                case ImageEventMessage.Progress:
                case ImageEventMessage.SetPos:
                case ImageEventMessage.SetRange:
                case ImageEventMessage.StepIt:
                default:
                flags,
                foreach (WimImage image in Images) {
                get { return this.handle == IntPtr.Zero; }
                Handle.Close();
                if (!File.Exists(Path.GetFullPath(wimPath))) {
                if (!NativeMethods.InitializeSecurityDescriptor(out securityDescriptor, 1)) {
                if (([IO.FileInfo]$openFileDialog1.FileName).Extension -ilike ".iso") {
                if ((Container.Handle.IsClosed) || (Container.Handle.IsInvalid)) {
                if (creationResult != NativeMethods.WimCreationResult.WimOpenedExisting) {
                if (disposing) {
                if (ImageIndex > Container.ImageCount) {
                if (m_FilePath != null) {
                if (NativeMethods.ERROR_ERROR_DEV_NOT_EXIST == returnCode) {
                if (null != path) {
                if (null == Container) {
                if (null == m_imageList) {
                if (null == m_xmlInfo) {
                if (String.IsNullOrEmpty(wimPath)) {
                if (Test-IsNetworkLocation $SourcePath) {
                if (this.handle == IntPtr.Zero) {
                image.Close();
                int arch = -1;
                int build = 0;
                int diskIndex = this.DiskIndex;
                int major = 0;
                int minor = 0;
                int revision = 0;
                IntPtr overlapped) {
                IntPtr.Zero,
                List<string> nameList = new List<string>();
                m_isDisposed = true;
                m_virtualHardDiskHandle,
                NativeMethods.AttachVirtualDiskParameters attachParameters = new NativeMethods.AttachVirtualDiskParameters();
                NativeMethods.CompactVirtualDiskFlags.None);
                NativeMethods.DISK_SECTOR_SIZE);
                NativeMethods.SecurityDescriptor securityDescriptor;
                NativeMethods.UnregisterMessageCallback(this.Handle, wimMessageCallback);
                NativeMethods.WimApplyFlags.WimApplyFlagsNone
                NativeMethods.WimCreationResult creationResult;
                NativeMethods.WimSetTemporaryPath(
                null,
                out vhdHandle);
                overlapped);
                overlapped,
                overwrite,
                path,
                ref createParams,
                ref openParams,
                ref progress);
                ref securityDescriptor,
                ref virtualStorageType,
                return
                return (Architectures)arch;
                return (new Version(major, minor, build, revision));
                return (this.DiskIndex != -1);
                return lang;
                return m_imageList;
                return m_virtualHardDiskHandle;
                return m_xmlInfo;
                return nameList;
                return NativeMethods.WimCloseHandle(this.handle);
                return stringToReturn;
                return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/PRODUCTTYPE").Value;
                returnCode = NativeMethods.GetVirtualDiskPhysicalPath(
                short attempts = 5;
                size,
                string lang = null;
                string path = PhysicalPath;
                string stringToReturn = "";
                string wimPath)
                StringBuilder path = new StringBuilder((int)pathSize);
                switch (returnCode) {
                System.IO.File.Delete(path);
                this.handle = NativeMethods.WimCreateFile(
                this.handle = NativeMethods.WimLoadImage(
                this.Handle,
                throw
                throw (
                throw new ArgumentNullException("ApplyToPath");
                throw new ArgumentNullException("Container");
                throw new ArgumentNullException("The handle to the WIM file has already been closed, or is invalid.", "Container");
                throw new ArgumentNullException("wimPath");
                throw new ArgumentOutOfRangeException("ImageIndex", "The index does not exist in the specified WIM file.");
                throw new DirectoryNotFoundException("The WIM cannot be applied because the specified directory was not found.");
                throw new FileNotFoundException("The specified VHD was not found.  Please check your path and try again.", path);
                throw new FileNotFoundException((new FileNotFoundException()).Message, wimPath);
                throw new InvalidOperationException("The handle to the Virtual Hard Disk is invalid.");
                throw new Win32Exception((int)returnCode);
                throw new Win32Exception();
                try {
                uint ImageIndex)
                uint pathSize = 1024;  // Isn't MAX_PATH 255?
                uint returnCode = 0;
                uint returnCode = NativeMethods.AttachVirtualDisk(
                uint returnCode = NativeMethods.DetachVirtualDisk(
                virtualStorageDeviceType,
                while ((attempts-- >= 0) && (diskIndex == this.DiskIndex)) {
                WimFile Container,
                wimMessageCallback = null;
                Write-W2VInfo "Scanning WIM metadata..."
                Write-W2VInfo "Selected Working Directory is $WorkingDirectory..."
               -ArgumentList "\\.\ROOT\WMI:BCDObject.Id=`"$($BOOTMGR_ID)`",StoreFilePath=`"$($BcdStoreFile.Replace('\', '\\'))`""
              $installIntegrationServices = '';
              $remoteDesktopRemoteFxFirewall = '';
              $sysprepOptions = '/generalize /shutdown /oobe /quiet /mode:vm'
             $Edition = $image.ImageFlags;
             -ArgumentList "\\.\ROOT\WMI:BCDObject.Id=`"$($defaultBootEntryId)`",StoreFilePath=`"$($BcdStoreFile.Replace('\', '\\'))`""
             break;
            "$($drive)Windows",    # Path to the \Windows on the VHD
            "/f BIOS",              # Support BIOS only
            "/s $drive",           # Specifies the volume letter of the drive to create the \BOOT folder on.
            "/v"                   # Enabled verbose logging.
            # Correct the initial state of the form to prevent the .Net maximized form issue
            # If the WorkingDirectory is anything besides $pwd, tell people that the WorkingDirectory is being ignored.
            $Edition      = $cmbSkuList.SelectedItem
            $editionId += "Core"
            $false if user is not an admin.
            $frmMain.Close()
            $frmMain.WindowState      = $InitialFormWindowState
            $openFileDialog1.CheckFileExists    = $true
            $openFileDialog1.CheckPathExists    = $true
            $openFileDialog1.FileName           = $null
            $openFileDialog1.Filter             = "All compatible files (*.ISO, *.WIM)|*.ISO;*.WIM|All files (*.*)|*.*"
            $openFileDialog1.Filter             = "XML files (*.xml)|*.XML|All files (*.*)|*.*"
            $openFileDialog1.FilterIndex        = 1
            $openFileDialog1.InitialDirectory   = $pwd
            $openFileDialog1.ShowHelp           = $false
            $openFileDialog1.Title              = "Select a source file..."
            $openFileDialog1.Title              = "Select an unattend file..."
            $openFolderDialog1.Description      = "Select the folder you'd like your VHD(X) to be created in."
            $openFolderDialog1.RootFolder       = "Desktop"
            $openFolderDialog1.SelectedPath     = $WorkingDirectory
            $result = $true
            $ret = $openFileDialog1.ShowDialog()
            $ret = $openFolderDialog1.ShowDialog()
            $SizeBytes = 2040GB
            $SizeBytes,
            $skuFamily = "Client"
            $skuFamily = "Server"
            $skuFamily = "Unknown"
            $SourcePath = "$($env:Temp)\$(Split-Path $SourcePath -Leaf)"
            $true
            $true if user is admin.
            $VHDFormat,
            $VHDPath      = "$($WorkingDirectory)\$($txtVhdName.Text)"
            $VHDPath  = Join-Path $WorkingDirectory $VHDPath
            $VHDPath,
            $WorkingDirectory = Split-Path $VHDPath -Parent
            )) {
            //
            // Check to see if Dispose has already been called.
            // Create and init a security descriptor.
            // Hook up the events before we return.
            // Select the correct version.
            // Since we're creating an essentially blank SD to use with CreateVirtualDisk
            // the VHD will take on the security values from the parent directory.
            // Validate size.  It needs to be a multiple of DISK_SECTOR_SIZE (512)...
            // Validate the virtualStorageDeviceType
            /// (FILE_READ_ATTRIBUTES | FILE_READ_DATA) access to the virtual disk image file.
            /// </remarks>
            /// </summary>
            /// <remarks>
            /// <remarks>Oddly enough, this doesn't apply to NTFS mount points.</remarks>
            /// <summary>
            /// A CREATE_VIRTUAL_DISK_VERSION enumeration that specifies the version of the CREATE_VIRTUAL_DISK_PARAMETERS structure being passed to or from the virtual hard disk (VHD) functions.
            /// A GUID to use for fallback resiliency over SMB.
            /// Allows unrestricted access to the virtual disk. The caller must have unrestricted access rights to the virtual disk image file.
            /// Applies the image without physically creating directories or files. Useful for obtaining a list of files and directories in the image.
            /// Attach the virtual disk as read-only.
            /// Contains virtual hard disk (VHD) creation flags.
            /// Disables automatic path fixups for junctions and symbolic links.
            /// Disables restoring security information for directories.
            /// Disables restoring security information for files
            /// disk image file, up to readWriteDepth if working with a differencing chain.
            /// during the prior open request for that differencing chain.
            /// Flags for opening the VHD
            /// For internal use only.  This type is not supported.
            /// GetInfoOnly flag for V2 handles
            /// If a ParentPath is specified, this value must be zero.
            /// If a SourcePath is specified, this value can be zero to specify the size of the source VHD to be used, otherwise the size specified must be greater than or equal to the size of the source disk.
            /// If the virtual disk is part of a differencing chain, the backing store (host volume) is opened in RW exclusive mode up to readWriteDepth.
            /// If the virtual disk is part of a differencing chain, the disk for this request cannot be less than the readWriteDepth specified
            /// If this parameter is not NULL, ParentPath must be NULL.
            /// If this parameter is not NULL, SourcePath must be NULL.
            /// If used in a request to open a virtual disk that is already open, the other handles must be limited to either
            /// Information retrieval access to the virtual disk. The caller must have READ access to the virtual disk image file.
            /// Internal size of the virtual disk object blocks.
            /// Internal size of the virtual disk object sectors. Must be set to 512.
            /// No drive letters are assigned to the disk's volumes.
            /// No flags.
            /// No flags. Use system defaults.
            /// Only Version2 of OpenVirtualDisk API accepts this parameter
            /// Open the VHD file (backing store) without opening any differencing-chain parents. Used to correct broken parent links.
            /// Open the virtual disk for read-only attach access. The caller must have READ access to the virtual disk image file.
            /// Open the virtual disk for read-write attaching access. The caller must have (READ | WRITE) access to the virtual disk image file.
            /// Open the virtual disk to allow detaching of an attached virtual disk. The caller must have
            /// Open the virtual disk to perform offline meta-operations. The caller must have (READ | WRITE) access to the virtual
            /// Optional path to a parent virtual disk object. Associates the new virtual disk with an existing virtual disk.
            /// Optional path to pre-populate the new virtual disk object with block data from an existing disk. This path may refer to a VHD or a physical disk.
            /// Pre-allocate all physical space necessary for the size of the virtual disk.
            /// Reserved.
            /// Returns a handle that cannot commit changes, regardless of the access level requested at mount time.
            /// Sends a WIM_MSG_FILEINFO message during the apply operation.
            /// Specifies that the image is to be sequentially read for caching or performance purposes.
            /// The .wim file is opened in a mode that enables simultaneous reading and writing.
            /// The CREATE_VIRTUAL_DISK_FLAG_FULL_PHYSICAL_ALLOCATION flag is used for the creation of a fixed VHD.
            /// The following are predefined block sizes and their behaviors. For a fixed VHD type, this parameter must be zero.
            /// The maximum virtual size of the virtual disk object. Must be a multiple of 512.
            /// The storage type is unknown or not valid.
            /// The virtual disk will be attached until the Detach() function is called, even if all open handles to the virtual disk are closed.
            /// Unique identifier to assign to the virtual disk object. If this member is set to zero, a unique identifier is created by the system.
            /// Verifies that files match original data.
            /// Virtual disk creation access.
            /// Virtual Hard Disk device type.
            /// Virtual Hard Disk v2 device type.
            /// Virtual Storage Type of the parent disk
            /// Virtual Storage Type of the source disk
            /// VIRTUAL_DISK_ACCESS_DETACH or VIRTUAL_DISK_ACCESS_GET_INFO access, otherwise the open request with this flag will fail.
            /// Will decouple the virtual disk lifetime from that of the VirtualDiskHandle.
            ///</summary>
            ///<summary>
            ///Abort.
            ///Alerts the caller that an error has occurred while capturing or applying an image.
            ///Enables the caller to align a file resource on a particular alignment boundary.
            ///Enables the caller to prevent a file or a directory from being captured or applied.
            ///Enables the caller to prevent a file resource from being compressed during a capture.
            ///Indicates an update in the progress of an image application.
            ///Indicates that a file has been either captured or applied.
            ///Indicates that volume information is being gathered during an image capture.
            ///Indicates the number of files that have been captured or applied.
            ///Indicates the number of files that will be captured or applied.
            ///Notification sent to enable the caller to prevent a file or a directory from being captured or applied.
            ///Success.
            ///To prevent a file or a directory from being captured or applied, call WindowsImageContainer.SkipFile().
            //NativeMethods.RegisterMessageCallback(this.Handle, wimMessageCallback);
            //wimMessageCallback = new NativeMethods.WimMessageCallback(ImageEventMessagePump);
            : uint {
            [In, MarshalAs(UnmanagedType.LPWStr)] string WimPath,
            [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string Path,
            [In, Optional]  IntPtr lpEventAttributes,
            [In, Optional]  string lpName);
            [In, Optional] IntPtr             ImageInfo
            [In, Optional] WimFileHandle      hWim,
            [In, Out] ref AttachVirtualDiskParameters Parameters,
            [In, Out] ref CompactVirtualDiskParameters Parameters,
            [In, Out] ref CreateVirtualDiskParameters Parameters,
            [In, Out] ref OpenVirtualDiskParameters Parameters,
            [In, Out] ref SecurityDescriptor SecurityDescriptor,
            [In, Out] ref uint DiskPathSizeInBytes,
            [In, Out] ref VirtualDiskProgress Progress);
            [In, Out] ref VirtualStorageType VirtualStorageType,
            [In]            bool bInitialState,
            [In]            bool bManualReset,
            [In]           WimMessageCallback MessageProc
            [In]           WimMessageCallback MessageProc,
            [In]          AttachVirtualDiskFlags Flags,
            [In]          CompactVirtualDiskFlags Flags,
            [In]          CreateVirtualDiskFlags Flags,
            [In]          IntPtr Overlapped);
            [In]          IntPtr Overlapped,
            [In]          NativeMethods.DetachVirtualDiskFlag Flags,
            [In]          OpenVirtualDiskFlags Flags,
            [In]          SafeFileHandle VirtualDiskHandle,
            [In]          string Path,
            [In]          uint dwRevision);
            [In]          uint ProviderSpecificFlags);
            [In]          uint ProviderSpecificFlags,
            [In]          VirtualDiskAccessMask VirtualDiskAccessMask,
            [In]        SafeHandle Handle,
            [In]    IntPtr Handle
            [In]    IntPtr Handle,
            [In]    string TempPath
            [In]    uint ImageIndex
            [In]    WimActionFlags FlagsAndAttributes,
            [In]    WimApplyFlags Flags
            [In]    WimCompressionType CompressionType,
            [In]    WimCreateFileDesiredAccess DesiredAccess,
            [In]    WimCreationDisposition CreationDisposition,
            [In]    WimFileHandle Handle
            [In]    WimFileHandle Handle,
            [In]    WimImageHandle Handle,
            [Out, Optional] out WimCreationResult CreationResult
            [Out]         StringBuilder DiskPath);
            [Out]     out SafeFileHandle Handle);
            [Out]     out SecurityDescriptor pSecurityDescriptor,
            [Out]   out StringBuilder ImageInfo,
            [Out]   out uint SizeOfImageInfo
            }
            };
            3 { $unit = "MB"; break }
            4 { $unit = "GB"; break }
            5 { $unit = "TB"; break }
            Abort = NativeMethods.WimMessage.WIM_MSG_ABORT_IMAGE
            Alignment = NativeMethods.WimMessage.WIM_MSG_ALIGNMENT,
            All                        = 0x003F0000,
            AMD64 = 0x9
            An array of arguments to pass to the executable when it's executed.
            ApplyToPath = Path.GetFullPath(ApplyToPath);
            ARM   = 0x5,
            AttachReadOnly             = 0x00010000,
            AttachReadWrite            = 0x00020000,
            -BcdStoreFile    "$($drive)boot\bcd"  `
            BlankFile                  = 0x00000002,
            bool disposing) {
            bool overwrite) {
            bool overwrite,
            bool status = NativeMethods.WimUnregisterMessageCallback(hWim, registeredCallback);
            BootDrive                  = 0x00000004,
            byte[] byteBuffer = {
            compactParams.Version = NativeMethods.CompactVirtualDiskVersion.Version1;
            Compress = NativeMethods.WimMessage.WIM_MSG_COMPRESS,
            Copy-Item -Path $SourcePath -Destination $env:Temp -Force
            Create                     = 0x00100000,
            createParams.BlockSizeInBytes         = blockSizeInBytes;
            createParams.GetInfoOnly              = false;
            createParams.MaximumSize              = size;
            createParams.OpenFlags                = NativeMethods.OpenVirtualDiskFlags.None;
            createParams.ParentPath               = null;
            createParams.ParentVirtualStorageType = new NativeMethods.VirtualStorageType();
            createParams.SectorSizeInBytes        = sectorSizeInBytes;
            createParams.SourcePath               = source;
            createParams.SourceVirtualStorageType = new NativeMethods.VirtualStorageType();
            createParams.UniqueId                 = Guid.NewGuid();
            createParams.Version = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
            default { $unit = ""; break }
            DefaultImageEventArgs eventArgs = new DefaultImageEventArgs(wParam, lParam, UserData);
            Detach                     = 0x00040000,
            Determines whether or not a given path is a network location or a local drive.
            -DiskSignature   $disk.Signature      `
            Do you honestly need one?  There are no parameters!
            Error = NativeMethods.WimMessage.WIM_MSG_ERROR,
            for (int i = (byte)'C'; i <= (byte)'Z'; i++) {
            foreach (string drive in System.Environment.GetLogicalDrives()) {
            foreach (WimImage image in Images) {
            FullPhysicalAllocation     = 0x00000001
            Function to determine whether or not a specified path is a local path, a UNC path,
            GC.SuppressFinalize(this);
            GCHandle handleForOverllapped = GCHandle.Alloc(overlapped, GCHandleType.Pinned);
            get {
            get { return Images[ImageIndex - 1]; }
            get { return m_Abort;  }
            get { return NativeMethods.WimGetImageCount(Handle); }
            get { return ulong.Parse(XmlInfo.XPathSelectElement("/IMAGE/TOTALBYTES").Value); }
            get { return XmlInfo.Element("IMAGE").Attribute("INDEX").Value; }
            get { return XmlInfo.XPathSelectElement("/IMAGE/DESCRIPTION").Value; }
            get { return XmlInfo.XPathSelectElement("/IMAGE/DISPLAYDESCRIPTION").Value; }
            get { return XmlInfo.XPathSelectElement("/IMAGE/DISPLAYNAME").Value; }
            get { return XmlInfo.XPathSelectElement("/IMAGE/FLAGS").Value; }
            get { return XmlInfo.XPathSelectElement("/IMAGE/NAME").Value; }
            get { return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/EDITIONID").Value; }
            get { return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/INSTALLATIONTYPE").Value; }
            get;
            GetInfo                    = 0x00080000,
            Handle = new NativeMethods.WimFileHandle(wimPath);
            Handle = new NativeMethods.WimImageHandle(Container, ImageIndex);
            IA64  = 0x6,
            if (!Directory.Exists(ApplyToPath)) {
            if (!File.Exists(path)) {
            if (!File.Exists(Path.GetFullPath(wimPath))) {
            if (!NativeMethods.InitializeSecurityDescriptor(out securityDescriptor, 1)) {
            if (!NativeMethods.WimApplyImage(
            if (!status) {
            if (!this.IsAttached) {
            if (!this.m_isDisposed) {
            if ($ret -ilike "ok") {
            if ((!Handle.IsClosed) && (!Handle.IsInvalid)) {
            if ((!String.IsNullOrEmpty(source)) && (!System.IO.File.Exists(source))) {
            if ((Container.Handle.IsClosed) || (Container.Handle.IsInvalid)) {
            if ((overlapped == IntPtr.Zero && NativeMethods.ERROR_SUCCESS != returnCode) ||
            if ((overwrite) && (System.IO.File.Exists(path))) {
            if ((size % NativeMethods.DISK_SECTOR_SIZE) != 0) {
            if (0 != rc) {
            if (Handle.IsInvalid || Handle.IsClosed) {
            if (ImageIndex > Container.ImageCount) {
            if (NativeMethods.ERROR_SUCCESS != returnCode && NativeMethods.ERROR_IO_PENDING != returnCode) {
            if (NativeMethods.ERROR_SUCCESS != returnCode) {
            if (null != wimMessageCallback) {
            if (null == Container) {
            if (string.IsNullOrEmpty(ApplyToPath)) {
            if (string.IsNullOrEmpty(wimPath)) {
            if (this.IsAttached) {
            if (virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHD && virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHDX) {
            int byteBufferSize = byteBuffer.Length;
            int rc = Marshal.GetLastWin32Error();
            IntPtr leftParameter, 
            IntPtr lParam,
            IntPtr overlapped,
            IntPtr skipFileFlag) {
            IntPtr UserData
            IntPtr UserData) {
            IntPtr userData) {
            IntPtr wideParameter, 
            IntPtr wParam,
            ISO                        = 0x00000001,
            LeftParameter = leftParameter;
            List<Char> availableDrives = new List<Char>();
            m_deviceType = DeviceType;
            m_FilePath = file;
            m_filePath = Path;
            m_SkipFileFlag = skipFileFlag;
            m_virtualHardDiskHandle = Handle;
            m_virtualHardDiskHandle.Close();
            Marshal.Copy(byteBuffer, 0, m_SkipFileFlag, byteBufferSize);
            MetaOperations             = 0x00200000,
            NativeMethods.AttachVirtualDiskFlags attachVirtualDiskFlags) {
            NativeMethods.CompactVirtualDiskFlags flags) {
            NativeMethods.CompactVirtualDiskParameters compactParams = new NativeMethods.CompactVirtualDiskParameters();
            NativeMethods.CreateVirtualDiskParameters createParams = new NativeMethods.CreateVirtualDiskParameters();
            NativeMethods.OpenVirtualDiskFlags flags,
            NativeMethods.OpenVirtualDiskParameters openParams = new NativeMethods.OpenVirtualDiskParameters();
            NativeMethods.SecurityDescriptor securityDescriptor;
            NativeMethods.VirtualDiskAccessMask accessMask,
            NativeMethods.VirtualStorageDeviceType DeviceType) {
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType) {
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            NativeMethods.VirtualStorageType virtualStorageType = new NativeMethods.VirtualStorageType();
            NativeOverlapped overlapped = new NativeOverlapped();
            NoBlockMoves               = 0x00000002
            NoDriveLetter              = 0x00000002,
            NoLocalHost                = 0x00000008
            None                       = 0x00000000
            None                       = 0x00000000,
            NoParents                  = 0x00000001,
            NoZeroScan                 = 0x00000001,
            openParams.GetInfoOnly = false;
            openParams.Version = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
            or a mapped network drive.
            overlapped.EventHandle = NativeMethods.CreateEvent(IntPtr.Zero, true, false, null);
            -PartitionOffset $partition.Offset    
            -PartitionStyle  $PARTITION_STYLE_MBR `
            PermanentLifetime          = 0x00000004,
            private set;
            Process = NativeMethods.WimMessage.WIM_MSG_PROCESS,
            Progress = NativeMethods.WimMessage.WIM_MSG_PROGRESS,
            protected override bool ReleaseHandle() {
            public AttachVirtualDiskVersion Version;
            public bool GetInfoOnly;
            public byte revision;
            public byte size;
            public CompactVirtualDiskVersion Version;
            public CreateVirtualDiskVersion Version;
            public Guid ResiliencyGuid;
            public Guid UniqueId;
            public Guid VendorId;
            public int OperationStatus;
            public int Reserved;
            public IntPtr dacl;
            public IntPtr group;
            public IntPtr owner;
            public IntPtr sacl;
            public OpenVirtualDiskFlags OpenFlags;
            public OpenVirtualDiskVersion Version;
            public override bool IsInvalid {
            public short control;
            public string ParentPath;
            public string SourcePath;
            public uint BlockSizeInBytes;
            public uint Reserved;
            public uint SectorSizeInBytes;
            public ulong CompletionValue;
            public ulong CurrentValue;
            public ulong MaximumSize;
            public VirtualStorageDeviceType DeviceId;
            public VirtualStorageType ParentVirtualStorageType;
            public VirtualStorageType SourceVirtualStorageType;
            public WimFileHandle(
            public WimImageHandle(
            Read                       = 0x000D0000,
            ReadOnly                   = 0x00000001,
            ref compactParams,
            ref NativeMethods.VirtualDiskProgress progress,
            return CreateFixedDisk(
            return CreateSparseDisk(
            return GetAvailableDriveLetters()[0];
            return handleForOverllapped;
            return new ReadOnlyCollection<char>(availableDrives);
            return new VirtualHardDisk(vhdHandle, path, virtualStorageDeviceType);
            return returnCode;
            return status;
            return this.Compact(
            Runs an external executable file, and validates the error level.
            SafeFileHandle Handle,
            SafeFileHandle vhdHandle;
            Scanning = NativeMethods.WimMessage.WIM_MSG_SCANNING,
            set { m_Abort = value; }
            SetPos = NativeMethods.WimMessage.WIM_MSG_SETPOS,
            SetRange = NativeMethods.WimMessage.WIM_MSG_SETRANGE,
            Short function to determine whether the logged-on user is an administrator.
            Split = NativeMethods.WimMessage.WIM_MSG_SPLIT,
            StepIt = NativeMethods.WimMessage.WIM_MSG_STEPIT,
            string ApplyToPath) {
            string file, 
            string path,
            string Path,
            string path,
            string source,
            Success = NativeMethods.WimMessage.WIM_MSG_SUCCESS,
            switch ((ImageEventMessage)MessageId) {
            The default value is 0.  
            The error code that means the executable ran successfully.
            The path that we need to figure stuff out about,
            The path to the executable to run and monitor.
            this.Attach(NativeMethods.AttachVirtualDiskFlags.None);
            this.Dispose(false);
            this.Dispose(true);
            throw "Form session has been cancelled."
            throw "No source path specified."
            throw "The specified ISO does not appear to be valid Windows installation media."
            throw "There is a mismatch between the VHDPath file extension ($($ext.ToUpper())), and the VHDFormat (.$($VHDFormat)).  Please ensure that these match and try again."
            uint   MessageId,
            uint _callback = NativeMethods.WimRegisterMessageCallback(hWim, callback, IntPtr.Zero);
            uint blockSizeInBytes,
            uint ImageIndex) {
            uint MessageId,
            uint readWriteDepth,
            uint returnCode = NativeMethods.CompactVirtualDisk(
            uint returnCode = NativeMethods.CreateVirtualDisk(
            uint returnCode = NativeMethods.GetVirtualDiskOperationProgress(
            uint returnCode = NativeMethods.OpenVirtualDisk(
            uint sectorSizeInBytes) {
            uint status = (uint) NativeMethods.WimMessage.WIM_MSG_SUCCESS;
            ulong size,
            Unknown                    = 0x00000000,
            UserData      = userData;
            Version1                   = 0x00000001
            Version1                   = 0x00000001,
            Version2                   = 0x00000002
            VersionUnspecified         = 0x00000000,
            VHD                        = 0x00000002,
            VHDX                       = 0x00000003
            virtualStorageType.DeviceId = virtualStorageDeviceType;
            virtualStorageType.VendorId = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.Unknown)
            virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorMicrosoft;
            WideParameter = wideParameter;
            WIM_MSG                    = WM_APP + 0x1476,                
            WIM_MSG_ABORT_IMAGE        = 0xFFFFFFFF
            WIM_MSG_ALIGNMENT,
            WIM_MSG_COMPRESS,
            WIM_MSG_ERROR,
            WIM_MSG_PROCESS,
            WIM_MSG_PROGRESS,
            WIM_MSG_RETRY,
            WIM_MSG_SCANNING,
            WIM_MSG_SETPOS,
            WIM_MSG_SETRANGE,
            WIM_MSG_SPLIT,
            WIM_MSG_STEPIT,
            WIM_MSG_SUCCESS            = 0x00000000,                
            WIM_MSG_TEXT,
            WimApplyFlagsFileInfo      = 0x00000080,
            WimApplyFlagsIndex         = 0x00000004,
            WimApplyFlagsMountFast     = 0x00000400,
            WimApplyFlagsMountLegacy   = 0x00000800
            WimApplyFlagsMountReadOnly = 0x00000200,
            WimApplyFlagsNoApply       = 0x00000008,
            WimApplyFlagsNoDirAcl      = 0x00000010,
            WimApplyFlagsNoFileAcl     = 0x00000020,
            WimApplyFlagsNone          = 0x00000000,
            WimApplyFlagsNoRpFix       = 0x00000100,
            WimApplyFlagsReserved      = 0x00000001,
            WimApplyFlagsShareWrite    = 0x00000040,
            WimApplyFlagsVerify        = 0x00000002,
            WimCreatedNew              = 0x00000000,
            WimFile Container,
            WimFileHandle hWim,
            WimGenericRead             = 0x80000000
            WimIgnored                 = 0x00000000
            WimMessageCallback callback) {
            WimMessageCallback registeredCallback) {
            WimOpenedExisting          = 0x00000001
            WimOpenExisting            = 0x00000003,
            WimQuery                   = 0x00000000,
            Writable                   = 0x00320000
            Write-W2VInfo "Copying ISO $(Split-Path $SourcePath -Leaf) to temp folder..."
            Write-W2VWarn "For the VHD file format, the maximum file size is ~2040GB.  We're automatically setting the size to 2040GB for you."
            Write-W2VWarn "Ignoring the WorkingDirectory specification."
            Write-W2VWarn "Specifying -VHDPath and -WorkingDirectory at the same time is contradictory."
            x86   = 0x0,
        "HKLM\$($HiveMountPoint)"
        "HKLM\$mountKey",
        "LOAD",
        "UNLOAD",
        #----------------------------------------------
        # Because we used ShowDialog, we need to manually dispose of the form.
        # before we start the conversion process.
        # Check to see if the path has a root specified.  If it doesn't, use the working directory.
        # Check to see if there's a conflict between the specified file extension and the VHDFormat being used.
        # Check to see if there's a WIM file we can muck about with.
        # Edition
        # Event blocks for the form
        # Figure out VHD size and size unit.
        # If the ISO isn't local, copy it down so we don't have to worry about resource contention
        # Init the OnLoad event to correct the initial state of the form
        # Is this ServerCore?
        # or about network latency.
        # Refresh the DiskImage object so we can get the real information about it.  I assume this is a bug.
        # Return the constructed form.
        # Save the initial state of the form
        # Since we can't do Resolve-Path against a file that doesn't exist, we need to get creative in determining 
        # the full path that the user specified (or meant to specify if they gave us a relative path).
        # This probably won't make much of a difference, but let's free up all of the resources we can
        # VHD Format
        # VHD Size
        # VHD Type
        # VHDPath
        # We need to generate a file name. 
        # What type of SKU are we?
        # Working Directory
        #endregion AsyncHelpers
        #endregion btnBrowseWim
        #endregion btnGo
        #endregion btnUnattendBrowse
        #endregion btnWrkBrowse
        #endregion cmbSkuList
        #endregion cmbVhdFormat
        #endregion cmbVhdSizeUnit
        #endregion cmbVhdType
        #endregion Constants
        #endregion Constructor
        #endregion Delegates and Callbacks
        #endregion Enums and Flags
        #endregion Events
        #endregion Fixed Disks
        #endregion Form Code
        #endregion Form Objects
        #endregion frmMain
        #endregion Gozer the Destructor
        #endregion groupBox1
        #endregion groupBox2
        #endregion groupBox3
        #endregion groupBox4
        #endregion IDisposable Members
        #endregion label1
        #endregion label2
        #endregion label3
        #endregion label4
        #endregion label5
        #endregion label6
        #endregion label7
        #endregion Member Variables
        #endregion numVhdSize
        #endregion Open
        #endregion Other
        #endregion Public Methods
        #endregion Public Properties
        #endregion SafeHandle wrappers for WimFileHandle and WimImageHandle
        #endregion Sparse Disks
        #endregion Static Methods
        #endregion Structs
        #endregion txtSourcePath
        #endregion txtUnattendFile
        #endregion txtVhdName
        #endregion txtWorkingDirectory
        #endregion VDiskInterop
        #endregion VirtDisk.DLL P/Invoke
        #endregion WIMGAPI
        #endregion WIMGAPI P/Invoke
        #endregion Win32 P/Invoke
        #region AsyncHelpers
        #region btnBrowseWim
        #region btnGo
        #region btnUnattendBrowse
        #region btnWrkBrowse
        #region cmbSkuList
        #region cmbVhdFormat
        #region cmbVhdSizeUnit
        #region cmbVhdType
        #region Constants
        #region Constructor
        #region Delegates and Callbacks
        #region Enums and Flags
        #region Events
        #region Fixed Disks
        #region Form Code
        #region Form Objects
        #region frmMain
        #region Gozer the Destructor
        #region groupBox1
        #region groupBox2
        #region groupBox3
        #region groupBox4
        #region IDisposable Members
        #region label1
        #region label2
        #region label3
        #region label4
        #region label5
        #region label6
        #region label7
        #region Member Variables
        #region numVhdSize
        #region Open
        #region Other
        #region Public Methods
        #region Public Properties
        #region SafeHandle wrappers for WimFileHandle and WimImageHandle
        #region Sparse Disks
        #region Static Methods
        #region Structs
        #region txtSourcePath
        #region txtUnattendFile
        #region txtVhdName
        #region txtWorkingDirectory
        #region VDiskInterop
        #region VirtDisk.DLL P/Invoke
        #region WIMGAPI
        #region WIMGAPI P/Invoke
        #region Win32 P/Invoke
        $Arguments,
        $bcdBootArgs = @(
        $BcdStoreFile,
        $bootMgr.Get()
        $btnBrowseWim           = New-Object System.Windows.Forms.Button
        $btnBrowseWim.add_Click($btnBrowseWim_OnClick)
        $btnBrowseWim.DataBindings.DefaultDataSourceUpdateMode = 0
        $btnBrowseWim.Location        = $System_Drawing_Point
        $btnBrowseWim.Name            = "btnBrowseWim"
        $btnBrowseWim.Size            = $System_Drawing_Size
        $btnBrowseWim.TabIndex        = 1
        $btnBrowseWim.Text            = "..."
        $btnBrowseWim.UseVisualStyleBackColor = $True
        $btnBrowseWim_OnClick                   = {
        $btnGo                  = New-Object System.Windows.Forms.Button
        $btnGo.add_Click($btnGo_OnClick)
        $btnGo.DataBindings.DefaultDataSourceUpdateMode = 0
        $btnGo.DialogResult           = "OK"
        $btnGo.Location               = $System_Drawing_Point
        $btnGo.Name                   = "btnGo"
        $btnGo.Size                   = $System_Drawing_Size
        $btnGo.TabIndex               = 0
        $btnGo.Text                   = "&Make my VHD"
        $btnGo.UseVisualStyleBackColor = $True
        $btnGo_OnClick                          = {
        $btnUnattendBrowse      = New-Object System.Windows.Forms.Button
        $btnUnattendBrowse.add_Click($btnUnattendBrowse_OnClick)
        $btnUnattendBrowse.DataBindings.DefaultDataSourceUpdateMode = 0
        $btnUnattendBrowse.Location   = $System_Drawing_Point
        $btnUnattendBrowse.Name       = "btnUnattendBrowse"
        $btnUnattendBrowse.Size       = $System_Drawing_Size
        $btnUnattendBrowse.TabIndex   = 9
        $btnUnattendBrowse.Text       = "..."
        $btnUnattendBrowse.UseVisualStyleBackColor = $True
        $btnUnattendBrowse_OnClick              = {
        $btnWrkBrowse           = New-Object System.Windows.Forms.Button
        $btnWrkBrowse.add_Click($btnWrkBrowse_OnClick)
        $btnWrkBrowse.DataBindings.DefaultDataSourceUpdateMode = 0
        $btnWrkBrowse.Location        = $System_Drawing_Point
        $btnWrkBrowse.Name            = "btnWrkBrowse"
        $btnWrkBrowse.Size            = $System_Drawing_Size
        $btnWrkBrowse.TabIndex        = 9
        $btnWrkBrowse.Text            = "..."
        $btnWrkBrowse.UseVisualStyleBackColor = $True
        $btnWrkBrowse_OnClick                   = {
        $buildLabEx   = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").BuildLabEx
        $cmbSkuList             = New-Object System.Windows.Forms.ComboBox
        $cmbSkuList.DataBindings.DefaultDataSourceUpdateMode = 0
        $cmbSkuList.FormattingEnabled = $True
        $cmbSkuList.Location          = $System_Drawing_Point
        $cmbSkuList.Name              = "cmbSkuList"
        $cmbSkuList.Size              = $System_Drawing_Size
        $cmbSkuList.TabIndex          = 2
        $cmbVhdFormat           = New-Object System.Windows.Forms.ComboBox
        $cmbVhdFormat.DataBindings.DefaultDataSourceUpdateMode = 0
        $cmbVhdFormat.FormattingEnabled = $True
        $cmbVhdFormat.Items.Add("VHD")  | Out-Null
        $cmbVhdFormat.Items.Add("VHDX") | Out-Null
        $cmbVhdFormat.Location        = $System_Drawing_Point
        $cmbVhdFormat.Name            = "cmbVhdFormat"
        $cmbVhdFormat.Size            = $System_Drawing_Size
        $cmbVhdFormat.TabIndex        = 0
        $cmbVhdFormat.Text            = $VHDFormat
        $cmbVhdSizeUnit         = New-Object System.Windows.Forms.ComboBox
        $cmbVhdSizeUnit.DataBindings.DefaultDataSourceUpdateMode = 0
        $cmbVhdSizeUnit.FormattingEnabled = $True
        $cmbVhdSizeUnit.Items.Add("GB") | Out-Null
        $cmbVhdSizeUnit.Items.Add("MB") | Out-Null
        $cmbVhdSizeUnit.Items.Add("TB") | Out-Null
        $cmbVhdSizeUnit.Location      = $System_Drawing_Point
        $cmbVhdSizeUnit.Name          = "cmbVhdSizeUnit"
        $cmbVhdSizeUnit.Size          = $System_Drawing_Size
        $cmbVhdSizeUnit.TabIndex      = 5
        $cmbVhdSizeUnit.Text          = $unit
        $cmbVhdType             = New-Object System.Windows.Forms.ComboBox
        $cmbVhdType.DataBindings.DefaultDataSourceUpdateMode = 0
        $cmbVhdType.FormattingEnabled = $True
        $cmbVhdType.Items.Add("Dynamic") | Out-Null
        $cmbVhdType.Items.Add("Fixed")   | Out-Null
        $cmbVhdType.Location          = $System_Drawing_Point
        $cmbVhdType.Name              = "cmbVhdType"
        $cmbVhdType.Size              = $System_Drawing_Size
        $cmbVhdType.TabIndex          = 2
        $cmbVhdType.Text              = $VHDType
        $DiskSignature,
        $driveInfo = [IO.DriveInfo]((Resolve-Path $Path).Path)
        $driveLetter = ($openIso | Get-Volume).DriveLetter
        $editionId    = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").EditionID
        $Executable,
        $ext = ([IO.FileInfo]$VHDPath).Extension
        $frmMain                = New-Object System.Windows.Forms.Form
        $frmMain.AcceptButton = $btnGo
        $frmMain.add_Load($OnLoadForm_StateCorrection)
        $frmMain.ClientSize           = $System_Drawing_Size
        $frmMain.Controls.Add($groupBox1)
        $frmMain.Controls.Add($groupBox2)
        $frmMain.Controls.Add($groupBox3)
        $frmMain.Controls.Add($groupBox4)
        $frmMain.Controls.Add($label1)
        $frmMain.DataBindings.DefaultDataSourceUpdateMode = 0
        $frmMain.Dispose()
        $frmMain.Font                 = New-Object System.Drawing.Font("Segoe UI",10,0,3,1)
        $frmMain.FormBorderStyle      = 1
        $frmMain.MaximizeBox          = $False
        $frmMain.MinimizeBox          = $False
        $frmMain.Name                 = "frmMain"
        $frmMain.StartPosition        = 1
        $frmMain.Text                 = "Convert-WindowsImage UI"
        $groupBox1              = New-Object System.Windows.Forms.GroupBox
        $groupBox1.Controls.Add($btnBrowseWim)
        $groupBox1.Controls.Add($txtSourcePath)
        $groupBox1.DataBindings.DefaultDataSourceUpdateMode = 0
        $groupBox1.Location           = $System_Drawing_Point
        $groupBox1.Name               = "groupBox1"
        $groupBox1.Size               = $System_Drawing_Size
        $groupBox1.TabIndex           = 4
        $groupBox1.TabStop            = $False
        $groupBox1.Text               = "1. Choose a source"
        $groupBox2              = New-Object System.Windows.Forms.GroupBox
        $groupBox2.Controls.Add($cmbSkuList)
        $groupBox2.DataBindings.DefaultDataSourceUpdateMode = 0
        $groupBox2.Location           = $System_Drawing_Point
        $groupBox2.Name               = "groupBox2"
        $groupBox2.Size               = $System_Drawing_Size
        $groupBox2.TabIndex           = 6
        $groupBox2.TabStop            = $False
        $groupBox2.Text               = "2. Choose a SKU from the list"
        $groupBox3              = New-Object System.Windows.Forms.GroupBox
        $groupBox3.Controls.Add($btnUnattendBrowse)
        $groupBox3.Controls.Add($btnWrkBrowse)
        $groupBox3.Controls.Add($cmbVhdFormat)
        $groupBox3.Controls.Add($cmbVhdSizeUnit)
        $groupBox3.Controls.Add($cmbVhdType)
        $groupBox3.Controls.Add($label2)
        $groupBox3.Controls.Add($label3)
        $groupBox3.Controls.Add($label4)
        $groupBox3.Controls.Add($label5)
        $groupBox3.Controls.Add($label6)
        $groupBox3.Controls.Add($label7)
        $groupBox3.Controls.Add($numVhdSize)
        $groupBox3.Controls.Add($txtUnattendFile)
        $groupBox3.Controls.Add($txtVhdName)
        $groupBox3.Controls.Add($txtWorkingDirectory)
        $groupBox3.DataBindings.DefaultDataSourceUpdateMode = 0
        $groupBox3.Location           = $System_Drawing_Point
        $groupBox3.Name               = "groupBox3"
        $groupBox3.Size               = $System_Drawing_Size
        $groupBox3.TabIndex           = 7
        $groupBox3.TabStop            = $False
        $groupBox3.Text               = "3. Choose configuration options"
        $groupBox4              = New-Object System.Windows.Forms.GroupBox
        $groupBox4.Controls.Add($btnGo)
        $groupBox4.DataBindings.DefaultDataSourceUpdateMode = 0
        $groupBox4.Location           = $System_Drawing_Point
        $groupBox4.Name               = "groupBox4"
        $groupBox4.Size               = $System_Drawing_Size
        $groupBox4.TabIndex           = 8
        $groupBox4.TabStop            = $False
        $groupBox4.Text               = "4. Make the VHD!"
        $Hive
        $hive         = Mount-RegistryHive -Hive (Join-Path $drive "Windows\System32\Config\Software")
        $Hive.Fullname
        $HiveMountPoint
        $InitialFormWindowState       = $frmMain.WindowState
        $InitialFormWindowState = New-Object System.Windows.Forms.FormWindowState
        $installType  = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").InstallationType
        $isoPath = (Resolve-Path $SourcePath).Path
        $label1                 = New-Object System.Windows.Forms.Label
        $label1.DataBindings.DefaultDataSourceUpdateMode = 0
        $label1.Location              = $System_Drawing_Point
        $label1.Name                  = "label1"
        $label1.Size                  = $System_Drawing_Size
        $label1.TabIndex              = 5
        $label1.Text                  = $uiHeader
        $label2                 = New-Object System.Windows.Forms.Label
        $label2.DataBindings.DefaultDataSourceUpdateMode = 0
        $label2.Location              = $System_Drawing_Point
        $label2.Name                  = "label2"
        $label2.Size                  = $System_Drawing_Size
        $label2.TabIndex              = 1
        $label2.Text                  = "VHD Format"
        $label3                 = New-Object System.Windows.Forms.Label
        $label3.DataBindings.DefaultDataSourceUpdateMode = 0
        $label3.Location              = $System_Drawing_Point
        $label3.Name                  = "label3"
        $label3.Size                  = $System_Drawing_Size
        $label3.TabIndex              = 3
        $label3.Text                  = "VHD Type"
        $label4                 = New-Object System.Windows.Forms.Label
        $label4.DataBindings.DefaultDataSourceUpdateMode = 0
        $label4.Location              = $System_Drawing_Point
        $label4.Name                  = "label4"
        $label4.Size                  = $System_Drawing_Size
        $label4.TabIndex              = 6
        $label4.Text                  = "VHD Size"
        $label5                 = New-Object System.Windows.Forms.Label
        $label5.DataBindings.DefaultDataSourceUpdateMode = 0
        $label5.Location              = $System_Drawing_Point
        $label5.Name                  = "label5"
        $label5.Size                  = $System_Drawing_Size
        $label5.TabIndex              = 8
        $label5.Text                  = "Working Directory"
        $label6                 = New-Object System.Windows.Forms.Label
        $label6.DataBindings.DefaultDataSourceUpdateMode = 0
        $label6.Location              = $System_Drawing_Point
        $label6.Name                  = "label6"
        $label6.Size                  = $System_Drawing_Size
        $label6.Text                  = "VHD Name (Optional)"
        $label7                 = New-Object System.Windows.Forms.Label
        $label7.DataBindings.DefaultDataSourceUpdateMode = 0
        $label7.Location              = $System_Drawing_Point
        $label7.Name                  = "label7"
        $label7.Size                  = $System_Drawing_Size
        $label7.Text                  = "Unattend File (Optional)"
        $null = rd $logFolder -Force -Recurse
        $null = Start-Transcript -Path (Join-Path $logFolder "Convert-WindowsImageTranscript.txt") -Force -ErrorAction SilentlyContinue
        $null = Stop-Transcript
        $numVhdSize             = New-Object System.Windows.Forms.NumericUpDown
        $numVhdSize.DataBindings.DefaultDataSourceUpdateMode = 0
        $numVhdSize.Location          = $System_Drawing_Point
        $numVhdSize.Name              = "numVhdSize"
        $numVhdSize.Size              = $System_Drawing_Size
        $numVhdSize.TabIndex          = 4
        $numVhdSize.Value             = $quantity
        $OnLoadForm_StateCorrection = {
        $openFileDialog1        = New-Object System.Windows.Forms.OpenFileDialog
        $openFileDialog1.FileName     = "openFileDialog1"
        $openFileDialog1.ShowHelp     = $True
        $openFolderDialog1      = New-Object System.Windows.Forms.FolderBrowserDialog
        $openIso     = Get-DiskImage -ImagePath $isoPath
        $openIso     = Mount-DiskImage -ImagePath $isoPath -StorageType ISO -PassThru
        $openVhd = [WIM2VHD.VirtualHardDisk]::CreateFixedDisk(
        $openVhd = [WIM2VHD.VirtualHardDisk]::CreateSparseDisk(
        $openVhd.Close()
        $openWim.Close()
        $openWim.Images | %{ Write-W2VError "  $($_.ImageFlags)" }
        $osLoader.Get()
        $PartitionOffset
        $PartitionStyle = $PARTITION_STYLE_MBR,
        $Path
        $quantity = Invoke-Expression -Command "$($SizeBytes) / 1$($unit)"
        $result = $true
        $ret = $frmMain.ShowDialog()
        $SizeBytes        = Invoke-Expression "$($numVhdSize.Value)$($cmbVhdSizeUnit.SelectedItem)"
        $skuFamily    = $null
        $SourcePath  = "$($driveLetter):\sources\install.wim"
        $SourcePath = "$($env:Temp)\$(Split-Path $SourcePath -Leaf)"
        $SuccessfulErrorCode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 10
        $System_Drawing_Point.X       = 176
        $System_Drawing_Point.X       = 23
        $System_Drawing_Point.X       = 25
        $System_Drawing_Point.X       = 340
        $System_Drawing_Point.X       = 39
        $System_Drawing_Point.X       = 409
        $System_Drawing_Point.X       = 449
        $System_Drawing_Point.Y       = 132
        $System_Drawing_Point.Y       = 150
        $System_Drawing_Point.Y       = 169
        $System_Drawing_Point.Y       = 180
        $System_Drawing_Point.Y       = 198
        $System_Drawing_Point.Y       = 199
        $System_Drawing_Point.Y       = 21
        $System_Drawing_Point.Y       = 24
        $System_Drawing_Point.Y       = 243
        $System_Drawing_Point.Y       = 42
        $System_Drawing_Point.Y       = 498
        $System_Drawing_Point.Y       = 76
        $System_Drawing_Point.Y       = 95
        $System_Drawing_Point.Y       = 98
        $System_Drawing_Point.Y       = 99
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 23
        $System_Drawing_Size.Height   = 245
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Height   = 27
        $System_Drawing_Size.Height   = 30
        $System_Drawing_Size.Height   = 33
        $System_Drawing_Size.Height   = 579
        $System_Drawing_Size.Height   = 68
        $System_Drawing_Size.Height   = 69
        $System_Drawing_Size.Height   = 71
        $System_Drawing_Size.Width    = 118
        $System_Drawing_Size.Width    = 136
        $System_Drawing_Size.Width    = 144
        $System_Drawing_Size.Width    = 175
        $System_Drawing_Size.Width    = 264
        $System_Drawing_Size.Width    = 27
        $System_Drawing_Size.Width    = 28
        $System_Drawing_Size.Width    = 415
        $System_Drawing_Size.Width    = 418
        $System_Drawing_Size.Width    = 452
        $System_Drawing_Size.Width    = 464
        $System_Drawing_Size.Width    = 489
        $System_Drawing_Size.Width    = 490
        $System_Drawing_Size.Width    = 512
        $System_Drawing_Size.Width    = 63
        $System_Drawing_Size.Width    = 67
        $System_Drawing_Size.Width    = 86
        $System_Drawing_Size.Width    = 92
        $text
        $transcripting = $false
        $transcripting = $true
        $txtSourcePath          = New-Object System.Windows.Forms.TextBox
        $txtSourcePath.DataBindings.DefaultDataSourceUpdateMode = 0
        $txtSourcePath.Location       = $System_Drawing_Point
        $txtSourcePath.Name           = "txtSourcePath"
        $txtSourcePath.Size           = $System_Drawing_Size
        $txtSourcePath.TabIndex       = 0
        $txtUnattendFile        = New-Object System.Windows.Forms.TextBox
        $txtUnattendFile.DataBindings.DefaultDataSourceUpdateMode = 0
        $txtUnattendFile.Location     = $System_Drawing_Point
        $txtUnattendFile.Name         = "txtUnattendFile"
        $txtUnattendFile.Size         = $System_Drawing_Size
        $txtUnattendFile.TabIndex     = 11
        $txtVhdName             = New-Object System.Windows.Forms.TextBox
        $txtVhdName.DataBindings.DefaultDataSourceUpdateMode = 0
        $txtVhdName.Location          = $System_Drawing_Point
        $txtVhdName.Name              = "txtVhdName"
        $txtVhdName.Size              = $System_Drawing_Size
        $txtVhdName.TabIndex          = 10
        $txtWorkingDirectory    = New-Object System.Windows.Forms.TextBox
        $txtWorkingDirectory.DataBindings.DefaultDataSourceUpdateMode = 0
        $txtWorkingDirectory.Location = $System_Drawing_Point
        $txtWorkingDirectory.Name     = "txtWorkingDirectory"
        $txtWorkingDirectory.Size     = $System_Drawing_Size
        $txtWorkingDirectory.TabIndex = 7
        $txtWorkingDirectory.Text     = $WorkingDirectory
        $UnattendPath = (Resolve-Path $UnattendPath).Path
        $unit = $null
        $vhdFinalName = "$($buildLabEx)_$($skuFamily)_$($editionId)_$($openImage.ImageDefaultLanguage).$($VHDFormat.ToLower())"
        $vhdFinalName = Split-Path $VHDPath -Leaf
        $VHDFormat        = $cmbVhdFormat.SelectedItem
        $VHDPath      = Join-Path $WorkingDirectory "$($sessionKey).$($VHDFormat.ToLower())"
        $VHDPath      = Join-Path (Split-Path $VHDPath -Parent) "$($sessionKey).$($VHDFormat.ToLower())"
        $VHDType          = $cmbVhdType.SelectedItem
        $WorkingDirectory = $txtWorkingDirectory.Text
        )
        );
        .\Convert-WindowsImage.ps1 -SourcePath D:\foo\install.wim -Edition Enterprise -WorkingDirectory D:\foo
        .\Convert-WindowsImage.ps1 -SourcePath D:\foo\Win7SP1.iso -Edition Ultimate -VHDPath D:\foo\Win7_Ultimate_SP1.vhd
        .DESCRIPTION
        .EXAMPLE
        .OUTPUTS
        .PARAMETER Arguments
        .PARAMETER Executable
        .PARAMETER Path
        .PARAMETER SuccessfulErrorCode
        .SYNOPSIS
        /// </param>
        /// </remarks>
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when an invalid size is specified</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when an invalid size or wrong virtual storage device type is specified.</exception>
        /// <exception cref="FileNotFoundException">Thrown if the VHD at path is not found.</exception>
        /// <exception cref="FileNotFoundException">Thrown when source VHD is not found.</exception>
        /// <exception cref="SecurityException">Thrown when an error occurred while creating the default security descriptor.</exception>
        /// <exception cref="SecurityException">Thrown when there was an error while creating the default security descriptor.</exception>
        /// <exception cref="Win32Exception">Thrown if an error occurred while opening the VHD.</exception>
        /// <exception cref="Win32Exception">Thrown when an error occurred while attaching the VHD.</exception>
        /// <exception cref="Win32Exception">Thrown when an error occurred while creating the VHD.</exception>
        /// <exception cref="Win32Exception">Thrown when an error occurred while mirroring the VHD.</exception>
        /// <param name="accessMask">Contains the bit mask for specifying access rights to a virtual hard disk (VHD).  Default is All.</param>
        /// <param name="attachVirtualDiskFlags">
        /// <param name="bInitialState"></param>
        /// <param name="blockSizeInBytes">Block size for the VHD.</param>
        /// <param name="bManualReset"></param>
        /// <param name="disposing"></param>
        /// <param name="flags">An OpenVirtualDiskFlags object to modify the way the Virtual Hard Disk is opened.  Default is Unknown.</param>
        /// <param name="flags">Flags for Compact operation</param>
        /// <param name="ImageIndex">The 1-based index of the image to retrieve.</param>
        /// <param name="ImageName"></param>
        /// <param name="lpEventAttributes"></param>
        /// <param name="lpName"></param>
        /// <param name="Overlapped"></param>
        /// <param name="overlapped"></param>
        /// <param name="overlapped">If not null, the operation runs in async mode</param>
        /// <param name="overwrite">If the VHD exists, setting this parameter to 'True' will delete it and create a new one.</param>
        /// <param name="overwrite">Overwrite the VHD if it already exists.</param>
        /// <param name="path">The path and name of the VHD to create.</param>
        /// <param name="path">The path and name of the Virtual Hard Disk file to open.</param>
        /// <param name="path">The path of the disk to create.</param>
        /// <param name="progress"></param>
        /// <param name="Progress"></param>
        /// <param name="readWriteDepth">Indicates the number of stores, beginning with the child, of the backing store chain to open as read/write. 
        /// <param name="sectorSizeInBytes">Sector size for the VHD.</param>
        /// <param name="size">The maximum size of the disk to create.</param>
        /// <param name="size">The size of the VHD to create in bytes.  
        /// <param name="source">Optional path to pre-populate the new virtual disk object with block data from an existing disk
        /// <param name="VirtualDiskHandle"></param>
        /// <param name="virtualStorageDeviceType">The type of disk to create, VHD or VHDX.</param>
        /// <param name="virtualStorageDeviceType">VHD format version (VHD1 or VHD2)</param>
        /// <param name="virtualStorageDeviceType">VHD Format Version (VHD1 or VHD2)</param>
        /// <param name="virtualStorageDeviceType">Virtual storage device type: VHD1 or VHD2.</param>
        /// <param name="wimPath">Path to the WIM container.</param>
        /// <remarks>
        /// <remarks>Creating a fixed disk can be a time consuming process!</remarks>  
        /// <remarks>Drives A and B are not included in the collection, even if they are available.</remarks>
        /// <remarks>Drives A and B will not be returned, even if they are available.</remarks>
        /// <returns></returns>
        /// <returns>A collection of drive letters that are currently available on the system.</returns>
        /// <returns>Char representing the first available drive letter.</returns>
        /// <returns>Returns a SafeFileHandle corresponding to the virtual hard disk that was created.</returns>
        /// <returns>Returns the GCHandle for the pinned overlapped structure</returns>
        /// <returns>Virtual Hard Disk object</returns>
        /// <returns>VirtualHardDisk object</returns>
        /// <returns>WinImage object.</returns>
        /// <summary>
        /// A combination of values from the attachVirtualDiskFlags enumeration which will dictate how the behavior of the VHD once mounted.
        /// Abbreviated signature of CreateFixedDisk so it's easier to use from WIM2VHD.
        /// Abbreviated signature of CreateSparseDisk so it's easier to use from WIM2VHD.
        /// Attaches a virtual hard disk (VHD) by locating an appropriate VHD provider to accomplish the attachment.
        /// Closes all open handles to the Virtual Hard Disk object.
        /// Closes the WIM file.
        /// Constructor.
        /// Contains the bit mask for specifying access rights to a virtual hard disk (VHD).
        /// Contains the type and provider (vendor) of the virtual storage device.
        /// Contains the version of the virtual hard disk (VHD) ATTACH_VIRTUAL_DISK_PARAMETERS structure to use in calls to VHD functions.
        /// Contains virtual disk attach request flags.
        /// Contains virtual hard disk (VHD) creation flags.
        /// Contains virtual hard disk (VHD) open request flags.
        /// CreateEvent API is used while calling async Online Mirror API
        /// Creates a fixed-size Virtual Hard Disk. Supports both sync and async modes. This methods always calls the V2 version of the 
        /// Creates a NativeOverlapped object, initializes its EventHandle property, and pins the object to the memory.
        /// Creates a new sparse (dynamically expanding) virtual hard disk (.vhd). Supports both sync and async modes.
        /// CreateVirtualDisk API, and creates VHD2. 
        /// DefaultImageEvent handler
        /// Destroys a VHD object.
        /// Disposal method for Virtual Hard Disk objects.
        /// Gets the first available drive letter on the current system.
        /// GetVirtualDiskOperationProgress API allows getting progress info for the async virtual disk operations (ie. Online Mirror)
        /// If it is not attached, NULL will be returned.
        /// If the VHD is currently attached, and the PermanentLifetime was not specified, this operation will detach it.
        /// If the virtual hard disk is not currently attached, -1 will be returned.
        /// If you want to go more than one disk deep into the parent chain, provide a different value.
        /// Indexer for WIM images inside the WIM container, indexed by the image name.
        /// Indexer for WIM images inside the WIM container, indexed by the image number.
        /// Indicates the index of the disk when attached.
        /// Indicates the version of the virtual disk to create.
        /// Indicates whether the current Virtual Hard Disk is attached to the system.
        /// Opens a virtual hard disk (VHD) using the V2 of OpenVirtualDisk Win32 API for use, allowing you to explicitly specify OpenVirtualDiskFlags, 
        /// Provides a list of names of the images in the specified WIM container file.
        /// Provides a list of WimImage objects, representing the images in the WIM container file.
        /// Read/Write depth, and Access Mask information.
        /// Reduces the size of the virtual hard disk (VHD) backing store file. Supports both sync and async modes.
        /// Retrieves a collection of drive letters that are currently available on the system.
        /// Retrieves the path to the physical device object that contains a virtual hard disk (VHD), if the VHD is attached.
        /// Returns an XDocument representation of the XML metadata for the WIM container and associated images.
        /// Returns the number of images in the WIM container.
        /// Some images have their name stored in the Name field, some in the Flags field, and some in the EditionID field.
        /// Specifies how the file is to be treated and what features are to be used.
        /// The default depth in a VHD parent chain that this library will search through.
        /// The list of Images is 0-based, but the WIM container is 1-based, so we automatically compensate for that.
        /// The maximum size of a dynamic VHD is 2,040 GB.  The minimum size is 3 MB.</param>
        /// The remaining stores in the differencing chain will be opened read-only. This is necessary for merge operations to succeed.  Default is 0x1.</param>
        /// The SafeFileHandle object for the opened VHD.
        /// The VHD image file is pre-allocated on the backing store for the maximum size requested.
        /// The VHD image file uses only as much space on the backing store as needed to store the actual data the VHD currently contains. 
        /// therefore it is possible to successfully create a dynamic VHD with a maximum size larger than the available physical disk free space.
        /// This method attaches the VHD with no flags.
        /// This overlapped objects are useful when executing VHD meta-ops in async mode.
        /// This path may refer to a VHD or a physical disk.  Use NULL if you don't want a source.</param>
        /// this[1] returns the 0th image in the WIM container.
        /// Unsurfaces (detaches) a virtual hard disk (VHD) by locating an appropriate VHD provider to accomplish the operation.
        /// We take all of those into account in while searching the WIM.
        /// When creating this type of VHD, the VHD API does not test for free space on the physical backing store based on the maximum size requested, 
        /// WIMs created by different processes sometimes contain different information - including the name.
        ///</returns>
        ///</summary>
        ///<param name="file">Fully qualified path and file name. For example: c:\file.sys.</param>
        ///<param name="lParam">Specifies additional message information. The contents of this parameter depend on the value of the
        ///<param name="MessageId">Specifies the message being sent.</param>
        ///<param name="skipFileFlag">Default is false - skip file and continue.
        ///<param name="UserData">Specifies the user-defined value passed to RegisterCallback.</param>
        ///<param name="wParam">Specifies additional message information. The contents of this parameter depend on the value of the
        ///<returns>
        ///<summary>
        ///abort the entire image capture.
        ///Alert the caller that an error has occurred while capturing or applying an image.
        ///Default constructor.
        ///Default is false - skip file and continue. Setting to true will
        ///Enable the caller to prevent a file resource from being compressed during a capture.
        ///Event callback to the Wimgapi events
        ///Flag to indicate if the entire image capture should be aborted.
        ///Fully qualified path and file name.
        ///Indicate an update in the progress of an image application.
        ///Indicate that a file has been either captured or applied.
        ///Indicate the number of files that have been captured or applied.
        ///Indicate the number of files that will be captured or applied.
        ///lParam
        ///MessageId parameter.</param>
        ///ProcessFileEvent handler
        ///Set to true to abort the entire image capture.</param>
        ///Skip file from being imaged.
        ///To cancel an image apply or capture, return WIM_MSG_ABORT_IMAGE when handling the WIM_MSG_PROCESS message.
        ///To indicate success and to enable other subscribers to process the message return WIM_MSG_SUCCESS.
        ///To prevent other subscribers from receiving the message, return WIM_MSG_DONE.
        ///UserData
        ///User-defined function used with the RegisterMessageCallback or UnregisterMessageCallback function.
        ///wParam
        [DllImport("advapi32", SetLastError = true)]
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMApplyImage")]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMCloseHandle")]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMCreateFile")]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMGetImageCount")]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMGetImageInformation")]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMLoadImage")]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMRegisterMessageCallback", CallingConvention = CallingConvention.StdCall)]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMSetTemporaryPath")]
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMUnregisterMessageCallback", CallingConvention = CallingConvention.StdCall)]
        [Flags]
        [FlagsAttribute]
        [int]
        [Parameter()]
        [Parameter(Mandatory = $true)]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        [Parameter(Mandatory=$true)]
        [Parameter(ValueFromPipeLine = $true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        [string[]]
        [string]
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        [System.IO.FileInfo]
        [UInt64]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ $_ -ge 0 })]
        [ValidateScript({ $_.Exists })]
        [ValidateScript({ ($_ -eq $PARTITION_STYLE_MBR) -or ($_ -eq $PARTITION_STYLE_GPT) })]
        \sources\install.wim.  If that file is found, it will be used to create a 
        {
        }
        } else {
        } elseif ($installType.ToUpper().Contains("CLIENT")) {
        ~VirtualHardDisk() {
        <build>.<revision>.<architecture>.<branch>.<timestamp>_<skufamily>_<sku>_<language>.<extension>
        8250.0.amd64chk.winmain_win8beta.120217-1520_client_enterprise_en-us.vhd(x)
        Add-Type -AssemblyName System.Drawing,System.Windows.Forms
        and documentation.
        and will be named automatically.
        APIs, which in turn depend on Hyper-V.  In order to prevent Convert-WindowsImage
        Apply(
        Apply-BcdStoreChanges                     `
        Architectures : uint {
        are provided. It is not supported or endorsed by Microsoft Corporation and 
        -ArgumentList $Arguments   `
        Attach(
        Attach() {
        AttachVirtualDisk(
        Branch    = private
        Build     = 8319
        By default, the version of BCDBOOT.EXE that is present in \Windows\System32
        Close() {
        Compact(
        Compact(IntPtr overlapped) {
        CompactVirtualDisk(
        Convert-WindowsImage and the associated documentation are provided "AS-IS". 
        Copy-Item -Path $SourcePath -Destination $env:Temp -Force
        Copy-Item -Path $UnattendPath -Destination (Join-Path $drive "unattend.xml") -Force
        Create the VHD using the VirtDisk Win32 API.
        CreateEvent(
        CreateFixedDisk(
        CreatePinnedOverlappedObject() {
        Creates a bootable VHD(X) based on Windows 7 or Windows 8 installation media.
        CreateSparseDisk(
        CreateVirtualDisk(
        DefaultImageEventArgs(
        Detach() {
        DetachVirtualDisk(
        DiskIndex {
        Dismount-DiskImage $ISOPath
        Dismount-RegistryHive -HiveMountPoint $hive
        Dismount-RegistryHive -HiveMountPoint $mountedHive
        Dispose(
        Dispose() {
        dynamically-expanding 40GB VHD containing the Ultimate SKU, and will be 
        enum
        -FilePath $Executable      `
        FilePath {
        Flavor    = amd64fre
        For dynamic disks, this will be the maximum size that the VHD(X) can grow to.
        For fixed disks, the VHD(X) file will be allocated all of this space immediately.
        from being dependent on Hyper-V (and thus, x64 systems only), we're using the 
        GetAvailableDriveLetters() {
        GetFirstAvailableDriveLetter() {
        GetVirtualDiskOperationProgress(
        GetVirtualDiskPhysicalPath(
        Handle {
        https://www.microsoft.com/opensource/licenses.mspx#Ms-PL
        i.e.:
        if (!($ext -ilike ".$($VHDFormat)")) {
        if (!($ret -ilike "OK")) {
        if (!(Test-Path $SourcePath)) {
        if (![IO.Path]::IsPathRooted($VHDPath)){
        if (![string]::IsNullOrEmpty($cmbSkuList.SelectedItem)) {
        if (![string]::IsNullOrEmpty($txtVhdName.Text)) {
        if ($driveInfo.DriveType -eq "Network") {
        if ($image.ImageFlags.Contains($SupportedEdition) -eq $true)
        if ($installType.ToUpper().Contains("CORE")) {
        if ($installType.ToUpper().Contains("SERVER")) {
        if ($SizeBytes -gt $vhdMaxSize) {
        if ($WorkingDirectory -ne $pwd) {
        if ([string]::IsNullOrEmpty($SourcePath)) {
        if (Test-IsNetworkLocation $SourcePath) {
        If specified along with -VHDPath, the -WorkingDirectory value is ignored.
        if specified by the -WorkingDirectory parameter, the working directory) and will automatically 
        ImageArchitecture {
        ImageCount {
        ImageDefaultLanguage {
        ImageDescription {
        ImageDisplayDescription {
        ImageDisplayName {
        ImageEditionId {
        ImageEventMessage : uint {
        ImageEventMessagePump(
        ImageFlags {
        ImageIndex {
        ImageInstallationType {
        ImageName {
        ImageNames {
        ImageProductType {
        Images {
        ImageSize {
        ImageVersion {
        Installing those cmdlets isn't a big deal, but they depend on the Hyper-V WMI
        internal const uint  ERROR_BAD_COMMAND                    = 0x00000016;
        internal const uint  ERROR_ERROR_DEV_NOT_EXIST            = 0x00000037;
        internal const uint  ERROR_INSUFFICIENT_BUFFER            = 0x0000007A;
        internal const uint  ERROR_IO_PENDING                     = 0x000003E5;
        internal const uint  ERROR_NOT_FOUND                      = 0x00000490;
        internal const uint  ERROR_SUCCESS                        = 0x00000000;
        internal const uint  ERROR_VIRTDISK_NOT_VIRTUAL_DISK      = 0xC03A0015;
        internal enum
        internal enum 
        internal List<WimImage> m_imageList;
        internal static extern bool
        internal static extern IntPtr
        internal static extern uint
        internal static Guid VirtualStorageTypeVendorMicrosoft    = new Guid("EC984AEC-A0F9-47e9-901F-71415A66345B");
        internal static Guid VirtualStorageTypeVendorUnknown      = new Guid("00000000-0000-0000-0000-000000000000");
        internal uint
        internal XDocument
        internal XDocument m_xmlInfo;
        is used by Convert-WindowsImage.  If you need to specify an alternate version,
        IsAttached {
        LASTEDIT:  02 MAR 2012 11:18:00 AM
        Major     = 6
        Microsoft Permissive License - https://www.microsoft.com/opensource/licenses.mspx#Ms-PL
        Minor     = 2
        name the file in the following format:
        NAME:      Create-WindowsImage.ps1
        named D:\foo\Win7_Ultimate_SP1.vhd
        New-VHD depends on the Hyper-V Cmdlets, which aren't installed by default.
        Omitting this parameter will create the Virtual Hard Disk is the current directory, (or,
        Open(
        OpenVirtualDisk(
        OpenVirtualDiskParameters {
        -Passthru
        PhysicalPath {
        Please visit <INSERT_NEW_URL /> for licensing information 
        private
        private        
        private bool m_Abort;
        private bool m_isDisposed;
        private IntPtr m_SkipFileFlag;
        private NativeMethods.VirtualStorageDeviceType m_deviceType = NativeMethods.VirtualStorageDeviceType.Unknown;
        private SafeFileHandle m_virtualHardDiskHandle = null;
        private static NativeMethods.WimMessageCallback wimMessageCallback;
        private string m_filePath = null;
        private string m_FilePath;
        private VirtualHardDisk(
        ProcessFileEventArgs(
        public
        public   const short FILE_ATTRIBUTE_NORMAL                = 0x00000080;
        public   const short INVALID_HANDLE_VALUE                 = -1;
        public   const uint  CREATE_ALWAYS                        = 0x00000002;
        public   const uint  CREATE_NEW                           = 0x00000001;
        public   const uint  DEFAULT_BLOCK_SIZE                   = 0x00080000;
        public   const uint  DISK_SECTOR_SIZE                     = 0x00000200;
        public   const uint  GENERIC_READ                         = 0x80000000;
        public   const uint  GENERIC_WRITE                        = 0x40000000;
        public   const uint  OPEN_EXISTING                        = 0x00000003;
        public   const uint  OPEN_VIRTUAL_DISK_RW_DEFAULT_DEPTH   = 0x00000001;
        public   const uint  WIM_FLAG_INDEX                       = 0x00000004;
        public   const uint  WIM_FLAG_VERIFY                      = 0x00000002;
        public   const uint  WM_APP                               = 0x00008000;
        public Architectures
        public bool
        public bool Abort {
        public delegate uint
        public delegate void DefaultImageEventHandler(object sender, DefaultImageEventArgs e);
        public delegate void ProcessFileEventHandler(object sender, ProcessFileEventArgs e);
        public enum
        public enum AttachVirtualDiskFlags {
        public enum AttachVirtualDiskVersion : int {
        public enum CompactVirtualDiskFlags {
        public enum CompactVirtualDiskVersion : int {
        public enum CreateVirtualDiskFlags {
        public enum CreateVirtualDiskVersion : int {
        public enum DetachVirtualDiskFlag {
        public enum OpenVirtualDiskFlags {
        public enum OpenVirtualDiskVersion : int {
        public enum VirtualDiskAccessMask {
        public enum VirtualStorageDeviceType : int {
        public enum WimMessage : uint {
        public event DefaultImageEventHandler ErrorEvent;
        public event DefaultImageEventHandler ProgressEvent;
        public event DefaultImageEventHandler SetPosEvent;
        public event DefaultImageEventHandler SetRangeEvent;
        public event DefaultImageEventHandler StepItEvent;
        public event ProcessFileEventHandler ProcessFileEvent;
        public int
        public IntPtr LeftParameter {
        public IntPtr UserData {
        public IntPtr WideParameter {
        public List<string>
        public List<WimImage>
        public NativeMethods.WimFileHandle Handle {
        public NativeMethods.WimImageHandle
        public SafeFileHandle
        public sealed class WimFileHandle : SafeHandle {
        public sealed class WimImageHandle : SafeHandle {
        public static char
        public static extern bool InitializeSecurityDescriptor(
        public static extern uint
        public static GCHandle
        public static ReadOnlyCollection<Char>
        public static VirtualHardDisk
        public static void
        public static void 
        public string
        public string 
        public struct
        public struct AttachVirtualDiskParameters {
        public struct CompactVirtualDiskParameters {
        public struct CreateVirtualDiskParameters {
        public struct SecurityDescriptor {
        public struct VirtualDiskProgress {
        public struct VirtualStorageType {
        public uint
        public ulong
        public Version
        public void
        public WimImage
        QFE       = 0
        -RedirectStandardError  "$($env:temp)\$($scriptName)\$($sessionKey)\$($Executable)-StandardError.txt"  `
        -RedirectStandardOutput "$($env:temp)\$($scriptName)\$($sessionKey)\$($Executable)-StandardOutput.txt" `
        RegisterMessageCallback(
        Remove-Item -Path $vhdFinalPath -Force
        returned on the pipeline.
        Run-Executable -Executable $BCDBoot -Arguments $bcdBootArgs
        Run-Executable -Executable $regPath -Arguments $regArgs
        should be used at your own risk.
        SkipFile() {
        So, why not use the New-VHD cmdlet here?
        Specifies that the full path to the VHD(X) that is created should be
        Specifies that the Graphical User Interface should be displayed.
        Specifies the directory where the VHD(X) file should be generated.  
        Specifies whether to create a fixed (fully allocated) VHD(X) or a dynamic (sparse) VHD(X).
        Specifies whether to create a VHD or VHDX formatted Virtual Hard Disk.
        switch ([Math]::Round($SizeBytes.ToString().Length / 3)) {
        System.IO.FileInfo
        The complete path to an unattend.xml file that can be injected into the VHD(X).
        The complete path to the WIM or ISO file that will be converted to a Virtual Hard Disk.
        The default is dynamic.
        The default is VHD.
        The default value is 40GB.
        The default value is the current directory ($pwd).
        The ISO file must be valid Windows installation media to be recognized successfully.
        The name and path of the Virtual Hard Disk to create.
        The name or image index of the image to apply from the WIM.
        The size of the Virtual Hard Disk to create.
        The VHD will be based on the Enterprise edition from D:\foo\install.wim,
        This command will create a 40GB dynamically expanding VHD in the D:\foo folder.
        This command will parse the ISO file D:\foo\Win7SP1.iso and try to locate
        This script is released under the Microsoft Public License (Ms-PL).
        this[int ImageIndex] {
        this[string ImageName] {
        throw
        throw "$Executable failed with code $($ret.ExitCode)!"
        throw "Could not get the BootMgr object from the VHD's BCDStore."
        throw "Could not get the OS Loader..."
        throw "Could not set Qualified Partition Device Element in the OS Loader Application."
        throw "Could not set Qualified Partition Device Element in the OS Loader Device."
        throw "Images can only be applied by an administrator.  Please launch PowerShell elevated and run this script again."
        throw "The registry path already exists.  I should just regenerate it, but I'm lazy."
        throw "Unable to set Qualified Partition Device Element in VHD's BCDStore."
        throw "Windows 10 or higher is required."
        throw new-object ArgumentOutOfRangeException("Edition", "Enterprise edition does not exist in the specified WIM file.");
        Timestamp = 120312-0902
        uint
        UnregisterMessageCallback(
        use this parameter to do so.
        VirtDisk APIs directly.
        VirtualHardDiskHandle {
        -Wait                      `
        WimActionFlags 
        WimApplyFlags
        WimApplyImage(
        WimCloseHandle(
        WimCompressionType 
        WimCreateFile(
        WimCreateFileDesiredAccess 
        WimCreationDisposition 
        WimCreationResult 
        WimFile(string wimPath) {
        WimGetImageCount(
        WimGetImageInformation(
        WimImage(
        WimLoadImage(
        WimMessageCallback(
        WimRegisterMessageCallback(
        WimSetTemporaryPath(
        WimUnregisterMessageCallback(
        -WindowStyle Hidden        `
        Write-W2VError "The specified edition does not appear to exist in the specified WIM."
        Write-W2VError "Valid edition names are:"
        Write-W2VError "You must specify an Edition or SKU index, since the WIM has more than one image."
        Write-W2VInfo "Applying unattend file ($(Split-Path $UnattendPath -Leaf))..."
        Write-W2VInfo "Closing $VHDFormat..."
        Write-W2VInfo "Closing ISO..."
        Write-W2VInfo "Closing registry hive..."
        Write-W2VInfo "Closing Windows image..."
        Write-W2VInfo "Copying WIM $(Split-Path $SourcePath -Leaf) to temp folder..."
        Write-W2VInfo "Creating fixed disk..."
        Write-W2VInfo "Creating sparse disk..."
        Write-W2VInfo "Deleting pre-existing $VHDFormat : $(Split-Path $vhdFinalPath -Leaf)..."
        Write-W2VInfo "Drive is bootable.  Cleaning up..."
        Write-W2VInfo "Generating name for $($VHDFormat)..."
        Write-W2VInfo "Image applied.  Making image bootable..."
        Write-W2VInfo "Launching UI..."
        Write-W2VInfo "Looking for $($SourcePath)..."
        Write-W2VInfo "Not making VHD bootable, since WOA can't boot in VMs."
        Write-W2VInfo "Opening ISO $(Split-Path $isoPath -Leaf)..."
        Write-W2VTrace "$VHDFormat final name is : $vhdFinalName"
        Write-W2VWarn "Transcription is already running.  No Convert-WindowsImage-specific transcript will be created."
        XmlInfo {
        You bear the risk of using it. No express warranties, guarantees or conditions
      #
    # Attach the VHD.
    # Check if -VHDPath and -WorkingDirectory were both specified.
    # Check to make sure that the image we're applying is Windows 7 or greater.
    # Check to make sure we're running as Admin.
    # Check to see if the WIM is local, or on a network location.  If the latter, copy it locally.
    # Close out the transcript and tell the user we're done.
    # Create a temporary name for the VHD(x).  We'll name it properly at the end of the script.
    # Create log folder
    # Hardcode edition to enterprise SKU (this is the only SKU that is supported)
    # If we still have a registry hive mounted, dismount it.
    # If we still have a VHD(X) open, close it.
    # If we still have a WIM image open, close it.
    # If we still have an ISO open, close it.
    # If we're using an ISO, mount it and get the path to the WIM file.
    # Resolve the path for the unattend file.
    # Set a global variable containing the name of the mounted registry key
    # so we can unmount it if there's an error.
    # There's a difference between the maximum sizes for VHDs and VHDXs.  Make sure we follow it.
    # Try to start transcripting.  If it's already running, we'll get an exception and swallow it.
    # We're good.  Open the WIM container.
    #########  Set Constants #########
    ##################################
    #>
    #endregion VHD Interop
    #endregion WIM Interop
    #region VHD Interop
    #region WIM Interop
    $APPLICATION_DEVICE_TYPE = 0x11000001
    $BCDBoot          = "bcdboot.exe",
    $bootMgr = New-Object Management.ManagementObject -ArgumentList $scope, $path, $options
    $BOOTMGR_ID              = "{9DEA862C-5CDD-4E70-ACC1-F32B344D4795}"
    $conn    = New-Object Management.ConnectionOptions
    $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
    $DEFAULT_TYPE            = 0x23000003
    $defaultBootEntryId = ($bootMgr.GetElement($DEFAULT_TYPE)).Element.Id
    $disk      = Get-Disk -Number $openVhd.DiskIndex
    $drive     = $(Get-Partition -Disk $disk).AccessPaths[0]
    $Edition = "null"
    $Edition,
    $global:mountedHive = $mountKey
    $global:mountedHive = $null
    $isAdmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
    $mkWasHere | Out-File -FilePath (Join-Path $drive "Convert-WindowsImageInfo.txt") -Encoding Unicode -Force
    $mountKey = [System.Guid]::NewGuid().ToString()
    $null = md $logFolder -Force
    $openImage = $openWim[$Edition]
    $openImage.Apply($drive)
    $openVhd = $null
    $openVhd.Attach()
    $openVhd.Close()
    $openWim     = New-Object WIM2VHD.WimFile $SourcePath
    $options = New-Object Management.ObjectGetOptions
    $OS_DEVICE_TYPE          = 0x21000001
    $osLoader= New-Object Management.ManagementObject -ArgumentList $scope, $path, $options
    $partition | Add-PartitionAccessPath -AssignDriveLetter
    $partition = New-Partition -DiskNumber $openVhd.DiskIndex -Size $disk.LargestFreeExtent -MbrType IFS -IsActive
    $Passthru,
    $path    = New-Object Management.ManagementPath `
    $regArgs = (
    $regPath  = "REG.EXE"
    $regPath = "REG.EXE"
    $result = $false
    $ret = $bootMgr.SetQualifiedPartitionDeviceElement($APPLICATION_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
    $ret = $osLoader.SetQualifiedPartitionDeviceElement($APPLICATION_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
    $ret = $osLoader.SetQualifiedPartitionDeviceElement($OS_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
    $ret = Start-Process           `
    $scope   = New-Object Management.ManagementScope -ArgumentList "\\.\ROOT\WMI", $conn
    $scope.Connect()
    $ShowUI
    $SizeBytes        = 40GB,
    $SourcePath  = (Resolve-Path $SourcePath).Path
    $SourcePath,
    $SupportedEdition = "Enterprise"
    $UnattendPath,
    $vhdFinalPath = Join-Path (Split-Path $VHDPath -Parent) $vhdFinalName
    $VHDFormat        = "VHD",
    $VHDPath,
    $VHDType          = "Dynamic",
    $volume    = Format-Volume -Partition $partition -FileSystem NTFS -Force -Confirm:$false
    $WorkingDirectory = $pwd,
    )
    .DESCRIPTION
    .EXAMPLE
    .LINK
    .NOTES 
    .OUTPUTS
    .PARAMETER BCDBoot
    .PARAMETER Edition
    .PARAMETER Passthru
    .PARAMETER ShowUI
    .PARAMETER SizeBytes
    .PARAMETER SourcePath
    .PARAMETER UnattendPath
    .PARAMETER VHDFormat
    .PARAMETER VHDPath
    .PARAMETER VHDType
    .PARAMETER WorkingDirectory
    .SYNOPSIS
    // Based on code written by the Hyper-V Test team.
    /// </summary>
    /// <summary>
    /// P/Invoke methods and associated enums, flags, and structs.
    /// The Virtual Hard Disk class provides methods for creating and manipulating Virtual Hard Disk files.
    ///</summary>
    ///<summary>
    ///Describes the file that is being processed for the ProcessFileEvent.
    [Alias("DiskType")]
    [Alias("Format")]
    [Alias("Size")]
    [Alias("SKU")]
    [Alias("Unattend")]
    [Alias("VHD")]
    [Alias("WIM")]
    [Alias("WorkDir")]
    [CmdletBinding()]
    [Parameter(ParameterSetName="SRC")]
    [Parameter(ParameterSetName="SRC", Mandatory=$true, ValueFromPipeline=$true)]
    [Parameter(ParameterSetName="UI")]
    [string]
    [switch]
    [UInt64]
    [ValidateNotNullOrEmpty()]
    [ValidateRange(512MB, 64TB)]
    [ValidateScript({ Test-Path $(Resolve-Path $_) })]
    [ValidateScript({ Test-Path $_ })]
    [ValidateSet("Dynamic", "Fixed")]
    [ValidateSet("VHD", "VHDX")]
    {
    }
    } 
    } catch {
    } else {
    <#
    Add-Type -TypeDefinition $code -ReferencedAssemblies "System.Xml","System.Linq","System.Xml.Linq"
    Consider this a TODO for future versions.
    ConvertFrom-StringData -StringData @"
    DefaultImageEventArgs : EventArgs {
    do things ourselves if we can, instead of using yet another binary. 
    foreach ($image in $openWim.Images)
    Functions to mount and dismount registry hives.
    if (!$ret.ReturnValue) {
    if (!(Test-Admin)) {
    if (![string]::IsNullOrEmpty($UnattendPath)) {
    if ("VHD" -ilike $VHDFormat) {
    if ($Edition -eq "null") {
    if ($Flavor -inotlike "woa*") {
    if ($mountedHive -ne $null) {
    if ($null -eq $openImage) {
    if ($openImage.ImageVersion -lt $lowestSupportedVersion) {
    if ($openIso -ne $null) {
    if ($openVhd -ne $null) {
    if ($openWim -ne $null) {
    if ($ret.ExitCode -ne $SuccessfulErrorCode) {
    if ($ShowUI) { 
    if ($transcripting) {
    if ($VHDPath) {
    if ($VHDType -eq "Dynamic") {
    if ((![String]::IsNullOrEmpty($VHDPath)) -and (![String]::IsNullOrEmpty($WorkingDirectory))) {
    if (([IO.FileInfo]$SourcePath).Extension -ilike ".ISO") { 
    if ([bool]([URI]$Path).IsUNC) {
    if ([String]::IsNullOrEmpty($vhdFinalName)) {
    if ([String]::IsNullOrEmpty($VHDPath)) {
    if (Test-IsNetworkLocation $SourcePath) {
    if (Test-Path $logFolder) {
    if (Test-Path $vhdFinalPath) {
    if (Test-Path HKLM:\$mountKey) {
    Initialize-Disk -Number $openVhd.DiskIndex -PartitionStyle MBR
    It should be noted that I have more confidence in using the RegLoadKey and
    NativeMethods {
    param(
    param()
    ProcessFileEventArgs : EventArgs {
    public class
    public class WimFile {
    RegUnloadKey Win32 APIs than I do using REG.EXE - it just seems like we should
    Rename-Item -Path (Resolve-Path $VHDPath).Path -NewName $vhdFinalName -Force
    return $isAdmin
    return $mountKey
    return $result
    return (Get-ChildItem -Path $vhdFinalPath)
    Run-Executable -Executable $regPath -Arguments $regArgs
    These hives will automatically be accessible via the HKLM:\ registry PSDrive.
    throw
    try {
    VirtualHardDisk : IDisposable {
    WimImage {
    Write-Verbose "ERROR  : $($text)"
    Write-Verbose "INFO   : $($text)"
    Write-Verbose "WARN   : $($text)"
    Write-Verbose $text
    Write-W2VError $_
    Write-W2VInfo "Access path ($drive) has been assigned..."
    Write-W2VInfo "Applying image to $VHDFormat.  This could take a while..."
    Write-W2VInfo "Attaching $VHDFormat..."
    Write-W2VInfo "BCD configuration complete. Moving on..."
    Write-W2VInfo "Closing $VHDFormat..."
    Write-W2VInfo "Disk initialized..."
    Write-W2VInfo "Disk partitioned..."
    Write-W2VInfo "Done."
    Write-W2VInfo "Image $($openImage.ImageIndex) selected ($($openImage.ImageFlags))..."
    Write-W2VInfo "Log folder is $logFolder"
    Write-W2VInfo "Opening $($BcdStoreFile) for configuration..."
    Write-W2VInfo "Signing disk..."
    Write-W2VInfo "Volume formatted..."
    Write-W2VTrace "Disk Signature  : $DiskSignature"
    Write-W2VTrace "Getting the default boot entry..."
    Write-W2VTrace "Getting the OS Loader..."
    Write-W2VTrace "isUserAdmin? $isAdmin"
    Write-W2VTrace "Partition Offset: $PartitionOffset"
    Write-W2VTrace "Partition Style : $PartitionStyle"
    Write-W2VTrace "Return code was $($ret.ExitCode)."
    Write-W2VTrace "Running $Executable $Arguments"
    Write-W2VTrace "Setting Qualified Partition Device Element for VHD boot..."
    Write-W2VTrace "Setting Qualified Partition Device Element in the OS Loader Application..."
    Write-W2VTrace "Setting Qualified Partition Device Element in the OS Loader Device..."
    Write-W2VTrace "Temporary $VHDFormat path is : $VHDPath"
  # Install Connector feature
  Enable-WindowsOptionalFeature -FeatureName MultiPoint-Connector, MultiPoint-Connector-Services -Path $VHDMountLocation
 Microsoft Corporation. All rights reserved.
 Operating System
 Windows
!is an administrative user account
!Resume disk protection and reboot
!This program cannot be run in DOS mode.
"Install disk protection and reboot
"Published session cannot be found.
"Suspend disk protection and reboot
#                                      Here Strings
#                                   Helper Functions
#                             Constants and Pseudo-Constants
#            "/f ALL",              # Support either a UEFI-based or a BIOS-based computer (https://technet.microsoft.com/en-us/library/dd744347(v=ws.10).aspx)
# Banner text displayed during each run.
# C# code to wrap the native APIs in VIRTDISK.DLL and WIMGAPI.DLL.  
# Function to make the # Write-Host (NOT Write-Error) output prettier in the case of an error.
# Function to make the # Write-Host (NOT Write-Warning) output prettier.
# Function to make the # Write-Host output a bit prettier. 
# Function to make the Write-Verbose output... well... exactly the same as it was before.
# Since we use the VHDFormat in output, make it uppercase.
# Text used as the banner in the UI.
# Text used for flag file embedded in VHD(X)
# This code allows Convert-WindowsImage to run without the need for IMAGEX.EXE (and the entire AIK/ADK).
# Version information that can be populated by timebuild.
# We'll make it lowercase again when we use it as a file extension.
##########################################################################################
#Blob
#endregion Helper Functions
#GUID
#region Helper Functions
#Requires -Version 3.0
#Strings
$BETA_SYMBOL         = [char]0x3B2
$code      = @"
$header    = @"
$isoPath      = $null
$logFolder           = "$($env:Temp)\$($scriptName)\$($sessionKey)" # Log folder path.
$lowestSupportedVersion = New-Object Version "10.0"                 # The lowest supported *image* version; we require Windows 10 or higher.
$mkWasHere = @"
$mountedHive  = $null
$myVersion           = "$($ScriptVersion.Major).$($ScriptVersion.Minor).$($ScriptVersion.Build).$($ScriptVersion.QFE).$($ScriptVersion.Flavor).$($ScriptVersion.Branch).$($ScriptVersion.Timestamp)"
$openImage    = $null
$openIso      = $null
$openVhd      = $null
$openWim      = $null
$PARTITION_STYLE_GPT = 0x00000001                                   # Just in case...
$PARTITION_STYLE_MBR = 0x00000000                                   # The default value
$path = Get-VMHardDiskDrive -VMName '{0}' | Select-Object Path; if (($path -ne $null) -and ($path.Path -ne $null)) {{ $path.Path }}
$path = Get-VMHardDiskDrive -VMName '{0}' | Select-Object Path; if (($path -ne $null) -and ($path.Path -ne $null)) {{ $type = Get-VHD -Path $path.Path | select-object VhdType; $type.VhdType }}
$scriptName          = "Convert-WindowsImage"                       # Name of the script, obviously.
$ScriptVersion = DATA {
$sessionKey          = [Guid]::NewGuid().ToString()                 # Session key, used for keeping records unique between multiple runs.
$transcripting       = $false
$uiHeader  = @"
$Uninstall disk protection and reboot
$vhdFinalName = $null
$vhdFinalPath = $null
$VHDFormat = $VHDFormat.ToUpper()
$vhdMaxSize          = 2040GB                                       # Maximum size for VHD is ~2040GB.
$vhdxMaxSize         = 64TB                                         # Maximum size for VHDX is ~64TB.
$vQuality            = $BETA_SYMBOL
%BUILTINADMINPASSWORD%
%BUILTINADMINUSERNAME%
%COMPUTERNAME%
%DOMAINJOINBLOB%
%LOCALE%
%REMOTEDESKTOPREMOTEFXFIREWALL%
%USERACCOUNT%
&*.sw
&amp;
&apos;
&quot;
)Disk protection service is not installed.
)SessionHost is empty or same as localhost
*Disk protection service already installed.
*Microsoft (R) Windows (R) Operating System
.cctor
.ctor
.NETFramework,Version=v4.6
.Parameter 'Message' must not be null or empty.
.text
/"[]|<>+=;,?*@.~:!#$%^&(){} '
@.reloc
@j\}N
@Virtual desktops require Windows 10 Professional or Enterprise. 
[.\s]
[/\\"\[\]:|<>=;,\?\*@]
[CmdletBinding(DefaultParameterSetName="SRC")]
\\.\root\cimv2\TerminalServices:Win32_TSPublishedApplication
\\{0}\root\cimv2\TerminalServices
]When more than one station ID is supplied, parameter 'FriendlyName' must be omitted or empty.
__AlertType_Count
__StaticArrayInitTypeSize=20
__StaticArrayInitTypeSize=58
_CorDllMain
`.rsrc
{0} | where {{ $_.Name -eq '{1}' }} 
{0} -Name {1} {2}
{0} was already added to {1}
{0}$$${1}$$${2}
{0}\{1}
{0}\{1}\{2}
{0}{1}
{0}-{1}
{0}{1}{2}{3}{4}
{0}-t
{4f50731a-89cf-4782-b3e0-dce8c90476ba}
{c7de053a-0c2e-4a44-91a2-5222ec2ecdf1}
} catch {
} finally { 
+Parameter 'Name' must not be null or empty.
+Specified account information is not valid.
<>4__this
<>9__168_0
<>9__169_0
<>9__169_1
<>9__170_0
<>9__170_1
<>9__171_0
<>9__171_1
<>9__172_0
<>9__172_1
<>9__173_0
<>9__173_1
<>9__174_0
<>9__174_1
<>9__25_0
<>9__3_0
<>9__4_0
<>9__47_0
<>9__5_0
<>c__5`1
<>c__DisplayClass100_0
<>c__DisplayClass101_0
<>c__DisplayClass102_0
<>c__DisplayClass103_0
<>c__DisplayClass104_0
<>c__DisplayClass105_0
<>c__DisplayClass106_0
<>c__DisplayClass107_0
<>c__DisplayClass108_0
<>c__DisplayClass109_0
<>c__DisplayClass11_0
<>c__DisplayClass110_0
<>c__DisplayClass111_0
<>c__DisplayClass112_0
<>c__DisplayClass113_0
<>c__DisplayClass114_0
<>c__DisplayClass115_0
<>c__DisplayClass116_0
<>c__DisplayClass117_0
<>c__DisplayClass118_0
<>c__DisplayClass119_0
<>c__DisplayClass12_0
<>c__DisplayClass120_0
<>c__DisplayClass121_0
<>c__DisplayClass122_0
<>c__DisplayClass123_0
<>c__DisplayClass124_0
<>c__DisplayClass125_0
<>c__DisplayClass126_0
<>c__DisplayClass127_0
<>c__DisplayClass128_0
<>c__DisplayClass130_0
<>c__DisplayClass131_0
<>c__DisplayClass132_0
<>c__DisplayClass139_0
<>c__DisplayClass140_0
<>c__DisplayClass141_0
<>c__DisplayClass142_0
<>c__DisplayClass143_0
<>c__DisplayClass144_0
<>c__DisplayClass145_0
<>c__DisplayClass146_0
<>c__DisplayClass147_0
<>c__DisplayClass148_0
<>c__DisplayClass149_0
<>c__DisplayClass150_0
<>c__DisplayClass151_0
<>c__DisplayClass152_0
<>c__DisplayClass153_0
<>c__DisplayClass154_0
<>c__DisplayClass155_0
<>c__DisplayClass156_0
<>c__DisplayClass157_0
<>c__DisplayClass158_0
<>c__DisplayClass159_0
<>c__DisplayClass160_0
<>c__DisplayClass164_0
<>c__DisplayClass165_0
<>c__DisplayClass167_0
<>c__DisplayClass37_0
<>c__DisplayClass38_0
<>c__DisplayClass39_0
<>c__DisplayClass40_0
<>c__DisplayClass41_0
<>c__DisplayClass42_0
<>c__DisplayClass43_0
<>c__DisplayClass47_0
<>c__DisplayClass48_0
<>c__DisplayClass49_0
<>c__DisplayClass50_0
<>c__DisplayClass52_0
<>c__DisplayClass52_1
<>c__DisplayClass53_0
<>c__DisplayClass54_0
<>c__DisplayClass55_0
<>c__DisplayClass56_0
<>c__DisplayClass60_0
<>c__DisplayClass61_0
<>c__DisplayClass62_0
<>c__DisplayClass62_1
<>c__DisplayClass63_0
<>c__DisplayClass66_0
<>c__DisplayClass66_1
<>c__DisplayClass66_2
<>c__DisplayClass67_0
<>c__DisplayClass68_0
<>c__DisplayClass71_0
<>c__DisplayClass72_0
<>c__DisplayClass73_0
<>c__DisplayClass74_0
<>c__DisplayClass75_0
<>c__DisplayClass78_0
<>c__DisplayClass79_0
<>c__DisplayClass80_0
<>c__DisplayClass81_0
<>c__DisplayClass82_0
<>c__DisplayClass85_0
<>c__DisplayClass87_0
<>c__DisplayClass88_0
<>c__DisplayClass89_0
<>c__DisplayClass90_0
<>c__DisplayClass90_1
<>c__DisplayClass91_0
<>c__DisplayClass91_1
<>c__DisplayClass93_0
<>c__DisplayClass93_1
<>c__DisplayClass94_0
<>c__DisplayClass95_0
<>c__DisplayClass97_0
<>c__DisplayClass98_0
<>c__DisplayClass99_0
<AddRemoteManagedComputer>b__0
<AddRemoteManagedComputerUsingSuppliedCredentials>b__0
<AddUser>b__0
<AdministratorPassword>k__BackingField
<AdministratorUser>k__BackingField
<AlertSeverity>k__BackingField
<AlertStatus>k__BackingField
<AlertType>k__BackingField
<All>k__BackingField
<AutoLogOnPassword>k__BackingField
<AutoLogOnUserName>k__BackingField
<AutomaticUpdateMode>k__BackingField
<Blanked>k__BackingField
<BlankedMessage>k__BackingField
<BlockUsbStorageDevices>b__0
<BlockUsbStorageDevicesAllStations>b__0
<BootToConsoleModeEnabled>k__BackingField
<ChatId>k__BackingField
<ClientName>k__BackingField
<CloseSessionApplication>b__0
<CloudServers>k__BackingField
<CollabId>k__BackingField
<ComputerName>k__BackingField
<Configuration>k__BackingField
<ConfigureChat>b__0
<ConfigureVirtualIpPerSession>b__0
<ConfigureWebLimiting>b__0
<ConfigureWebLimitingAll>b__0
<ConnectIM>b__0
<ConnectionError>k__BackingField
<ConnectionErrorMessage>k__BackingField
<ConnectionString>k__BackingField
<CreateTime>k__BackingField
<CustomScript>k__BackingField
<CustomScriptFullPath>k__BackingField
<CustomScriptMaxRuntimeMinutes>k__BackingField
<DefaultValue>k__BackingField
<DesktopMonitoringEnabled>k__BackingField
<DeviceCount>k__BackingField
<DeviceCounts>k__BackingField
<DeviceType>k__BackingField
<DeviceTypes>k__BackingField
<DisconnectIM>b__0
<DisconnectSession>b__0
<DiscoverType>k__BackingField
<DisplayOrientation>k__BackingField
<Domain>k__BackingField
<DomainName>k__BackingField
<DomainOrWorkgroupName>k__BackingField
<DoWork>k__BackingField
<DoWorkInParallel>b__0
<EnableProjectAll>b__0
<EnableWebLimitingAll>b__0
<EnumerateStationIDs>b__0
<EnumerateStationIDs>b__1
<EnumerateUsers>b__0
<ErrorCode>k__BackingField
<eventSink>k__BackingField
<EventType>k__BackingField
<ExceptionProperty>k__BackingField
<ExcludedCloudServers>k__BackingField
<ExcludedMultiPointServers>k__BackingField
<ExcludedPersonalComputers>k__BackingField
<GetClientVersion>b__0
<GetConnectionState>b__3_0
<GetCurrentActivity>b__0
<GetDiskProtectionMode>b__0
<GetDiskProtectionNeededSpaceInGb>b__0
<GetDisplayOrientation>b__0
<GetIMultiPointCertificateRequestProxy>b__168_0
<GetIMultiPointChatProxy>b__169_0
<GetIMultiPointChatProxy>b__169_1
<GetIMultiPointDiskProtectionProxy>b__174_0
<GetIMultiPointDiskProtectionProxy>b__174_1
<GetIMultiPointServerProxy>b__171_0
<GetIMultiPointServerProxy>b__171_1
<GetIMultiPointSessionProxy>b__173_0
<GetIMultiPointSessionProxy>b__173_1
<GetIMultiPointStationProxy>b__170_0
<GetIMultiPointStationProxy>b__170_1
<GetIMultiPointUserManagerProxy>b__172_0
<GetIMultiPointUserManagerProxy>b__172_1
<GetLicenseCount>b__0
<GetManagedSystemsType>b__0
<GetMultiPointProtocolVersion>b__0
<GetNetJoinStatus>b__0
<GetPeerWmsConnectorList>b__0
<GetPeerWmsServerList>b__0
<GetRunningApps>b__0
<GetScheduledUpdateConfiguration>b__0
<GetScreenState>b__0
<GetServerVersion>b__0
<GetSessionFlags>b__0
<GetStation>b__0
<GetStation>b__1
<GetStation>b__2
<GetStation>b__3
<GetStation>b__4
<GetStation>b__5
<GetStationServerName>b__0
<GetSystemMode>b__0
<GetThumbnailBits>b__0
<GetUpdateSchedule>b__0
<HasNonLoopbackAdapter>k__BackingField
<HourToScheduleUpdates>k__BackingField
<IdentifyAll>b__0
<IdentifySession>b__0
<IdentifySessionWrapper>b__0
<IdentifyStation>b__0
<ImportModules>b__1
<ImportModules>b__47_0
<InputFilePath>k__BackingField
<InstallDiskProtectionService>b__0
<IpAddresses>k__BackingField
<IsAdmin>k__BackingField
<IsAdminOrchestrationEnabled>k__BackingField
<IsAllowList>k__BackingField
<IsAllowRemoteManagementOn>k__BackingField
<IsAutoLogOn>k__BackingField
<IsBitmapUnavailable>k__BackingField
<IsChatEnabled>k__BackingField
<IsDesktopMonitoringAllowed>k__BackingField
<IsDisconnected>k__BackingField
<IsInLimiting>k__BackingField
<IsIPPerSessionEnabled>k__BackingField
<IsLocked>k__BackingField
<IsMOGUser>k__BackingField
<IsOrchestratable>k__BackingField
<IsPrivate>k__BackingField
<IsRail>k__BackingField
<IsScheduleUpdateEnabled>k__BackingField
<IsSingleSessionPerUser>k__BackingField
<IsSplit>k__BackingField
<IsUsbStorageBlocked>k__BackingField
<IsUsbStorageDeviceBlocked>b__0
<IsVirtualDesktopEnabled>b__25_0
<IsVirtualIpPerSessionEnabled>b__0
<IsVirtualMachine>k__BackingField
<IsWebLimited>k__BackingField
<Key>k__BackingField
<LoadWindowsEdition>b__0
<LockSession>b__0
<LogOffConsoleSession>b__0
<LogOffSession>b__0
<ManagedServerFqdn>k__BackingField
<ManagedServerIpAddresses>k__BackingField
<ManagedSystemsType>k__BackingField
<MaxTimeAllowedForCustomScript>k__BackingField
<Message>k__BackingField
<Module>
<MultiPointServers>k__BackingField
<Name>k__BackingField
<NetJoinStatus>k__BackingField
<NotificationType>k__BackingField
<OnAssociateSessionWithStation>b__0
<OnboardVirtualDesktop>b__0
<OnBootToConsoleModeChange>b__0
<OnConfigureStation>b__0
<OnDesktopMonitoringChange>b__0
<OnDeviceAdded>b__0
<OnDeviceRemoved>b__0
<OnEnterSplitScreen>b__0
<OnExitSplitScreen>b__0
<OnGroupUpdated>b__133_0
<OnManagedServerOffline>b__0
<OnManagedServerOnline>b__0
<OnPeerServerAdded>b__0
<OnPeerServerDiscovered>b__0
<OnPeerServerRemoved>b__0
<OnProjectionStateChange>b__0
<OnScheduledUpdateSettingsChanged>b__0
<OnServiceControlSessionChange>b__0
<OnSessionAgentReady>b__0
<OnSessionBlocked>b__0
<OnSessionDisconnected>b__0
<OnSessionUnblocked>b__0
<OnStationAdded>b__0
<OnStationAlert>b__0
<OnStationRemoved>b__0
<OnSystemAlert>b__0
<OnSystemModeChange>b__0
<OnUserCreated>b__0
<OnUserDeleted>b__0
<OnUserUpdated>b__0
<OnVirtualDesktopNotification>b__0
<OnVirtualDesktopOnline>b__0
<OperatingMode>k__BackingField
<OperatingSystem>k__BackingField
<ParentVirtualMachineName>k__BackingField
<Password>k__BackingField
<PeerServerFqdn>k__BackingField
<PeerServerIpAddress>k__BackingField
<PersonalComputers>k__BackingField
<PrivateImplementationDetails>
<ProcessId>k__BackingField
<Progress>k__BackingField
<ProtocolVersion>k__BackingField
<QueryRemoteManagementProperty>b__0
<QuerySessionInformationForString>b__4_0
<QuerySessionInformationForStruct>b__5_0
<Reboot>b__0
<RefreshStation>b__0
<RegKey>k__BackingField
<RemapStations>b__0
<RemoteConnectionServerName>k__BackingField
<RemoveRemoteManagedComputer>b__0
<RemoveUser>b__0
<Restart>k__BackingField
<Results>k__BackingField
<ReturnState>k__BackingField
<RunFileSession>b__0
<ScheduledUpdateMode>k__BackingField
<ScheduleUpdateCustomScript>k__BackingField
<ScheduleUpdateRunWU>k__BackingField
<ScheduleUpdatesReturnState>k__BackingField
<ScreenBroadcastState>k__BackingField
<SendError>b__0
<SendIM>b__0
<SendMsg>b__0
<Server>k__BackingField
<ServerFqdn>k__BackingField
<ServerName>k__BackingField
<SessionHostFqdn>k__BackingField
<SessionHostServer>k__BackingField
<SessionId>k__BackingField
<SetAdminOrchestrationMode>b__0
<SetBlockAllMessage>b__0
<SetBootToConsoleMode>b__0
<SetBootToConsoleMode>b__1
<SetCurrentDashboardUser>b__0
<SetDesktopMonitoring>b__0
<SetDiskProtectionServiceInDiscardMode>b__0
<SetDiskProtectionServiceInPassiveMode>b__0
<SetDisplayOrientation>b__0
<SetSingleSessionPerUser>b__0
<SetStationAutologon>b__0
<SetStationAutologon>b__1
<SetStationAutologon>b__2
<SetStationName>b__0
<SetStationRemoteConnection>b__0
<SetSuppressPrivacyNotification>b__0
<SetUpdateSchedule>b__0
<SetUseHardwareGpu>b__0
<SetUserInfo>b__0
<ShareDesktop>b__0
<Shutdown>b__0
<ShutdownNotification>b__129_0
<Sites>k__BackingField
<SplitStation>b__0
<State>k__BackingField
<StationHostFqdn>k__BackingField
<StationId>k__BackingField
<StopIdentifyingSession>b__0
<StopIdentifyingStation>b__0
<StopIdentifySessions>b__0
<StopIdentifyStations>b__0
<StopLockingSession>b__0
<StopShareDesktop>b__0
<SuppressPrivacyNotification>k__BackingField
<TemplatePrefix>k__BackingField
<TemplateVirtualMachineGuid>k__BackingField
<ThumbnailBits>k__BackingField
<ThumbnailImage>k__BackingField
<TimeStampInUtc>k__BackingField
<UnblockUsbStorageDevices>b__0
<UnblockUsbStorageDevicesAllStations>b__0
<UnInstallDiskProtectionService>b__0
<UniqueId>k__BackingField
<UnsplitStation>b__0
<UpdateStartHour>k__BackingField
<UseHardwareGpu>k__BackingField
<UserAccounts>
<UserName>k__BackingField
<Value>k__BackingField
<VhdLocation>k__BackingField
<ViewDesktop>b__0
<VirtualDiskPath>k__BackingField
<VirtualMachineFqdn>k__BackingField
<VirtualMachineHostName>k__BackingField
<VirtualMachineId>k__BackingField
<VirtualMachineName>k__BackingField
<VMType>k__BackingField
<WindowId>k__BackingField
<WindowsEdition>k__BackingField
<WmsClientVersion>k__BackingField
<WmsServerVersion>k__BackingField
>d:\os\public\amd64fre\internal\strongnamekeys\fake\windows.snk
040904B0
0B747D09-1DEB-40E5-984D-D8F234FA8E06
0Parameter 'FileToRun' must not be null or empty.
1.0.0.0
10.0.10011.16384
10.0.17763.1
10.0.17763.1 (WinBuild.160101.0800)
1The specified Auto-logon account name is invalid.
2;CKS\enw
2B57672B-F986-4DFB-B654-41E98FF09C09
385DDB3F5884C4043B1896D8CC86940FF3AE5F93
3System.Resources.Tools.StronglyTypedResourceBuilder
4.0.0.0
6609FBE6-15C0-437B-90AA-B782ADFDD1CA
7621215C-EBB0-4D76-B6C7-28E15ED80B9E
7D60D060FDFDA0BF6D662598D9DBA43848EDC104
9Copyright (c) Microsoft Corporation. All rights reserved.
9The Desktop's Invitation field must not be null or empty.
AccessOptions
Action:http://MultiPoint/RemoteManagement/IMultiPointChat/ConnectT
Action:http://MultiPoint/RemoteManagement/IMultiPointChat/SendMsgT
Action;http://MultiPoint/RemoteManagement/IMultiPointServer/RebootT
Action?http://MultiPoint/RemoteManagement/IMultiPointServer/EnableChatT
Action\http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnScheduledUpdateSettingsChangedT
Action\http://MultiPoint/RemoteManagement/IMultiPointCredentialRequest/RequestWmsControlCredentialsT
Action_http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnManagedServerOnlineNotifyT
Action_http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnNewServerCertificateReadyT
Action`1
Action`http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnManagedServerOfflineNotifyT
Action+http://MultiPoint/RemoteManagement/WmsFaultT
Action<http://MultiPoint/RemoteManagement/IMultiPointChat/GetChatIdT
Action<http://MultiPoint/RemoteManagement/IMultiPointChat/SendErrorT
Action=http://MultiPoint/RemoteManagement/IMultiPointChat/DisconnectT
Action=http://MultiPoint/RemoteManagement/IMultiPointServer/ShutdownT
Action7http://MultiPoint/RemoteManagement/IMultiPointChat/PingT
ActionAhttp://MultiPoint/RemoteManagement/IMultiPointSession/LockSessionT
ActionAhttp://MultiPoint/RemoteManagement/IMultiPointSession/ViewDesktopT
ActionAhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/AddUserT
ActionBhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetSystemModeT
ActionBhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsChatEnabledT
ActionBhttp://MultiPoint/RemoteManagement/IMultiPointSession/ShareDesktopT
ActionBhttp://MultiPoint/RemoteManagement/IMultiPointStation/SplitStationT
ActionChttp://MultiPoint/RemoteManagement/IMultiPointServer/GetAllSessionsT
ActionChttp://MultiPoint/RemoteManagement/IMultiPointSession/LogOffSessionT
ActionChttp://MultiPoint/RemoteManagement/IMultiPointStation/RemapStationsT
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetModeT
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/InstallT
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/SetModeT
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetLicenseCountT
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetScreenStateT
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointSession/RunFileSessionT
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointStation/RefreshStationT
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/RemoveUserT
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetClientVersionT
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetNetJoinStatusT
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetServerVersionT
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointSession/CurrentActivityT
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionFlagsT
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointSession/IdentifySessionT
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointStation/IdentifyStationT
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/SetUserInfoT
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/UninstallT
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetUseHardwareGpuT
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetWmsWebLimitingT
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetUseHardwareGpuT
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetThumbnailBitsT
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopShareDesktopT
ActionGhttp://MultiPoint/RemoteManagement/IMultiPointServer/LoadWindowsEditionT
ActionGhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetBlockAllMessageT
ActionGhttp://MultiPoint/RemoteManagement/IMultiPointSession/DisconnectSessionT
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/IsInstalledT
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsBootToConsoleModeT
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsHypervisorPresentT
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointSession/EnableProjectToAllT
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopLockingSessionT
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetDisplayRotationT
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetDisplayRotationT
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/EnumerateUsersT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDeviceAddedT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSystemAlertT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserCreatedT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserDeletedT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserUpdatedT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetPeerWmsServerListT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetSystemAlertStatusT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetBootToConsoleModeT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetDesktopMonitoringT
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationAutoLogonT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnGroupUpdatedT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationAddedT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationAlertT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetManagedSystemsTypeT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/OnboardVirtualDesktopT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/RegisterChatEventSinkT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/RegisterCoreEventSinkT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointSession/ConfigureWebLimitingT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointSession/EnableWebLimitingAllT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointSession/LogOffConsoleSessionT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationServerNameT
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationServerNameT
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDeviceRemovedT
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsSingleSessionPerUserT
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionAgentStatusT
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionRunningAppsT
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationAlertStatusT
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationInformationT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionBlockedT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationRemovedT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetPeerWmsConnectorListT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetSingleSessionPerUserT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/UnregisterChatEventSinkT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/UnregisterCoreEventSinkT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopIdentifyingSessionT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/BlockUsbStorageDevicesT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationFriendlyNameT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationFriendlyNameT
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/StopIdentifyingStationT
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnExitSplitScreenT
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerAddedT
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsAdminOrchestrationModeT
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/ValidateAutoLogonAccountT
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/CloseSessionApplicationT
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/ConfigureWebLimitingAllT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnConfigureStationT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEnterSplitScreenT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionUnblockedT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSystemModeChangeT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/EnableVirtualIpPerSessionT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetVirtualMachineHostnameT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetAdminOrchestrationModeT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetNextStationIdentifierT
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointStation/UnblockUsbStorageDevicesT
ActionNotSupportedException
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerRemovedT
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionAgentReadyT
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionConnectingT
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetFreeSpaceNeededT
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetVirtualMachineIpAddressT
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsDesktopMonitoringAllowedT
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointStation/IsUsbStorageDeviceBlockedT
ActionPhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEndIdentifySessionT
ActionPhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEndIdentifyStationT
ActionPhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/ShutdownNotificationT
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnManagedServerOnlineT
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionDisconnectedT
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointCredentialRequest/SetSslCertificateT
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetReplacementSslCertificateT
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsVirtualIpPerSessionEnabledT
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetReplacementSslCertificateT
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationDeviceInformationT
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBeginIdentifySessionT
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBeginIdentifyStationT
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnManagedServerOfflineT
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerDiscoveredT
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnVirtualDesktopOnlineT
ActionShttp://MultiPoint/RemoteManagement/IMultiPointCertificateRequest/GetProtocolVersionT
ActionShttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnProjectionStateChangeT
ActionShttp://MultiPoint/RemoteManagement/IMultiPointServer/SetSuppressPrivacyNotificationT
ActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationAutoLogonInformationT
ActionUhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBootToConsoleModeChangeT
ActionUhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDesktopMonitoringChangeT
ActionUhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsSuppressPrivacyNotificationSetT
ActionVhttp://MultiPoint/RemoteManagement/IMultiPointCertificateRequest/RequestSslCertificateT
ActionVhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationSplitScreenInformationT
ActionWhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetScheduledUpdateSettingsT
ActionWhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/SetScheduledUpdateSettingsT
ActionWhttp://MultiPoint/RemoteManagement/IMultiPointStation/BlockUsbStorageDevicesAllStationsT
ActionXhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnVirtualDesktopNotificationT
ActionYhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnAssociateSessionWithStationT
ActionYhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnServiceControlSessionChangeT
ActionYhttp://MultiPoint/RemoteManagement/IMultiPointStation/UnblockUsbStorageDevicesAllStationsT
Active
activity
AdapterTypeID
add_BootToConsoleModeChanged
add_DesktopMonitoringChanged
add_ErrorReceived
add_ManagedServerOffline
add_ManagedServerOnline
add_MessageReceived
add_PeerServerAdded
add_PeerServerDiscovered
add_PeerServerRemoved
add_PropertyChanged
add_ScheduledUpdateSettingsChanged
add_ServerShutdown
add_SessionAgentReady
add_SessionAssociatedWithStation
add_SessionBlocked
add_SessionProjectionStateChanged
add_SessionStateChanged
add_SessionUnblocked
add_StationAdded
add_StationAlertArrived
add_StationConfigured
add_StationDeviceAdded
add_StationDeviceRemoved
add_StationEnteredSplitScreen
add_StationExitedSplitScreen
add_StationRemoved
add_StationSessionDisconnected
add_SystemAlertArrived
add_SystemModeChanged
add_UserCreated
add_UserDeleted
add_UserGroupUpdated
add_UserUpdated
add_VirtualDesktopNotification
add_VirtualDesktopOnline
AddDomainAccountBlock
AddLocalAccountBlock
AddRemoteManagedComputer
AddRemoteManagedComputerUsingSuppliedCredentials
AddScript
AddServiceEndpoint
AddToExcludedServerList
AddUrlAcl
AddUserRequest
AddUserRequestBody
AddUserResponse
AddUserResponseBody
AddUserResponseT
AddUserT
Add-WindowsFeature
Administrator
administratorPassword
AdministratorsGroupSid
administratorUser
adminPassword
adminUser
advapi32.dll
AlertKeyFormat
alertSeverity
alertSeverityTable
alertStatus
alertType
Alias
AliasAttribute
AllocHGlobal
allow desktop composition:i:1
allow font smoothing:i:1
AllowedTimeIncrementToRunCustomScriptInMinutes
AllowEmptyStringAttribute
allowList
allowList64
allowNullEmpty
AllowRemoteSessionHostServer
alternate shell:s:||{0}
An invalid VM is specified
AppDomain
Append
AppendChar
Apply-BCDStoreChanges {
ArgumentException
ArgumentNullException
ArgumentOutOfRangeException
arguments
ArrayOfBytes
ArrayOfBytesT
ArrayOfStrings
ArrayOfStringsT
ArrayOfWMS_RUNNING_APP_WS
ArrayOfWMS_RUNNING_APP_WST
ArrayOfWMS_SESSION_INFO_WS
ArrayOfWMS_SESSION_INFO_WST
ArrayOfWMS_USER_WS
ArrayOfWMS_USER_WST
AssemblyCompanyAttribute
AssemblyCopyrightAttribute
AssemblyDelaySignAttribute
AssemblyFileVersionAttribute
AssemblyKeyFileAttribute
AssemblyProductAttribute
AsyncCallback
attemptingToConnect
attributeCount
attributes
authentication level:i:2
AuthenticationMechanism
authError
authPackage
authType
AuthType
AutoAdminLogon
autoConfig
autologonCombinedUserName
autologonConfig
AutoLogonCredentialFailed
autologonDomain
AutoLogonNameIsInvalid
autologonPassword
AutoLogonRegistryKey
AutoLogonRegistryPath
autologonSetting
autologonUserName
AutoResetEvent
B792CA7A-F156-4DD1-B45B-ADC89CA110C4
BeginInvoke
binding
bitField
bitmapcachesize:i:32000
BitmapSource
blockList
blockList64
BlockUsbStorageDevices
BlockUsbStorageDevicesAllStations
Boolean
BootToConsoleMode
bootToConsoleMode
BootToConsoleMode
BootToConsoleModeEventArgs
BringProcessWindowToFront
BringWindowToForeground
bstrFileToRun
bstrServerName
bstrTeacherName
bstrUriSinkEndpoint
bstrVirtualMachineHostName
bstrWinStation
buffer
bufferLength
bytesReturned
callback
caller
caption
cbAccountName
cbAuthBuffer
cbDataBits
cbDomainName
cbSid
cbSize
cchName
cchReferencedDomainName
CD742EB2-467C-4494-9976-E15EDDF9D27E
cDevices
CERT_STORE_BACKUP_RESTORE_FLAG
CERT_STORE_CREATE_NEW_FLAG
CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
CERT_STORE_DELETE_FLAG
CERT_STORE_ENUM_ARCHIVED_FLAG
CERT_STORE_MANIFOLD_FLAG
CERT_STORE_MAXIMUM_ALLOWED_FLAG
CERT_STORE_NO_CRYPT_RELEASE_FLAG
CERT_STORE_OPEN_EXISTING_FLAG
CERT_STORE_PROV_MEMORY
CERT_STORE_PROV_SYSTEM
CERT_STORE_PROV_SYSTEM_REGISTRY
CERT_STORE_READONLY_FLAG
CERT_STORE_SET_LOCALIZED_NAME_FLAG
CERT_STORE_SHARE_CONTEXT_FLAG
CERT_STORE_SHARE_STORE_FLAG
CERT_STORE_UNSAFE_PHYSICAL_FLAG
CERT_STORE_UPDATE_KEYID_FLAG
CERT_SYSTEM_STORE_CURRENT_SERVICE
CERT_SYSTEM_STORE_CURRENT_USER
CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
CERT_SYSTEM_STORE_LOCAL_MACHINE
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
CERT_SYSTEM_STORE_SERVICES
CERT_SYSTEM_STORE_USERS
CertCloseStore
certificate
CertOpenStore
CertOpenStoreFlags
CertOpenStoreProvider
chain
CheckDomainPreRequisites
CheckImageForSupportedEditions
CheckPreRequisites
CimV2namespace
Clear
cLicenses
Client
client
Client
ClientBase`1
clientName
ClientVersionKey
CloneCollection
Close
CloseHandle
CloseSessionApplication
ClrNamespace
CLSCompliantAttribute
CMD /C Powershell -Command "$Shortcut=''%USERPROFILE%\Desktop\COMPLETECUSTOMIZATION.LNK'';$wShell=(New-Object -COM WScript.Shell).CreateShortcut($Shortcut);$wShell.TargetPath=''%WINDIR%\TEMP\CompleteCustomization.CMD'';$wShell.Save();
CmdletAttribute
cmdletCommand
CmdletThreadWorker
collabStationID
CollectDomainTelemtry
collectionCreationLock
CollectionDataContractAttribute
collectionType
CollectVhdLocationTelemtry
Combine
COMException
command
CommandCollection
CommandLineSetting
CommandParameter
CommandParameterCollection
commandParameters
comment
CommunicationException
CompanyName
Compare
CompareExchange
CompilationRelaxationsAttribute
CompilerGeneratedAttribute
computerName
ComputerName
computerName
ComputerName
computerName cannot be null or empty and its length cannot be greater than 
computerName has invalid characters
computerName is null or empty
ComputerName: {0}
ComputerNameLength
ComputerNameRegexInvalidChars
ComputerNameRegexPeriodSpace
ComVisibleAttribute
Concat
ConcurrentQueue`1
configurationKey
ConfigurationName
ConfigurationName IMultiPointSystemOnlineEventSinkH
ConfigureChat
ConfigureVirtualIpPerSession
ConfigureWebLimiting
ConfigureWebLimitingAllRequest
ConfigureWebLimitingAllRequestBody
ConfigureWebLimitingAllResponse
ConfigureWebLimitingAllResponseBody
ConfigureWebLimitingAllResponseT
ConfigureWebLimitingAllT
ConfirmImpact
Connected
ConnectedToStation
ConnectIM
connection type:i:6
connectionCount
ConnectionCount
ConnectionOptions
connectionState
ConnectionType
connectionType
ConnectQuery
ConnectRequest
ConnectRequestBody
ConnectResponse
ConnectResponseBody
ConnectResponseT
ConnectT
ConnectTime
Console
Constants
ConstructUnattendFiles
ConstructVirtualDesktopName
Contains
ContainsKey
ContractNamespaceAttribute
Convert
ConvertSqmDataPoint.pl
ConvertStringToSecureString
ConvertStringToUnsecureString
ConvertStructureToPtr
ConvertWebsiteArrayToInternalFormat
Convert-WindowsImage.PS1
ConvertWindowsImagePowershellScript
ConvertWindowsImagePowershellScript3
cookie
Copyright (C) Microsoft Corporation.  All rights reserved.
CopyTo
Core call failed
CoreCallFailed
CoreData
coreManager
CostDeferredLatency
CoTaskMemFree
Could not connect to remote WMS System {0}, error: {1}.
Create
CreateAllVirtualDesktops2
CreateCustomizeUnattendFile
CreateInstance
CreateLog
CreateMessageFault
CreatePipeline
CreateRunspace
CreateStationVirtualDesktopTemplate
CreateStationVm
CreateStationVms
CreateSubKey
CreateTemplateVirtualHardDisk
CreateTemplateVirtualMachine
createTime
CreateTimeField
CreateUnattendFiles
CreateVirtualDesktopByIdT
CreateVirtualDesktopImage
CreateVirtualDesktopTemplate
CreateVirtualMachine
CreateVirtualSwitch
CreateWellKnownSid
CreateWmsAlert
CreateWmsShell
CreateWmsShellBackup
CreateWmsVirtualDesktop
CreateWmsVirtualDesktopTemplate
CreateWSManConnectionInfo
CreateXmlSerializer
CRED_TYPE_DOMAIN_PASSWORD
CRED_TYPE_GENERIC
CRED_TYPE_UNKNOWN
CredDeleteW
credential
credentialBlob
credentialBlobSize
CredentialTargetFormat
CredFree
CredReadW
credui.dll
CredUIInfo
CredUIPromptForWindowsCredentials
CredUIWin
CREDUIWIN_AUTHPACKAGE_ONLY
CREDUIWIN_CHECKBOX
CREDUIWIN_ENUMERATE_ADMINS
CREDUIWIN_ENUMERATE_CURRENT_USER
CREDUIWIN_GENERIC
CREDUIWIN_IN_CRED_ONLY
CREDUIWIN_PACK_32_WOW
CREDUIWIN_SECURE_PROMPT
CredUnPackAuthenticationBuffer
CredWriteW
Critical
CriticalDataKeyword
CriticalPersistence
crypt32.dll
Crypt32.dll
CS$<>8__locals1
CS$<>8__locals2
CultureInfo
Current Operating System version not supported by TerminalServicesSession function
currentActivity
CurrentActivityRequest
CurrentActivityRequestBody
CurrentActivityResponse
CurrentActivityResponseBody
CurrentActivityResponseT
CurrentActivityT
currentDashboardUser
currentStage
currentStationID
CurrentTime
CurrentUser
customizeUnattendFile
customScript
DASHBOARD
DashboardExeFileName
dataBits
dataId
DATAID_WMS_DASHBOARD_DURATION_MINUTES
DATAID_WMS_MANAGED_SERVERS
DATAID_WMS_MANAGER_DURATION_MINUTES
DATAID_WMS_SETTINGS
DATAID_WMS_TASK_DESKTOPS_AUTOLAUNCH_DISABLE
DATAID_WMS_TASK_DESKTOPS_AUTOLAUNCH_ENABLE
DATAID_WMS_TASK_DESKTOPS_BLOCK
DATAID_WMS_TASK_DESKTOPS_BLOCK_ALL
DATAID_WMS_TASK_DESKTOPS_BLOCK_MULTI
DATAID_WMS_TASK_DESKTOPS_BLOCK_USB_STORAGE
DATAID_WMS_TASK_DESKTOPS_BLOCK_USB_STORAGE_ALL
DATAID_WMS_TASK_DESKTOPS_CHANGE_SIZE
DATAID_WMS_TASK_DESKTOPS_CHAT_DISABLE
DATAID_WMS_TASK_DESKTOPS_CHAT_ENABLE
DATAID_WMS_TASK_DESKTOPS_CHAT_SEND
DATAID_WMS_TASK_DESKTOPS_CLEAR_CHAT_MESSAGES
DATAID_WMS_TASK_DESKTOPS_CLOSE_APP
DATAID_WMS_TASK_DESKTOPS_CONFIG_WEB_LIMIT
DATAID_WMS_TASK_DESKTOPS_ENLARGE
DATAID_WMS_TASK_DESKTOPS_EXCLUDE_SYSTEM
DATAID_WMS_TASK_DESKTOPS_GROUP_BY_COMPUTER
DATAID_WMS_TASK_DESKTOPS_HELP
DATAID_WMS_TASK_DESKTOPS_INCLUDE_SYSTEM
DATAID_WMS_TASK_DESKTOPS_LAUNCH_APP_ALL
DATAID_WMS_TASK_DESKTOPS_LAUNCH_APP_MULTI
DATAID_WMS_TASK_DESKTOPS_LIMIT_WEB_ALL
DATAID_WMS_TASK_DESKTOPS_LIMIT_WEB_MULTI
DATAID_WMS_TASK_DESKTOPS_LOGOFF_ALL
DATAID_WMS_TASK_DESKTOPS_LOGOFF_MULTI
DATAID_WMS_TASK_DESKTOPS_MESSAGE
DATAID_WMS_TASK_DESKTOPS_REMOTE_CONTROL
DATAID_WMS_TASK_DESKTOPS_SEARCH
DATAID_WMS_TASK_DESKTOPS_SHARE_ALL
DATAID_WMS_TASK_DESKTOPS_SHARE_MULTI
DATAID_WMS_TASK_DESKTOPS_SHARE_SELECTED_ALL
DATAID_WMS_TASK_DESKTOPS_SHOW_ACTIVE
DATAID_WMS_TASK_DESKTOPS_SHOW_ALL
DATAID_WMS_TASK_DESKTOPS_SORT_ASCENDING
DATAID_WMS_TASK_DESKTOPS_SORT_BY_COMPUTER
DATAID_WMS_TASK_DESKTOPS_SORT_BY_STATION
DATAID_WMS_TASK_DESKTOPS_SORT_BY_USER
DATAID_WMS_TASK_DESKTOPS_SORT_DESCENDING
DATAID_WMS_TASK_DESKTOPS_STOP_LIMIT_WEB_ALL
DATAID_WMS_TASK_DESKTOPS_STOP_LIMIT_WEB_MULTI
DATAID_WMS_TASK_DESKTOPS_STOP_SHARING
DATAID_WMS_TASK_DESKTOPS_THUMBNAIL_VIEW
DATAID_WMS_TASK_DESKTOPS_UNBLOCK
DATAID_WMS_TASK_DESKTOPS_UNBLOCK_ALL
DATAID_WMS_TASK_DESKTOPS_UNBLOCK_MULTI
DATAID_WMS_TASK_DESKTOPS_UNBLOCK_USB_STORAGE
DATAID_WMS_TASK_DESKTOPS_UNBLOCK_USB_STORAGE_ALL
DATAID_WMS_TASK_DESKTOPS_UNGROUP
DATAID_WMS_TASK_HOME_ADD_CALS
DATAID_WMS_TASK_HOME_DISABLE_DP_FAIL_DURATION
DATAID_WMS_TASK_HOME_DISABLE_DP_FAIL_ERROR
DATAID_WMS_TASK_HOME_DISABLE_DP_START
DATAID_WMS_TASK_HOME_DISABLE_DP_SUCCESS_DURATION
DATAID_WMS_TASK_HOME_DISCUSSION_BOARD
DATAID_WMS_TASK_HOME_ENABLE_DP_FAIL_DURATION
DATAID_WMS_TASK_HOME_ENABLE_DP_FAIL_ERROR
DATAID_WMS_TASK_HOME_ENABLE_DP_START
DATAID_WMS_TASK_HOME_ENABLE_DP_SUCCESS_DURATION
DATAID_WMS_TASK_HOME_MAINTENANCE
DATAID_WMS_TASK_HOME_MANAGE_CALS
DATAID_WMS_TASK_HOME_MANAGE_COMPUTERS
DATAID_WMS_TASK_HOME_NORMAL
DATAID_WMS_TASK_HOME_REMAP
DATAID_WMS_TASK_HOME_REMOVE_CALS
DATAID_WMS_TASK_HOME_RESTART
DATAID_WMS_TASK_HOME_SAVE_CONNECTION
DATAID_WMS_TASK_HOME_SETTINGS
DATAID_WMS_TASK_HOME_SHUTDOWN
DATAID_WMS_TASK_HOME_WEB
DATAID_WMS_TASK_STATUS_AUTOLOGON
DATAID_WMS_TASK_STATUS_IDENTIFY
DATAID_WMS_TASK_STATUS_IDENTIFY_ALL
DATAID_WMS_TASK_STATUS_LOGOFF
DATAID_WMS_TASK_STATUS_LOGOFF_ALL
DATAID_WMS_TASK_STATUS_SPLIT_SCREEN
DATAID_WMS_TASK_STATUS_STATION_NAME
DATAID_WMS_TASK_STATUS_STOP_IDENTIFY_ALL
DATAID_WMS_TASK_STATUS_SUSPEND
DATAID_WMS_TASK_STATUS_SUSPEND_ALL
DATAID_WMS_TASK_STATUS_UNSPLIT_SCREEN
DATAID_WMS_TASK_USERS_ADD_ACCOUNT
DATAID_WMS_TASK_USERS_CHANGE_ACCESS
DATAID_WMS_TASK_USERS_CHANGE_FULL_NAME
DATAID_WMS_TASK_USERS_CHANGE_PASSWORD
DATAID_WMS_TASK_USERS_DELETE_ACCOUNT
DATAID_WMS_TASK_VDI_DISABLE_FAIL_DURATION
DATAID_WMS_TASK_VDI_DISABLE_FAIL_ERROR
DATAID_WMS_TASK_VDI_DISABLE_START
DATAID_WMS_TASK_VDI_DISABLE_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_ENABLE_FAIL_DURATION
DATAID_WMS_TASK_VDI_ENABLE_FAIL_ERROR
DATAID_WMS_TASK_VDI_ENABLE_START
DATAID_WMS_TASK_VDI_ENABLE_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_FAIL_DURATION
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_FAIL_ERROR
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_START
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_VHD_LOCATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_DOMAIN
DATAID_WMS_TASK_VDI_NEW_DESKTOP_FAIL_DURATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_FAIL_ERROR
DATAID_WMS_TASK_VDI_NEW_DESKTOP_START
DATAID_WMS_TASK_VDI_NEW_DESKTOP_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_DOMAIN
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_FAIL_DURATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_FAIL_ERROR
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_START
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_VHD_LOCATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_VHD_LOCATION
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_DOMAIN
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_FAIL_DURATION
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_FAIL_ERROR
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_START
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_SUCCESS_DURATION
DATAID_WMS_UI_EXCEPTION
DataMemberAttribute
DataPointStrings
dataValue
DC3641D5-F6BE-4950-BCD1-5D9F4881B28E
DebuggableAttribute
DebuggerNonUserCodeAttribute
DebuggerStepThroughAttribute
DebuggingModes
DefaultCmdletTimeoutInSeconds
DefaultIfEmpty
DefaultMaxProjectionViewers
DefaultMemberAttribute
DefaultPollingPeriodInSeconds
defaultSaveCredential
defaultTimeoutForPowershellConnection
DefaultTimeoutForPowershellConnection
defaultValue
DefaultVirtualDesktopSubPath
defaultVirtualMachineMemorySize
defaultVirtualMachineProcessorCount
DEL "%USERPROFILE%\Desktop\COMPLETECUSTOMIZATION.LNK"
DelegatedConstructor`1
DelegatedCredentials`1
DelegatedGetPeerList
DeleteSubKey
DeleteUrlAcl
Description
description
description cannot be null and its length cannot be greater than 
DescriptionLength
Deserialize
DesktopMonitoringEventArgs
destCollection
DEVICE_NOT_READY
deviceCount
devicestoredirect:s:
Dictionary`2
Differencing
DirectoryEntry
DirectoryNotFoundException
Disable
disable full window drag:i:0
disable menu anims:i:0
disable wallpaper:i:0
DisableDiskProtection
DisableVirtualDesktop
DisableVirtualDesktopCommand
DisableVirtualIpPerSession
Discard
DisconnectIM
DisconnectRequest
DisconnectRequestBody
DisconnectResponse
DisconnectResponseBody
DisconnectResponseT
DisconnectT
DisconnectTime
DiskProtectionAlreadyInstalled
DiskProtectionMode
diskProtectionMode
DiskProtectionNotInstalled
DisMount-VHD -Path '{0}'
Dispose
disposed
disposing
domain
domainId
DomainJoin4
domainName
DomainNameRegexInvalidChars
DomainNameRegexPeriodSpace
DoWorkInParallel
drivestoredirect:s:*
DropPii
DropPiiField
DuplicateAutoLogonUsers
durationDataId
durationSeconds
dwEncodingType
dwEventType
dwFlags
dwOptions
dwTimeout
Dynamic
E_NOTIMPL
E_OUTOFMEMORY
E_POINTER
eAccountStatus
eAction
EAlertSeverity
EAlertStatus
EAutoLogonAccountStatus
EAutoLogonConfiguration
EAutomaticUpdateMode
eBitmapSize
ED4824AF-DCE4-45A8-81E2-FC7965083634
EDeviceType
eDiscoverType
EDiscoverType
EDiskProtectionMode
EDisplayOrientation
eDisplayOrientation
EDisplayOrientationPS
eDisplayRotation
Edition
EditorBrowsableAttribute
EditorBrowsableState
EEM_Connector_Oobe
EEM_Connector_ServiceStartup
EEM_ResetAutoLogon
EEM_Role_Oobe
EEM_Role_ServiceStartup
EEM_Staging
EEM_WmsShell
EExecutionMode
EHostNameType
EIdentifyStationAction
Element
ElementName
eMgmtType
EmitDefaultValue
Enable
enable
enableAdminOrchestration
EnableChat
EnableDesktopMonitoring
EnableDiskProtection
EnabledState
EnableLocalAdministratorBlock
EnableProjectAll
EnableProjectToAll
EnableVirtualDesktop
EnableVirtualDesktopCommand
EnableVirtualIpPerSession
EnableWebLimitingAll
EnableWmsScheduledUpdateInvalidParams
enabling
encodedMessage
Encoding
EndInvoke
endpoint
EndpointAddress
endpointConfigurationName
endpointFormatString
EndpointNotFoundException
endpointPath
endpointType
EndsWith
Enqueue
Enter
Enumerable
EnumerateStationIDs
EnumerateUsersRequest
EnumerateUsersRequestBody
EnumerateUsersResponse
EnumerateUsersResponseBody
EnumerateUsersResponseT
EnumerateUsersT
Environment
eOperation
EOrchestrationThumbnailSize
EProcessState
ePropertyId
Equals
error
ERROR_BAD_FORMAT
ERROR_BAD_NETPATH
ERROR_BAD_USERNAME
ERROR_CANCELLED
ERROR_FILE_EXISTS
ERROR_INSUFFICIENT_BUFFER
ERROR_INVALID_DOMAIN_ROLE
ERROR_NO_SUCH_DOMAIN
ERROR_NO_SUCH_LOGON_SESSION
ERROR_RETRY
ERROR_SUCCESS
ERROR_UNTRUSTED_IP_WITH_DEFAULT_AUTH
ErrorCategory
errorDataId
ErrorReceivedEventArgs
ErrorRecord
EScheduledUpdateMode
EScheduleUpdateReturnState
EScheduleUpdatesReturnState
EScreenBroadcastState
estationAlertType
EStationAlertType
eStationAlertWmsAlertTypeTable
ESystemAlertType
esystemAlertType
eSystemAlertWmsAlertTypeTable
ETW_GROUP
EUsbStorageDeviceBlocking
EventFieldTags
EventHandler`1
EventKeywords
EventLevel
EventLog
eventName
EventNotificationServiceClass
EventSinkAlreadyUnregistered
EventSinkStillRegistered
EventSinkUsernamePasswordValidator
eventSourceName
EventSourceOptions
EventSourceSettings
EventTags
EventWaitHandle
EventWrite
eVirtualDesktopNotificationType
EVirtualDesktopNotificationType
EWmsMode
EWmsRemoteManagementHostType
EWmsRemoteManagementPropertyId
EWmsRemoteManagementType
EWX_FORCE
EWX_FORCEIFHUNG
EWX_HYBRID_SHUTDOWN
EWX_POWEROFF
EWX_REBOOT
EWX_RESTARTAPPS
EWX_SHUTDOWN
exception
Exception: {0}, StackTrace: {1}
exceptionHandlerAction
ExceptionHandlerCoreCall
exceptionMessage
Exclude
executableName
ExecuteCoreCall
exeName
exePath
Existing
Exists
extensionDataField
ExtensionDataObject
ExternalException
ExtractHostName
Failed to create virtual switch
Failed to get public documents folder path
FaultContractAttribute
FaultException
fBootToConsoleModeEnabled
fDesktopMonitoringEnabled
feature
Feature
fEnable
FileAccess
FileDescription
FileMode
fileName
FileNameProperty
FileNotFoundException
FileShare
FileStream
FileVersion
First
fIsAllowedList
fIsRailField
Fixed
flags
FlagsAttribute
FLASHW_ALL
FLASHW_CAPTION
FLASHW_STOP
FLASHW_TIMER
FLASHW_TIMERNOFG
FLASHW_TRAY
FlashWindow
FlashWindowEx
FlashWindowFlags
FlashWInfo
FOLDERID_PublicDocuments
ForceMinimized
ForEach
FormatUserName
fqdnMap
fqdnServer
fqdnTarget
FreeCoTaskMem
FreeHGlobal
FromBase64String
fSave
fSingleSessionPerUser
full address:s:
FullMogGroupName
fullName
FullName
FullName cannot be null and its length cannot be greater than 
FullNameBuf
FullNameBufLength
FullNameLength
FullScreen
Func`2
function
function 
Function 
Function Dismount-RegistryHive {
Function Mount-RegistryHive {
Function Test-IsNetworkLocation {
fUseHardwareGpu
gatewaycredentialssource:i:0
gatewayhostname:s:
gatewayprofileusagemethod:i:0
gatewayusagemethod:i:2
GeneratedCodeAttribute
GenerateRandomPassword
GenerateRandomPassword failed
get_AddressFamily
get_AddressList
get_AdministratorPassword
get_AdministratorUser
get_AlertSeverity
get_AlertStatus
get_AlertType
get_All
get_Assembly
get_AttemptingToConnect
get_AutoLogonNameIsInvalid
get_AutoLogOnPassword
get_AutoLogOnUserName
get_AutomaticUpdateMode
get_BaseObject
get_BitField
get_Blanked
get_BlankedMessage
get_BootMode
get_BootToConsoleMode
get_BootToConsoleModeEnabled
get_Capacity
get_Certificates
get_Channel
get_ChatId
get_ClientCredentials
get_ClientName
get_CloudServers
get_CollabId
get_Commands
get_ComputerName
get_Configuration
get_ConnectionCount
get_ConnectionError
get_ConnectionErrorMessage
get_ConnectionState
get_ConnectionString
get_ConnectionType
get_ConvertWindowsImagePowershellScript
get_CoreCallFailed
get_Count
get_CreateTime
get_Credentials
get_Culture
get_Current
get_CurrentCulture
get_CurrentPrincipal
get_CustomScript
get_CustomScriptFullPath
get_CustomScriptMaxRuntimeMinutes
get_Data
get_DefaultValue
get_Description
get_DesktopMonitoringEnabled
get_DeviceCount
get_DeviceCounts
get_DeviceType
get_DeviceTypes
get_DiscoverType
get_DiskProtectionAlreadyInstalled
get_DiskProtectionMode
get_DiskProtectionNotInstalled
get_DisplayOrientation
get_Domain
get_DomainName
get_DomainOrWorkgroupName
get_DoWork
get_DuplicateAutoLogonUsers
get_EnableWmsScheduledUpdateInvalidParams
get_Error
get_ErrorCode
get_EStationAlertWmsAlertTypeTable
get_ESystemAlertWmsAlertTypeTable
get_eventSink
get_EventType
get_Exception
get_ExceptionProperty
get_ExcludedCloudServers
get_ExcludedManagedServers
get_ExcludedMultiPointServers
get_ExcludedPersonalComputers
get_ExtensionData
get_fIsRail
get_FullName
get_GetWmsUserInvalidParams
get_Handle
get_HasDetail
get_HasNonLoopbackAdapter
get_Host
get_HourToScheduleUpdates
get_hr
get_HResult
get_Id
get_id
get_Identity
get_InnerException
get_InputFilePath
get_Installed
get_InvalidAccountInfo
get_InvalidDiskProtectionState
get_InvalidInvitationString
get_InvalidWindowsVersion
get_InvariantCulture
get_IpAddresses
get_IsAdmin
get_IsAdministrativeUserAccount
get_IsAdminOrchestrationEnabled
get_IsAllowList
get_IsAllowRemoteManagementOn
get_IsAutoLogOn
get_IsBitmapUnavailable
get_IsChatEnabled
get_IsDesktopMonitoringAllowed
get_IsDisconnected
get_IsInLimiting
get_IsIPPerSessionEnabled
get_IsLocked
get_IsMOGUser
get_IsOrchestratable
get_IsPresent
get_IsPrivate
get_IsRail
get_IsScheduleUpdateEnabled
get_IsSingleSessionPerUser
get_IsSplit
get_IsUsbStorageBlocked
get_IsVirtualMachine
get_IsWebLimited
get_Item
get_Key
get_Length
get_LicenseCount
get_LockWmsSessionInvalidParams
get_LoggedInUserName
get_MachineName
get_MainWindowHandle
get_ManagedServerFqdn
get_ManagedServerIpAddresses
get_ManagedServers
get_ManagedSystemsType
get_MaxTimeAllowedForCustomScript
get_Message
get_MonitoringSystemType
get_MultiPointServers
get_Name
get_NetJoinStatus
get_NewLine
get_NotificationMessage
get_NotificationType
get_Now
get_OpenWmsAppInvalidParams
get_OperatingMode
get_OperatingSystem
get_OSVersion
get_Parameters
get_ParamName
get_ParentVirtualMachineName
get_Password
get_PeerServerFqdn
get_PeerServerIpAddress
get_PersonalComputers
get_ProcessId
get_Progress
get_Properties
get_ProtocolVersion
get_PublishedSessionNotFound
get_RegKey
get_RemoteConnectionServerName
get_RemoveWmsUserInvalidParams
get_ResourceManager
get_Restart
get_Results
get_RetryAttemptToConnect
get_ReturnState
get_ScheduledUpdateMode
get_ScheduleUpdateCustomScript
get_ScheduleUpdateRunWU
get_ScheduleUpdatesReturnState
get_ScreenBroadcastState
get_Security
get_Server
get_ServerFqdn
get_ServerName
get_ServiceCertificate
get_SessionHostFqdn
get_SessionHostServer
get_SessionId
get_Sessions
get_SetWmsStationInvalidHostname
get_SetWmsStationInvalidParams
get_SetWmsUserInvalidParams
get_ShouldProcessDisableWmsDiskProtection
get_ShouldProcessEnableWmsDiskProtection
get_ShouldProcessExitWmsSystem
get_ShouldProcessRemoveWmsSystem
get_ShouldProcessRemoveWmsUser
get_ShouldProcessRestartWmsSystem
get_ShouldProcessResumeWmsDiskProtection
get_ShouldProcessSuspendWmsDiskProtection
get_Singleton
get_Sites
get_StackTrace
get_state
get_State
get_StationHostFqdn
get_StationId
get_Status
get_Streams
get_Success
get_SuppressPrivacyNotification
get_SystemImage
get_SystemMode
get_TakeControlWindowTitleTemplate
get_TemplatePrefix
get_TemplateVirtualMachineGuid
get_ThumbnailBits
get_ThumbnailImage
get_TimeStampInUtc
get_TimeToScheduleUpdates
get_TotalSeconds
get_Transport
get_Unicode
get_UniqueId
get_UpdateStartHour
get_UseHardwareGpu
get_UserDomain
get_UserName
get_UserNameAuthentication
get_UserType
get_UtcNow
get_UTF8
get_Value
get_Version
get_VhdLocation
get_VirtualDiskPath
get_VirtualMachineFqdn
get_VirtualMachineHostName
get_VirtualMachineId
get_VirtualMachineName
get_VMType
get_WebServiceCallFailed
get_WindowId
get_WindowsEdition
get_WindowStationName
get_WmsAlertSeverityTable
get_WmsClientVersion
get_WmsCmdlet3DllPath
get_WmsServerVersion
get_wsDescription
get_wsDomain
get_wsFullName
get_wsName
get_wsUserName
get_wsWinStation
GetAlerts
GetAllSessionsRequest
GetAllSessionsRequestBody
GetAllSessionsResponse
GetAllSessionsResponseBody
GetAllSessionsResponseT
GetAllSessionsT
GetAscii
GetAvailableServerList
GetBytes
GetChatEventSink
GetChatIdRequest
GetChatIdRequestBody
GetChatIdResponse
GetChatIdResponseBody
GetChatIdResponseT
GetChatIdT
GetClientProxy
GetClientVersionRequest
GetClientVersionRequestBody
GetClientVersionResponse
GetClientVersionResponseBody
GetClientVersionResponseT
GetClientVersionT
GetConnectionCount
GetConnectionState
GetConnectionString
GetCoreEventSink
GetCredential
GetCurrent
GetCurrentActivity
GetCurrentProcess
GetDefaultRDSConnectionString
GetDefaultVhdLocation
GetDiskProtectionMode
GetDiskProtectionNeededSpaceInGb
GetDisplayOrientation
GetDisplayRotation
GetDomain
GetEndpointCert
GetEnumerator
GetExtension
GetExternalEthernetAdapter
GetFolderPath
GetForegroundWindow
GetFreeSpaceNeeded
GetFullyQualifiedHostName
GetHostEntry
GetHostName
GetHttpProxy
GetIMultiPointCertificateRequestProxy
GetIMultiPointChatProxy
GetIMultiPointDiskProtectionProxy
GetIMultiPointServerProxy
GetIMultiPointSessionProxy
GetIMultiPointStationProxy
GetIMultiPointUserManagerProxy
GetInstances
GetLastWin32Error
GetLengthSid
GetLicenseCount
GetLocalBuiltInAdministratorName
GetLocalServer
GetManagedServerList
GetManagedServerListFromCollection
GetManagedServers
GetManagedSystemsType
GetMode
GetMultiPointProtocolVersion
GetNetJoinStatusRequest
GetNetJoinStatusRequestBody
GetNetJoinStatusResponse
GetNetJoinStatusResponseBody
GetNetJoinStatusResponseT
GetNetJoinStatusT
GetNextStationIdentifier
GetOfflineDomainJoinBlob
GetPeerWmsConnectorListRequest
GetPeerWmsConnectorListRequestBody
GetPeerWmsConnectorListResponse
GetPeerWmsConnectorListResponseBody
GetPeerWmsConnectorListResponseT
GetPeerWmsConnectorListT
GetPeerWmsServerListRequest
GetPeerWmsServerListRequestBody
GetPeerWmsServerListResponse
GetPeerWmsServerListResponseBody
GetPeerWmsServerListResponseT
GetPeerWmsServerListT
GetProcessById
GetProcessMainWindow
GetProcessOwnerName
GetPropertyValue
GetProtocolVersion
GetReaderAtDetailContents
GetRemoteConnectionStringFile
GetReplacementSslCertificateRequest
GetReplacementSslCertificateRequestBody
GetReplacementSslCertificateResponse
GetReplacementSslCertificateResponseBody
GetReplacementSslCertificateT
GetRunningApps
GetScheduledUpdateConfiguration
GetScheduledUpdateSettingsRequest
GetScheduledUpdateSettingsRequestBody
GetScheduledUpdateSettingsResponse
GetScheduledUpdateSettingsResponseBody
GetScheduledUpdateSettingsT
GetScreenState
GetServerSettings
GetServerVersionRequest
GetServerVersionRequestBody
GetServerVersionResponse
GetServerVersionResponseBody
GetServerVersionResponseT
GetServerVersionT
GetSession
GetSessionAgentStatus
GetSessionFlags
GetSessionInfos
GetSessionRunningAppsRequest
GetSessionRunningAppsRequestBody
GetSessionRunningAppsResponse
GetSessionRunningAppsResponseBody
GetSessionRunningAppsResponseT
GetSessionRunningAppsT
GetSitesInInternalFormat
GetSKU
GetStation
GetStationAlerts
GetStationAlertStatus
GetStationAutoLogonInformationRequest
GetStationAutoLogonInformationRequestBody
GetStationAutoLogonInformationResponse
GetStationAutoLogonInformationResponseBody
GetStationAutoLogonInformationT
GetStationDeviceInformation
GetStationFriendlyNameRequest
GetStationFriendlyNameRequestBody
GetStationFriendlyNameResponse
GetStationFriendlyNameResponseBody
GetStationFriendlyNameResponseT
GetStationFriendlyNameT
GetStationInformationRequest
GetStationInformationRequestBody
GetStationInformationResponse
GetStationInformationResponseBody
GetStationInformationResponseT
GetStationInformationT
GetStations
GetStationServerNameRequest
GetStationServerNameRequestBody
GetStationServerNameResponse
GetStationServerNameResponseBody
GetStationServerNameResponseT
GetStationServerNameT
GetStationSplitScreenInformation
GetString
GetSubKeyNames
GetSystem
GetSystemAlerts
GetSystemAlertStatus
GetSystemMode
GetSystemOperationMode
GetSystemShortName
GetTempFileName
GetThumbnailBitsRequest
GetThumbnailBitsRequestBody
GetThumbnailBitsResponse
GetThumbnailBitsResponseBody
GetThumbnailBitsResponseT
GetThumbnailBitsT
GetTypeFromHandle
GetUnattendConfigurations
GetUnicode
GetUpdateSchedule
GetUseHardwareGpu
GetValues
GetVirtualDesktop
GetVirtualDesktopCommand
GetVirtualDesktopState
getVirtualDiskPath
getVirtualDiskTypeQueryFormatString
GetVirtualMachineHostnameRequest
GetVirtualMachineHostnameRequestBody
GetVirtualMachineHostnameResponse
GetVirtualMachineHostnameResponseBody
GetVirtualMachineHostnameT
GetVirtualMachineIpAddressRequest
GetVirtualMachineIpAddressRequestBody
GetVirtualMachineIpAddressResponse
GetVirtualMachineIpAddressResponseBody
GetVirtualMachineIpAddressT
GetVirtualMachineProperty
Get-VMSwitch -Name WMS
Get-WindowsFeature
GetWmiInstances
GetWmsAlertSeverity
GetWmsAlertType
GetWMSConnectionString
GetWmsUserInvalidParams
GetWmsWebLimitingRequest
GetWmsWebLimitingRequestBody
GetWmsWebLimitingResponse
GetWmsWebLimitingResponseBody
GetWmsWebLimitingResponseT
GetWmsWebLimitingT
grfSession
GroupNameRegexInvalidChars
GroupNameRegexPeriodSpace
guestDomain
guestDomainJoined
guidChatId
guidDestChatId
gwmi MSVM_ComputerSystem -namespace "root\virtualization\v2"
gwmi MSVM_ComputerSystem -namespace "root\virtualization\v2" | where {{ $_.ElementName -eq '{0}' }} 
handle
HandleIdentifyExceptions
HashPii
HashPiiField
hbmBanner
hCertStore
Helping {0}
hFile
hhctrl.ocx
HhDisplayTopic
high resolution mouse:i:0
hInstance
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows MultiPoint Server
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SQMClient\Windows
HKEY_LOCAL_MACHINE\Software\Microsoft\Virtual Machine\Guest\Parameters
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server\Remote Management
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server\Version
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server\Virtual Desktops
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\Windows Error Reporting
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\Windows Error Reporting\Consent
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows MultiPoint Server
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server
hObject
hostAndGuestDomainDiffer
hostDomainJoined
hostFqdn
Hostname
hostname
HostnameList
hostnameList
hostNamePunyCode
hostNameType
hostNameUnicode
HostSystem
HostType
hrError
hResult
HRESULT_ERROR_ACCESS_DENIED
HRESULT_ERROR_BAD_FILE_TYPE
HRESULT_ERROR_DISK_FULL
HRESULT_ERROR_FILE_NOT_FOUND
HRESULT_ERROR_INVALID_ACL
HRESULT_ERROR_INVALID_PARAMETER
HRESULT_ERROR_NO_TOKEN
HRESULT_ERROR_NOT_FOUND
HRESULT_ERROR_NOT_SUPPORTED
HRESULT_ERROR_PATH_NOT_FOUND
HRESULT_ERROR_TIMEOUT
HRESULT_FROM_WIN32
HRESULT_RPC_E_DISCONNECTED
HRESULT_RPC_S_CALL_CANCELLED
HRESULT_RPC_S_CALL_FAILED
HRESULT_RPC_S_SERVER_UNAVAILABLE
HRESULT_WS_E_ENDPOINT_UNREACHABLE
HRESULT_WS_E_OPERATION_TIMED_OUT
hrField
hServer
HtmlHelp
HtmlHelp_DisplayTopic
HtmlHelpW
hToken
http://
http://{0}:5985/wsman
http://MultiPoint
http://MultiPointa
http://MultiPointc
http://MultiPointI
http://MultiPointK
http://MultiPointS
http://MultiPointT
http://schemas.microsoft.com/powershell/Microsoft.PowerShell
http://schemas.microsoft.com/powershell/WMSReserved
HttpClientCredentialType
HttpProxyCredentialType
https
HttpTransportSecurity
HubMissingRequiredDevice
hwndParent
Hyper-V, RDS-Virtualization, RSAT-Hyper-V-Tools
Hyper-V\Virtual Hard Disks
HyperVFeatureID
IAsyncResult
IChannel
IClientChannel
ICommunicationObject
IconIndex
IconPath
IContextChannel
Identify
IdentifySessionRequest
IdentifySessionRequestBody
IdentifySessionResponse
IdentifySessionResponseBody
IdentifySessionResponseT
IdentifySessionT
IdentifySessionWrapper
IdentifyStationRequest
IdentifyStationRequestBody
IdentifyStationResponse
IdentifyStationResponseBody
IdentifyStationResponseT
identifyStationState
IdentifyStationT
idField
IDictionary
IDisposable
idleTime
IdnMapping
idPrimaryStation
idProcess
idProgress
idStation
idStudentSession
idTeacherSession
idWindow
IEnumerable`1
IEnumerator
IEnumerator`1
IExtensibleDataObject
IExtensibleObject`1
if (($Passthru) -and (![string]::IsNullOrEmpty($vhdFinalPath)) -and (Test-Path $vhdFinalPath)) {
IFormatProvider
Ignoring {0} calling UnregisterChatEventSink on server {1}
Ignoring {0} calling UnregisterCoreEventSink on server {1}
IIdentity
ImageSysprepState
iMaxViewers
Import
import-module -Name 
ImportModules
ImportTypeMapping
ImportVirtualDesktopCommand
ImportVirtualDesktopTemplate
ImportWmsVirtualDesktop
IMultiPointCertificateRequest
IMultiPointCertificateRequest.RequestSslCertificate
IMultiPointCertificateRequestChannel
IMultiPointChat
IMultiPointChat.Connect
IMultiPointChat.Disconnect
IMultiPointChat.GetChatId
IMultiPointChat.SendError
IMultiPointChat.SendMsg
IMultiPointChatChannel
IMultiPointChatO
IMultiPointCoreEventSink
IMultiPointCoreEventSink)
IMultiPointCoreEventSinkChannel
IMultiPointCredentialRequest
IMultiPointCredentialRequest.RequestWmsControlCredentials
IMultiPointCredentialRequest.SetSslCertificate
IMultiPointCredentialRequestChannel
IMultiPointCredentialRequestW
IMultiPointDiskProtection
IMultiPointDiskProtection.GetScheduledUpdateSettings
IMultiPointDiskProtection.SetScheduledUpdateSettings
IMultiPointDiskProtectionChannel
IMultiPointDiskProtectionF
IMultiPointServer
IMultiPointServer.GetAllSessions
IMultiPointServer.GetClientVersion
IMultiPointServer.GetNetJoinStatus
IMultiPointServer.GetPeerWmsConnectorList
IMultiPointServer.GetPeerWmsServerList
IMultiPointServer.GetReplacementSslCertificate
IMultiPointServer.GetServerVersion
IMultiPointServer.GetVirtualMachineHostname
IMultiPointServer.GetVirtualMachineIpAddress
IMultiPointServer.GetWmsWebLimiting
IMultiPointServer.LoadWindowsEdition
IMultiPointServer.OnboardVirtualDesktop
IMultiPointServer.RegisterChatEventSink
IMultiPointServer.RegisterCoreEventSink
IMultiPointServer.SetReplacementSslCertificate
IMultiPointServer.ValidateAutoLogonAccount
IMultiPointServerChannel
IMultiPointServerM
IMultiPointSession
IMultiPointSession.ConfigureWebLimitingAll
IMultiPointSession.CurrentActivity
IMultiPointSession.GetSessionRunningApps
IMultiPointSession.GetThumbnailBits
IMultiPointSession.IdentifySession
IMultiPointSession.LockSession
IMultiPointSession.RunFileSession
IMultiPointSession.ShareDesktop
IMultiPointSession.ViewDesktop
IMultiPointSessionChannel
IMultiPointSessionP
IMultiPointStation
IMultiPointStation.GetStationAutoLogonInformation
IMultiPointStation.GetStationFriendlyName
IMultiPointStation.GetStationInformation
IMultiPointStation.GetStationServerName
IMultiPointStation.IdentifyStation
IMultiPointStation.SetStationFriendlyName
IMultiPointStationChannel
IMultiPointStationI
IMultiPointSystemOnlineEventSink
IMultiPointSystemOnlineEventSink.OnManagedServerOfflineNotify
IMultiPointSystemOnlineEventSink.OnManagedServerOnlineNotify
IMultiPointSystemOnlineEventSink.OnNewServerCertificateReady
IMultiPointSystemOnlineEventSinkChannel
IMultiPointUserManager
IMultiPointUserManager.AddUser
IMultiPointUserManager.EnumerateUsers
IMultiPointUserManager.RemoveUser
IMultiPointUserManager.SetUserInfo
IMultiPointUserManagerChannel
IMultiPointUserManagerI
inAdminGroup
InAuthBuffer
InAuthBufferSize
Include
IncomingCompressedBytes
IndexOfAny
infoClass
InitializeArray
Initializing
InjectUnattendFiles
InjectXToken
innerException:
INotifyPropertyChanged
Input parameter description is null.
Input parameter fullName is null.
inputFilePath
inputString
inputUnattendFile
Install
installIntegrationServices
InstanceContextMode
Interlocked
InternalName
IntPtr
Invalid disk-protection state.
Invalid Scheduled Update Mode state.
InvalidAccountInfo
InvalidDiskProtectionState
invalidHostnameCharacters
InvalidInvitationString
InvalidOperationException
InvalidWindowsVersion
invitation
IOException
IpAddressListCommaDelimited
IPHostEntry
IPrincipal
IsAdministrativeUserAccount
IsAdminOrchestrationMode
IsAdminSession
isAllowList
IsBootToConsoleMode
IsConfigurationEnabled
isConfigurationEnabled
isDesktopMonitoringEnabled
isDisconnected
IsForegroundWindow
IsHostDomainJoined
isHostJoinedToDomain
IsHypervisorPresent
isInLimiting
IsInRole
IsInstalled
isInstalled
IsLocalIPAddress
IsLocalMachine
isLocked
IsLockedSession
isLoopbackStation
IsMogSession
IsMultiPointProtocolVersionSupported
IsNullOrEmpty
IsNullOrWhiteSpace
IsPolicyEnabled
isPrivate
IsRequired
IsScheduleUpdateEnabled
isScheduleUpdateEnabled
IsServiceRunning
IsSessionIdValid
IsSessionWebLimited
isSingleSessionPerUser
IsStationIdValid
IsSuppressPrivacyNotificationSet
isSuppressPrivacyNotificationSet
IsUsbStorageDeviceBlocked
IsUserAuthorized
IsUserInAdminGroup
IsUserInAdminGroup failed
IsValidDomainUser
IsVirtualDesktopEnabled
IsVirtualIpPerSessionEnabled
IsVolatile
IsWellFormedOriginalString
IsWellFormedOriginalString returns false
IsWrapped
ItemName
ItemNotFoundException
ITerminalServer
ITerminalServerHandle
ITerminalServicesManager
ITerminalServicesSession
j[i({
Kerberos
kernel32
kernel32.dll
KeyboardOrMouseFoundOnRootHub
KeyValuePair`2
kmloop
Landscape
LandscapeFlipped
Large
lastAuthenticationError
LastIndexOf
LastInputTime
lastWritten_highDateTime
lastWritten_lowDateTime
LaunchExecutable
LegalCopyright
level
LicenseConfiguration
LicenseCount
licenseCount
List`1
Listening
LOAD_LIBRARY_AS_DATAFILE
LoadLibraryEx
LoadString
LoadWindowsEditionRequest
LoadWindowsEditionRequestBody
LoadWindowsEditionResponse
LoadWindowsEditionResponseBody
LoadWindowsEditionResponseT
LoadWindowsEditionT
LOCAL
LocalComputerName
localhost -G 
LocalMultiPointServer
LocalServerHandle
lockMessage
LockSessionRequest
LockSessionRequestBody
LockSessionResponse
LockSessionResponseBody
LockSessionResponseT
LockSessionT
LockWmsSessionInvalidParams
loggedInUserName
LoggedInUserName
LogOffConsoleSession
LogOffSession
LookupAccountSid
Loopback
LOOPBACK_ADAPTER_SERVICE_NAME
LoopbackAdaptersError
lpBuffer
lpDcName
lpDomain
lpFileName
lpMachineAccountOU
lpMachineName
lpName
lpSystemName
LSA_STRING
LsaConnectUntrusted
LsaDeregisterLogonProcess
LsaDeregisterLogonProcess in CredUIPromptForWindowsCredentials() failed, error code: {0}. May cause memory leak.
LsaHandle
LsaLookupAuthenticationPackage
LSAString
LsaStringWrapper
lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet
m_controlPassword
m_fqdnSource
m_fqdnToChatEventSink
m_fqdnToCoreEventSink
m_fqdnToICertificateRequestClient
m_fqdnToIChatClient
m_fqdnToIDiskProtectionClient
m_fqdnToIServerClient
m_fqdnToISessionClient
m_fqdnToIStationClient
m_fqdnToIUserManagerClient
m_MultiPointCertStore
m_wsHttpBinding
m_wsHttpsBinding
MacAddress
machineName
Maintenance
Managed Servers
MANAGED_SERVERS
managedServer
ManagedServerCollection
ManagedServerEventArgs
managedServerList
ManagedServerOnlineRegistryPath
managedServersRegKey
ManagedSystemOffline
ManagedSystems
managedSystemsType
ManagedSystemsType should be one of CloudServers, MultiPointServers or PersonalComputers
ManagedSystemsType should be one of MultiPointServers & PersonalComputers
ManagedSystemTypes
ManagementBaseObject
ManagementClass
ManagementObject
ManagementObjectCollection
ManagementObjectEnumerator
ManagementObjectSearcher
ManagementPath
ManagementScope
MANAGER
ManagerExeFileName
Mandatory
ManualResetEvent
manualResetEvent
MarkPii
MarkReady
Marshal
Match
MAX_BUFFER
MaxAllowedTimeToRunCustomScriptInMinutes
Maximize
MaximumLength
maxTimeAllowedForCustomScript
maxViewers
MeasuresKeyword
MeasuresOptions
Medium
MemberAddedToGroup
MemberRemovedFromGroup
memory
MemoryStartupMB
message
MessageBodyMemberAttribute
MessageContractAttribute
MessageCredentialType
MessageParameterAttribute
MessageReceivedEventArgs
method
metric
Microsoft
Microsoft Corporation
Microsoft.Diagnostics.Telemetry
Microsoft.SharedComputing.Utils
Microsoft.Win32
Microsoft.Windows.RemoteDesktop.MultiPoint
Microsoft.Windows.ServerManager.Commands
Microsoft.Windows.ServerManager.PowerShell
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.Properties
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.Properties.Resources
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.Properties.Resources.resources
MicrosoftTelemetry
microsoftTelemetryTraits
MinAllowedTimeToRunCustomScriptInMinutes
Minimize
MinPowershellRunspaceIdleTimeout
module
moduleName
moduleName is null or empty
moduleNames
moduleNames is null or empty
Mog user is not applicable for the current system
MogUser
Monitor
MonitoringSystemType
MonitoringType
monitoringType
MonitorsWithoutPotentialStationHubs
MountImageAndExecuteScript
MountImageMode
MoveNext
mscoree.dll
mscorlib
MulticastDelegate
multimediaenableredirection:i:1
multipoint
MultiPoint Services Certificates
MultiPoint/IMultiPointCertificateRequest
MultiPoint/IMultiPointChat
MultiPoint/IMultiPointChatEventSink/{0}/
MultiPoint/IMultiPointCoreEventSink/{0}/
MultiPoint/IMultiPointDiskProtection
MultiPoint/IMultiPointServer
MultiPoint/IMultiPointSession
MultiPoint/IMultiPointStation
MultiPoint/IMultiPointUserManager
multipoint1
multipoint1.WmsFaultType
MultiPointCertificateRequestClient
MultiPointChatClient
MultiPointChatEventSink
MultiPointCoreEventSinkClient
MultiPointCredentialRequestClient
MultiPointDiskProtectionClient
MultiPointEventSink
MultipointOperatorGroupName
MultiPointServerClient
MultiPointSessionClient
MultiPointStationClient
MultiPointSystemOnlineEventSinkClient
MultiPointTelemetryProviderName
MultiPointUserManagerClient
MultiPointVdi
MultiPointVdi.dll
MultiPointVdi.pdb
MultiPointVdi.psd1
MultiStation
Must be a domain user to create virtual desktop
Must specify a user name.
Name pfSuppressPrivacyNotificationSet
Name ValidateAutoLogonAccountResponseT
Name!GetVirtualMachineHostnameResponseT
Name"GetScheduledUpdateSettingsResponseT
Name"GetVirtualMachineIpAddressResponseT
Name"SetScheduledUpdateSettingsResponseT
Name#OnManagedServerOnlineNotifyResponseT
Name#OnNewServerCertificateReadyResponseT
Name$GetReplacementSslCertificateResponseT
Name$OnManagedServerOfflineNotifyResponseT
Name$RequestWmsControlCredentialsResponseT
Name$SetReplacementSslCertificateResponseT
Name&GetStationAutoLogonInformationResponseT
Namespace
namespace WIM2VHD {
NativeCredential
NativeCredentialFlags
NativeErrorCode
NativeMethods
NativeMethodsHelper
nBufferMax
nCmdShow
Needed space
neededSpace
Negotiate
NERR_BadDomainJoinInfo
NERR_BadOfflineJoinInfo
NERR_BASE
NERR_CantCreateJoinInfo
NERR_CantLoadOfflineHive
NERR_CantVerifyHostname
NERR_ConnectionInsecure
NERR_DS8DCNotFound
NERR_DS8DCRequired
NERR_JoinPerformedMustRestart
NERR_LDAPCapableDCRequired
NERR_NoJoinPending
NERR_NoOfflineJoinInfo
NERR_ProvisioningBlobUnsupported
NERR_TargetVersionUnsupported
NERR_ValuesNotSet
netapi32.dll
Netapi32.dll
NetApiBufferFree
NetProvisionComputerAccount
NETSETUP_PROVISION_REUSE_ACCOUNT
NetSetupDomainName
NetSetupUnjoined
NetSetupUnknownStatus
NetSetupWorkgroupName
NetUserModalsGet
NewGuid
newOrExistingServer
NewOrExistingServer
newStationUnattendFile
newTargetName
NewVirtualDesktopCommand
NewVirtualDesktopTemplateCommand
New-VMSwitch -Name WMS -NetAdapterInterfaceDescription '{0}'
NonDomainJoin/
NonDualMessageSecurityOverHttp
NoPotentialStationHubs
NormalLatency
NormalPersistence
NotConfigured
NotConnected
notificationMessage
NotificationMessage
NotImplementedException
NotReady
notUsed1
Nullable`1
NullReferenceException
object
ObjectGetOptions
ObjectQuery
oldTargetName
ole32.dll
on $([DateTime]::Now).
OnAssociateSessionWithStation
OnBeginIdentifySession
OnBeginIdentifyStation
OnboardVirtualDesktopRequest
OnboardVirtualDesktopRequestBody
OnboardVirtualDesktopResponse
OnboardVirtualDesktopResponseBody
OnboardVirtualDesktopResponseT
OnboardVirtualDesktopT
OnBootToConsoleModeChange
OnConfigureStation
OnDesktopMonitoringChange
OnDeviceAdded
OnDeviceRemoved
OnEndIdentifySession
OnEndIdentifyStation
OnEnterSplitScreen
OnErrorReceived
OnExitSplitScreen
OnGroupUpdated
OnManagedServerOffline
OnManagedServerOfflineNotifyRequest
OnManagedServerOfflineNotifyRequestBody
OnManagedServerOfflineNotifyResponse
OnManagedServerOfflineNotifyResponseBody
OnManagedServerOfflineNotifyT
OnManagedServerOnline
OnManagedServerOnlineNotifyRequest
OnManagedServerOnlineNotifyRequestBody
OnManagedServerOnlineNotifyResponse
OnManagedServerOnlineNotifyResponseBody
OnManagedServerOnlineNotifyT
OnMessageReceived
OnNewServerCertificateReadyRequest
OnNewServerCertificateReadyRequestBody
OnNewServerCertificateReadyResponse
OnNewServerCertificateReadyResponseBody
OnNewServerCertificateReadyT
OnPeerServerAdded
OnPeerServerDiscovered
OnPeerServerRemoved
OnProjectionStateChange
OnScheduledUpdateSettingsChanged
OnServiceControlSessionChange
OnSessionAgentReady
OnSessionBlocked
OnSessionConnecting
OnSessionDisconnected
OnSessionUnblocked
OnStationAdded
OnStationAlert
OnStationRemoved
OnSystemAlert
OnSystemModeChange
OnUserCreated
OnUserDeleted
OnUserUpdated
OnVirtualDesktopNotification
OnVirtualDesktopOnline
op_Equality
op_Explicit
op_GreaterThanOrEqual
op_Inequality
op_Subtraction
OpenEndpoint
OpenSubKey
OpenVirtualDesktop
OpenVirtualDesktopCommand
OpenWmsAppInvalidParams
OperationContractAttribute
OperationSystemProductType
option
optionalParameter
OrchestrationAppEventName
Order
OriginalFilename
OutgoingCompressedBytes
OutOfMemoryException
overrideAdminWarning
owfCredBlob
PackageName
PADPADP
param(
Parameter is null or empty
ParameterizedThreadStart
ParameterSetName
parentHandle
parentVirtualMachineName
PartOfDomainQuery
Passive
password
Password is wrong.
passwordForCert
Paused
Pausing
pAuthBuffer
pbstrDomain
pbstrUserName
pbstrVirtualMachineIpAddress
pcchMaxDomainame
pcchMaxPassword
pcchMaxUserName
pcLicenses)
pcMaxMinutesAllowedForCustomScript
pcSessionInfo
pdwDeviceCount
pdwInactiveTicks
pdwProvisionBinDataSize
pdwResult
peConfiguration
peCurrentBroadCastState"
peDisplayRotation#
PeerServerEventArgs
peIdentifyStationState
peMode
peNetJoinStatus
peReturnState
persist
PersistencyLevel
peSeverity
peSplitScreenState
peState
peStatus
peType
peUsbStorageDeviceBlocked
peUse
pEWmsRemoteManagementHostType
pfAdminOrchestrationMode
pfBootToConsoleMode$
pfDesktopMonitoringAllowed
pfEnabled&
pfHypervisorPresent"
pfIsAllowList
pfIsDisconnected
pfIsInLimiting
pfIsInstalled
pfIsLocked
pfIsPrivate
pfSingleSessionPerUser,
pfUseHardwareGpu
pgrfSession
pguidStudentChat
PhysicalAdapter
PhysicalDrive
pidNextStation
pidPrimaryStation%
pidSession
pidxSplitScreen
PipelineReader`1
piScheduledUpdateStartHour
Portrait
PortraitFlipped
Position
powershell
PowershellSchema
powershellScript
PowershellWmsEndpointSchema
ppbDataBits
pprgWmsSessionInfoWs
pprgWmsUsersWs
pprgwsWmsRunningAppWs
pProtocolVersion
pProvisionBinData
pProvisionTextData
ppSslCertificate
PresentationCore
PreviousState
prgData
prgData[
prgWmsRunningAppWs<
prgWmsSessionInfoWs=
prgWmsSessionInfoWs5
prgwsConnectorList
prgwsIpAddressList
prgwsServerList
primaryStationID
procesId
processId
ProcessIdField
ProcessorCount
ProcessQueue
ProcessRecord
ProcessSessionCallback`1
ProcessStartInfo
PRODUCT_MULTIPOINT_PREMIUM_SERVER
PRODUCT_MULTIPOINT_STANDARD_SERVER
ProductName
ProductVersion
Project
prompt
prompt for credentials on client:i:1
prompt is null or empty
promptcredentialonce:i:1
promptNow
property
PropertyChangedEventArgs
PropertyChangedEventHandler
PropertyData
PropertyDataCollection
protocolVersion
ProviderSectionName
proxy
PSCmdlet
PSCredential
psCredential
PSDataCollection`1
PSDataStreams
PSLibUtility
PSObject
pSslPort
PSUtility
pszCaptionText
pszDomainName
pszMessageText
pszPassword
pszPath
pszUserName
PtrToStringAuto
PtrToStringUni
PtrToStructure
PtrToStructureList
PublishedSessionNotFound
pullCookie
pullFreeSpaceNeeded
pwsAllowList
pwsBlockList
pwsCurrentActivity
pwsCustomScriptFullPath
pwsDomainName
pwsFriendlyName
pwsInvitation
pwsServerName
pwsSessionHost
pwsSslCertificateThumbprint
pwsVersion
pwsVirtualMachineHostname
pwsVirtualMachineId
pwsVirtualMachineName
pwsWindowsEdition
pwsWmsControlPassword
pwsWmsManagementPassword
pwszAccountName
pwszDomainName
pwszSystemName
query
QueryRemoteManagementProperty
QuerySessionInformationForString
QuerySessionInformationForStruct
QueryTemplateImageProperty
queueReady
RandomPasswordBufferLength
RDPFileContents
rdpTargetServerConnectionProperty
ReadAllText
ReadElementContentAsString
ReadInt32
ReadOnly
-ReadOnly
ReadWrite
RealtimeLatency
Reboot
Reboot the computer
rebootOnSuccessfulCompletion
rebootTask
redirectclipboard:i:1
redirectcomports:i:0
redirectdrives:i:1
redirectposdevices:i:0
redirectprinters:i:0
redirectsmartcards:i:0
refOutAuthBuffer
refOutAuthBufferSize
Refresh
RefreshCoreManager
RefreshStation
Regex
RegisterAsRemoteApp
RegisterChatEventSinkRequest
RegisterChatEventSinkRequestBody
RegisterChatEventSinkResponse
RegisterChatEventSinkResponseBody
RegisterChatEventSinkResponseT
RegisterChatEventSinkT
RegisterCoreEventSinkRequest
RegisterCoreEventSinkRequestBody
RegisterCoreEventSinkResponse
RegisterCoreEventSinkResponseBody
RegisterCoreEventSinkResponseT
RegisterCoreEventSinkT
Registry
RegistryKeyPermissionCheck
RegistryOptions
RegistryValueKind
regKey
RemapStations
Remote
remoteAddress
remoteapplicationcmdline:s:
remoteapplicationmode:i:1
remoteapplicationname:s:{2}
remoteapplicationprogram:s:||{1}
RemoteCertificateValidationCallback
remoteConnectionServerName
remoteControl
RemoteControlAction
remoteDesktopRemoteFxFirewall
remoteHostName
remoteHostName is null or empty
remotePassword
remoteServerConnectionName
remoteUserName
Remove
Remove user:
remove_BootToConsoleModeChanged
remove_DesktopMonitoringChanged
remove_ErrorReceived
remove_ManagedServerOffline
remove_ManagedServerOnline
remove_MessageReceived
remove_PeerServerAdded
remove_PeerServerDiscovered
remove_PeerServerRemoved
remove_PropertyChanged
remove_ScheduledUpdateSettingsChanged
remove_ServerShutdown
remove_SessionAgentReady
remove_SessionAssociatedWithStation
remove_SessionBlocked
remove_SessionProjectionStateChanged
remove_SessionStateChanged
remove_SessionUnblocked
remove_StationAdded
remove_StationAlertArrived
remove_StationConfigured
remove_StationDeviceAdded
remove_StationDeviceRemoved
remove_StationEnteredSplitScreen
remove_StationExitedSplitScreen
remove_StationRemoved
remove_StationSessionDisconnected
remove_SystemAlertArrived
remove_SystemModeChanged
remove_UserCreated
remove_UserDeleted
remove_UserGroupUpdated
remove_UserUpdated
remove_VirtualDesktopNotification
remove_VirtualDesktopOnline
RemoveCredential
RemoveFromAnyManagedServerList
RemoveFromManagedServerList
RemoveRemoteManagedComputer
RemoveUserRequest
RemoveUserRequestBody
RemoveUserResponse
RemoveUserResponseBody
RemoveUserResponseT
RemoveUserT
Remove-WindowsFeature
RemoveWmsUserInvalidParams
Replace
ReplyAction?http://MultiPoint/RemoteManagement/IMultiPointChat/PingResponse
ReplyAction[http://MultiPoint/RemoteManagement/IMultiPointCertificateRequest/GetProtocolVersionResponsef
ReplyAction[http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnProjectionStateChangeResponse
ReplyAction[http://MultiPoint/RemoteManagement/IMultiPointServer/SetSuppressPrivacyNotificationResponse
ReplyAction\http://MultiPoint/RemoteManagement/IMultiPointStation/GetStationAutoLogonInformationResponse
ReplyAction]http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBootToConsoleModeChangeResponse
ReplyAction]http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDesktopMonitoringChangeResponse
ReplyAction]http://MultiPoint/RemoteManagement/IMultiPointServer/IsSuppressPrivacyNotificationSetResponse
ReplyAction^http://MultiPoint/RemoteManagement/IMultiPointCertificateRequest/RequestSslCertificateResponse
ReplyAction^http://MultiPoint/RemoteManagement/IMultiPointStation/GetStationSplitScreenInformationResponse
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetScheduledUpdateSettingsResponse
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointDiskProtection/SetScheduledUpdateSettingsResponse
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointStation/BlockUsbStorageDevicesAllStationsResponse
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnManagedServerOnlineNotify
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnNewServerCertificateReady
ReplyAction`http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnVirtualDesktopNotificationResponse
ReplyAction`http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnManagedServerOfflineNotify
ReplyActionahttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnAssociateSessionWithStationResponse
ReplyActionahttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnServiceControlSessionChangeResponse
ReplyActionahttp://MultiPoint/RemoteManagement/IMultiPointStation/UnblockUsbStorageDevicesAllStationsResponse
ReplyActionBhttp://MultiPoint/RemoteManagement/IMultiPointChat/ConnectResponse
ReplyActionBhttp://MultiPoint/RemoteManagement/IMultiPointChat/SendMsgResponse
ReplyActionChttp://MultiPoint/RemoteManagement/IMultiPointServer/RebootResponse
ReplyActionDhttp://MultiPoint/RemoteManagement/IMultiPointChat/GetChatIdResponse
ReplyActionDhttp://MultiPoint/RemoteManagement/IMultiPointChat/SendErrorResponse
ReplyActiondhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnScheduledUpdateSettingsChangedResponse
ReplyActiondhttp://MultiPoint/RemoteManagement/IMultiPointCredentialRequest/RequestWmsControlCredentialsResponse
ReplyActionEhttp://MultiPoint/RemoteManagement/IMultiPointChat/DisconnectResponse
ReplyActionEhttp://MultiPoint/RemoteManagement/IMultiPointServer/ShutdownResponse
ReplyActionGhttp://MultiPoint/RemoteManagement/IMultiPointServer/EnableChatResponse
ReplyActionIhttp://MultiPoint/RemoteManagement/IMultiPointSession/LockSessionResponse
ReplyActionIhttp://MultiPoint/RemoteManagement/IMultiPointSession/ViewDesktopResponse
ReplyActionIhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/AddUserResponse
ReplyActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetSystemModeResponse
ReplyActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsChatEnabledResponse
ReplyActionJhttp://MultiPoint/RemoteManagement/IMultiPointSession/ShareDesktopResponse
ReplyActionJhttp://MultiPoint/RemoteManagement/IMultiPointStation/SplitStationResponse
ReplyActionKhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetAllSessionsResponse
ReplyActionKhttp://MultiPoint/RemoteManagement/IMultiPointSession/LogOffSessionResponse
ReplyActionKhttp://MultiPoint/RemoteManagement/IMultiPointStation/RemapStationsResponse
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetModeResponse
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/InstallResponse
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/SetModeResponse
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetLicenseCountResponse
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetScreenStateResponse
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointSession/RunFileSessionResponse
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/RefreshStationResponse
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/RemoveUserResponse
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetClientVersionResponse
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetNetJoinStatusResponse
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetServerVersionResponse
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/CurrentActivityResponse
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionFlagsResponse
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/IdentifySessionResponse
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointStation/IdentifyStationResponse
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/SetUserInfoResponse
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/UninstallResponse
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetUseHardwareGpuResponse
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetWmsWebLimitingResponse
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetUseHardwareGpuResponse
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetThumbnailBitsResponse
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopShareDesktopResponse
ReplyActionOhttp://MultiPoint/RemoteManagement/IMultiPointServer/LoadWindowsEditionResponse
ReplyActionOhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetBlockAllMessageResponse
ReplyActionOhttp://MultiPoint/RemoteManagement/IMultiPointSession/DisconnectSessionResponse
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/IsInstalledResponse
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsBootToConsoleModeResponse
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsHypervisorPresentResponse
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointSession/EnableProjectToAllResponse
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopLockingSessionResponse
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetDisplayRotationResponse
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetDisplayRotationResponse
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/EnumerateUsersResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDeviceAddedResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSystemAlertResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserCreatedResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserDeletedResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserUpdatedResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetPeerWmsServerListResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetSystemAlertStatusResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetBootToConsoleModeResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetDesktopMonitoringResponse
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationAutoLogonResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnGroupUpdatedResponseK
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationAddedResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationAlertResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetManagedSystemsTypeResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointServer/OnboardVirtualDesktopResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointServer/RegisterChatEventSinkResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointServer/RegisterCoreEventSinkResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointSession/ConfigureWebLimitingResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointSession/EnableWebLimitingAllResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointSession/LogOffConsoleSessionResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationServerNameResponse
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationServerNameResponse
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDeviceRemovedResponse
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointServer/IsSingleSessionPerUserResponse
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionAgentStatusResponse
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionRunningAppsResponse
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationAlertStatusResponse
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationInformationResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionBlockedResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationRemovedResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointServer/GetPeerWmsConnectorListResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointServer/SetSingleSessionPerUserResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointServer/UnregisterChatEventSinkResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointServer/UnregisterCoreEventSinkResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointSession/StopIdentifyingSessionResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/BlockUsbStorageDevicesResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationFriendlyNameResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationFriendlyNameResponse
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/StopIdentifyingStationResponse
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnExitSplitScreenResponse
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerAddedResponse
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsAdminOrchestrationModeResponse
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointServer/ValidateAutoLogonAccountResponse
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointSession/CloseSessionApplicationResponse
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointSession/ConfigureWebLimitingAllResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnConfigureStationResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEnterSplitScreenResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionUnblockedResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSystemModeChangeResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointServer/EnableVirtualIpPerSessionResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetVirtualMachineHostnameResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetAdminOrchestrationModeResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetNextStationIdentifierResponse
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointStation/UnblockUsbStorageDevicesResponse
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerRemovedResponse
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionAgentReadyResponse
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionConnectingResponse
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetFreeSpaceNeededResponse
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetVirtualMachineIpAddressResponse
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsDesktopMonitoringAllowedResponse
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointStation/IsUsbStorageDeviceBlockedResponse
ReplyActionXhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEndIdentifySessionResponse
ReplyActionXhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEndIdentifyStationResponse
ReplyActionXhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/ShutdownNotificationResponse
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnManagedServerOnlineResponse
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionDisconnectedResponse
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointCredentialRequest/SetSslCertificateResponse
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetReplacementSslCertificateResponse
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsVirtualIpPerSessionEnabledResponse
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetReplacementSslCertificateResponse
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationDeviceInformationResponse
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBeginIdentifySessionResponse
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBeginIdentifyStationResponse
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnManagedServerOfflineResponse
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerDiscoveredResponse
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnVirtualDesktopOnlineResponse
ReportException
ReportExceptionEx
request
requestedSystemMode
RequestSslCertificateRequest
RequestSslCertificateRequestBody
RequestSslCertificateResponse
RequestSslCertificateResponseBody
RequestSslCertificateResponseT
RequestSslCertificateT
RequestWmsControlCredentialsRequest
RequestWmsControlCredentialsRequestBody
RequestWmsControlCredentialsResponse
RequestWmsControlCredentialsResponseBody
RequestWmsControlCredentialsT
requireConfirmation
reserved
Reserved44Keyword
Reset
ResolveUnattendFile
resourceCulture
resourceMan
-restart
Restore
result
Resuming
retryAttemptToConnect
retryTurnOff
retStatus
returned
returnedBytes
returnReservedUserAccounts
returnStateUint
RMust either have an AutomaticUpdateMode other than none or supply a custom script.
root\cimv2
root\virtualization\v2
RPC_S_CALL_IN_PROGRESS
RPC_S_PROTSEQ_NOT_SUPPORTED
RSDSA
RtlZeroMemory
Run-Executable {
RunFileSessionRequest
RunFileSessionRequestBody
RunFileSessionResponse
RunFileSessionResponseBody
RunFileSessionResponseT
RunFileSessionT
RunPowershellCommand
RunPowershellCommandWithRetryOnNullRefException
runspace
runspace is null or empty
RunspaceConnectionInfo
RunspaceFactory
RuntimeCompatibilityAttribute
RuntimeException
RuntimeFieldHandle
RuntimeHelpers
RuntimeTypeHandle
RunVirtualDesktopScript
S-1-5-32-544
S-1-5-32-545
saveCredential
Saving
scenario
ScheduledUpdateSettingsEventArgs
schema
screenBroadCastState
script
scriptToExecuteAfterMount
scriptToExecuteBeforeMount
secur32.dll
secureString
SecureStringToGlobalAllocUnicode
SECURITY_MAX_SID_SIZE
SecurityAccessDeniedException
SecurityAction
SecurityEventCode
SecurityIdentifier
SecurityInfo
SecurityMode
SecurityPermissionAttribute
SecurityTokenException
Select * FROM Msvm_ExternalEthernetPort
Select * FROM Msvm_LANEndpoint WHERE ElementName='WMS'
Select * from SoftwareLicensingProduct
Select * from Win32_ComputerSystem
Select * from Win32_OperatingSystem
Select * from Win32_TerminalServiceSetting
Select * from Win32_TSGeneralSetting
Select * from Win32_TSLicenseKeyPack
Select * from Win32_TSLicenseServer
Select * from Win32_TSNetworkAdapterSetting
Select * from Win32_TSPublishedApplication
SelectQuery
sender
SendErrorRequest
SendErrorRequestBody
SendErrorResponse
SendErrorResponseBody
SendErrorResponseT
SendErrorT
SendIM
SendMsgRequest
SendMsgRequestBody
SendMsgResponse
SendMsgResponseBody
SendMsgResponseT
SendMsgT
SendVirtualDesktopTemplateProgressNotification
Serialize
serializerDict
server
Server
server port:i:3389
serverAction
ServerFeatureTaskAction
serverFqdn
serverHandle
serverList
serverName
ServerVersionKey
SERVICE_SESSION
ServiceBehaviorAttribute
ServiceContractAttribute
ServiceController
ServiceControllerStatus
ServiceControlSessionEventType
ServiceCredentials
serviceHost
ServiceHost
ServiceHostBase
ServiceName
serviceName
ServicePointManager
session bpp:i:32
SessionAssociatedWithStationEventArgs
SessionEventArgs
sessionHost
sessionHostServer
SessionHostType
SessionID
sessionId
sessionID
sessionId
sessionIdList
sessionIds
sessionInfo
SessionProjectionStateEventArgs
sessions
SessionSettingRegistryPath
SessionStateChangedEventArgs
set_AdministratorPassword
set_AdministratorUser
set_AlertSeverity
set_AlertStatus
set_AlertType
set_All
set_Arguments
set_AttemptingToConnect
set_AutoLogOnPassword
set_AutoLogOnUserName
set_AutomaticUpdateMode
set_BitField
set_Blanked
set_BlankedMessage
set_BootToConsoleMode
set_BootToConsoleModeEnabled
set_CancelTimeout
set_Certificate
set_ChatId
set_ClientCredentialType
set_ClientName
set_CloudServers
set_CollabId
set_ComputerName
set_Configuration
set_ConnectionCount
set_ConnectionError
set_ConnectionErrorMessage
set_ConnectionString
set_ConnectionType
set_CreateTime
set_Culture
set_CustomScript
set_CustomScriptFullPath
set_CustomScriptMaxRuntimeMinutes
set_CustomUserNamePasswordValidator
set_DefaultValue
set_Description
set_DesktopMonitoringEnabled
set_DeviceCount
set_DeviceCounts
set_DeviceType
set_DeviceTypes
set_DiscoverType
set_DiskProtectionMode
set_DisplayOrientation
set_Domain
set_DomainName
set_DomainOrWorkgroupName
set_DoWork
set_DtdProcessing
set_ErrorCode
set_EstablishSecurityContext
set_eventSink
set_EventType
set_ExceptionProperty
set_ExcludedCloudServers
set_ExcludedMultiPointServers
set_ExcludedPersonalComputers
set_ExtensionData
set_fIsRail
set_FullName
set_HasNonLoopbackAdapter
set_HourToScheduleUpdates
set_hr
set_id
set_IdleTimeout
set_InputFilePath
set_IpAddresses
set_IsAdmin
set_IsAdminOrchestrationEnabled
set_IsAllowList
set_IsAllowRemoteManagementOn
set_IsAutoLogOn
set_IsBackground
set_IsBitmapUnavailable
set_IsChatEnabled
set_IsDesktopMonitoringAllowed
set_IsDisconnected
set_IsInLimiting
set_IsIPPerSessionEnabled
set_IsLocked
set_IsMOGUser
set_IsOrchestratable
set_IsPrivate
set_IsRail
set_IsScheduleUpdateEnabled
set_IsSingleSessionPerUser
set_IsSplit
set_IsUsbStorageBlocked
set_IsVirtualMachine
set_IsWebLimited
set_Item
set_Key
set_Keywords
set_LicenseCount
set_LoggedInUserName
set_ManagedServerFqdn
set_ManagedServerIpAddresses
set_ManagedSystemsType
set_MaxReceivedMessageSize
set_MaxTimeAllowedForCustomScript
set_Message
set_MonitoringSystemType
set_MultiPointServers
set_Name
set_NegotiateServiceCredential
set_NetJoinStatus
set_NotificationMessage
set_NotificationType
set_OpenTimeout
set_OperatingMode
set_OperatingSystem
set_OperationTimeout
set_ParentVirtualMachineName
set_Password
set_PeerServerFqdn
set_PeerServerIpAddress
set_PersonalComputers
set_ProcessId
set_Progress
set_ProtocolVersion
set_ProxyAuthentication
set_ProxyCredentialType
set_Realm
set_RegKey
set_RemoteConnectionServerName
set_Restart
set_Results
set_RetryAttemptToConnect
set_ReturnState
set_Runspace
set_ScheduledUpdateMode
set_ScheduleUpdateCustomScript
set_ScheduleUpdateRunWU
set_ScheduleUpdatesReturnState
set_ScreenBroadcastState
set_Server
set_ServerCertificateValidationCallback
set_ServerFqdn
set_ServerName
set_SessionHostFqdn
set_SessionHostServer
set_SessionId
set_Sites
set_StartInfo
set_State
set_state
set_StationHostFqdn
set_StationId
set_SuppressPrivacyNotification
set_SystemImage
set_SystemMode
set_TemplatePrefix
set_TemplateVirtualMachineGuid
set_ThumbnailBits
set_ThumbnailImage
set_TimeStampInUtc
set_TimeToScheduleUpdates
set_UniqueId
set_UpdateStartHour
set_UseHardwareGpu
set_UserName
set_UserNamePasswordValidationMode
set_UserType
set_UseShellExecute
set_Value
set_VhdLocation
set_VirtualDiskPath
set_VirtualMachineFqdn
set_VirtualMachineHostName
set_VirtualMachineId
set_VirtualMachineName
set_VMType
set_WindowId
set_WindowsEdition
set_WmsClientVersion
set_WmsServerVersion
set_wsDescription
set_wsDomain
set_wsFullName
set_wsName
set_wsUserName
set_wsWinStation
SetAdminOrchestrationMode
SetBlockAllMessage
SetBooleanConfiguration
SetBooleanPolicy
SetBootToConsoleMode
setcreds
SetCurrentDashboardUser
SetDatapoint
SetDesktopMonitoring
SetDiskProtectionServiceInDiscardMode
SetDiskProtectionServiceInPassiveMode
SetDisplayOrientation
SetDisplayRotation
SetDword
SetError
SetForegroundWindow
SetManagedServerList
SetMode
SetPrincipalPolicy
SetReplacementSslCertificateRequest
SetReplacementSslCertificateRequestBody
SetReplacementSslCertificateResponse
SetReplacementSslCertificateResponseBody
SetReplacementSslCertificateT
SetScheduledUpdateSettingsRequest
SetScheduledUpdateSettingsRequestBody
SetScheduledUpdateSettingsResponse
SetScheduledUpdateSettingsResponseBody
SetScheduledUpdateSettingsT
SetSingleSessionPerUser
SetSslCertificateRequest
SetSslCertificateRequestBody
SetSslCertificateResponse
SetSslCertificateResponseBody
SetSslCertificateResponseT
SetSslCertificateT
SetStationAutologon
SetStationAutoLogon
SetStationAutologonHelper
SetStationFriendlyNameRequest
SetStationFriendlyNameRequestBody
SetStationFriendlyNameResponse
SetStationFriendlyNameResponseBody
SetStationFriendlyNameResponseT
SetStationFriendlyNameT
SetStationName
SetStationRemoteConnection
SetStationServerName
SetSuppressPrivacyNotification
SETTINGS
SetUiDuration
SetUiException
SetUpdateSchedule
SetUseHardwareGpu
SetUserInfoRequest
SetUserInfoRequestBody
SetUserInfoResponse
SetUserInfoResponseBody
SetUserInfoResponseT
SetUserInfoT
SetValue
SetWmsMode
SetWmsStationInvalidHostname
SetWmsStationInvalidParams
SetWmsUserInvalidParams
sGuidChatId
Shadowing
ShareDesktopRequest
ShareDesktopRequestBody
ShareDesktopResponse
ShareDesktopResponseBody
ShareDesktopResponseT
ShareDesktopT
shell32.dll
SHGetKnownFolderPath
shortName
ShouldProcess
ShouldProcessDisableWmsDiskProtection
ShouldProcessEnableWmsDiskProtection
ShouldProcessExitWmsSystem
ShouldProcessRemoveWmsSystem
ShouldProcessRemoveWmsUser
ShouldProcessRestartWmsSystem
ShouldProcessResumeWmsDiskProtection
ShouldProcessSuspendWmsDiskProtection
showCommand
ShowDefault
ShowInPortal
ShowMaximized
ShowMinimized
ShowMinNoActivate
ShowNoActivate
ShowNormal
ShowNormalNoActivate
ShowWindow
ShowWindowAsync
Shutdown computer
ShutdownMode
ShutdownNotification
ShuttingDown
SID_NAME_USE
SidNameUse
SidTypeAlias
SidTypeComputer
SidTypeDeletedAccount
SidTypeDomain
SidTypeGroup
SidTypeInvalid
SidTypeUnknown
SidTypeUser
SidTypeWellKnownGroup
SizeOf
SkipVerification
Sleep
SLProductQuery
Small
Software\Microsoft\Windows MultiPoint Server
Software\Microsoft\Windows MultiPoint Server\ConfigTasks\Skip
Software\Microsoft\Windows MultiPoint Server\Managed Server Notifications
Software\Microsoft\Windows MultiPoint Server\ProjectingMyOwnDesktop
Software\Microsoft\Windows NT\CurrentVersion\Winlogon
-SourcePath
span monitors:i:1
SpecialFolder
Speed
SplitStation
SqmDatapointId
SqmRegKeyPath
srcCollection
SslCertificateThumbprint
sslPolicyErrors
SslPolicyErrors
StandardVgaAdapterOnly
Starting
StartsWith
StartVirtualMachine
State
stateField
station
StationAlertEventArgs
stationClient
StationDeviceEventArgs
stationHost
stationID
stationId
stationID
StationId
StationId {0} does not exist
stationIds
stationName
stations
stationToVirtualDesktopMappings
stationUnattendFile
StationVirtualDesktop
status
StatusSubTabEventName
Stop managing the computer
StopFlashingWindow
StopIdentifyAll
StopIdentifyingSession
StopIdentifyingStation
StopIdentifySessions
StopIdentifyStations
StopLockingSession
Stopping
StopShareDesktop
StopStationVirtualMachines
stopWorkerThread
StoreCredential
storeName
storeProvider
StringBuilder
StringCollection
StringComparison
StringFileInfo
StringReader
StringToCoTaskMemAuto
StringToHGlobalAnsi
StringWriter
structList
structure
studentSessionId
Substring
suffix
supportedDeviceType
SupportsShouldProcess
SuppressFinalize
SuppressPrivacyNotification
suppressPrivacyNotification
Suspended
SwitchParameter
SwitchWmsMode
Swrestore
syncRoot
SYSPREP_CONTINUING_STAGED_INSTALL
SYSPREP_FRESH_INSTALLATION
SYSPREP_GENERALIZE_FAILED
SYSPREP_GENERALIZE_SUCCEEDED
SYSPREP_ONLINE_CONFIGURATION_FAILED
SYSPREP_ONLINE_CONFIGURED
SYSPREP_SPECIALIZE_FAILED
SYSPREP_SPECIALIZE_SUCCEEDED
sysprepState
system
system is null or empty
System.CodeDom.Compiler
System.Collections
System.Collections.Concurrent
System.Collections.Generic
System.Collections.ObjectModel
System.Collections.Specialized
System.ComponentModel
System.Core
System.Diagnostics
System.Diagnostics.Tracing
System.DirectoryServices
System.Globalization
System.IdentityModel
System.IdentityModel.Selectors
System.IdentityModel.Tokens
System.IO
System.Linq
System.Management
System.Management.Automation
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
System.Management.Automation.Runspaces
System.Net
System.Net.Security
System.Net.Sockets
System.Reflection
System.Resources
System.Runtime.CompilerServices
System.Runtime.InteropServices
System.Runtime.Serialization
System.Runtime.Versioning
System.Security
System.Security.Cryptography.X509Certificates
System.Security.Permissions
System.Security.Permissions.SecurityPermissionAttribute, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
System.Security.Principal
System.ServiceModel
System.ServiceModel.Channels
System.ServiceModel.Description
System.ServiceModel.InstanceContextMode, System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
System.ServiceModel.Security
System.ServiceProcess
System.Text
System.Text.RegularExpressions
System.Threading
System.Windows.Forms
System.Windows.Media.Imaging
System.Xml
System.Xml.Serialization
SystemAlertEventArgs
SystemConnectionState
SystemDefaultCharSize
systemImage
SystemImage
SystemInformation
SystemInSafeMode
SystemMode
systemMode
SystemModeEventArgs
SystemOperatingMode
SystemOperatingModePS
SystemSubTabEventName
TakeControlWindowTitleTemplate
target
targetAlias
TargetFrameworkAttribute
targetName
TASK_DESKTOPS_AUTOLAUNCH_DISABLE
TASK_DESKTOPS_AUTOLAUNCH_ENABLE
TASK_DESKTOPS_BLOCK
TASK_DESKTOPS_BLOCK_ALL
TASK_DESKTOPS_BLOCK_MULTI
TASK_DESKTOPS_BLOCK_USB_STORAGE
TASK_DESKTOPS_BLOCK_USB_STORAGE_ALL
TASK_DESKTOPS_CHANGE_SIZE
TASK_DESKTOPS_CHAT_DISABLE
TASK_DESKTOPS_CHAT_ENABLE
TASK_DESKTOPS_CHAT_SEND
TASK_DESKTOPS_CLEAR_CHAT_MESSAGES
TASK_DESKTOPS_CLOSE_APP
TASK_DESKTOPS_CONFIG_WEB_LIMIT
TASK_DESKTOPS_ENLARGE
TASK_DESKTOPS_EXCLUDE_SYSTEM
TASK_DESKTOPS_GROUP_BY_COMPUTER
TASK_DESKTOPS_HELP
TASK_DESKTOPS_INCLUDE_SYSTEM
TASK_DESKTOPS_LAUNCH_APP_ALL
TASK_DESKTOPS_LAUNCH_APP_MULTI
TASK_DESKTOPS_LIMIT_WEB_ALL
TASK_DESKTOPS_LIMIT_WEB_MULTI
TASK_DESKTOPS_LOGOFF_ALL
TASK_DESKTOPS_LOGOFF_MULTI
TASK_DESKTOPS_MESSAGE
TASK_DESKTOPS_REMOTE_CONTROL
TASK_DESKTOPS_SEARCH
TASK_DESKTOPS_SHARE_ALL
TASK_DESKTOPS_SHARE_MULTI
TASK_DESKTOPS_SHARE_SELECTED_ALL
TASK_DESKTOPS_SHOW_ACTIVE
TASK_DESKTOPS_SHOW_ALL
TASK_DESKTOPS_SORT_ASCENDING
TASK_DESKTOPS_SORT_BY_COMPUTER
TASK_DESKTOPS_SORT_BY_STATION
TASK_DESKTOPS_SORT_BY_USER
TASK_DESKTOPS_SORT_DESCENDING
TASK_DESKTOPS_STOP_LIMIT_WEB_ALL
TASK_DESKTOPS_STOP_LIMIT_WEB_MULTI
TASK_DESKTOPS_STOP_SHARING
TASK_DESKTOPS_THUMBNAIL_VIEW
TASK_DESKTOPS_UNBLOCK
TASK_DESKTOPS_UNBLOCK_ALL
TASK_DESKTOPS_UNBLOCK_MULTI
TASK_DESKTOPS_UNBLOCK_USB_STORAGE
TASK_DESKTOPS_UNBLOCK_USB_STORAGE_ALL
TASK_DESKTOPS_UNGROUP
TASK_HOME_ADD_CALS
TASK_HOME_DISABLE_DP_FAIL_DURATION
TASK_HOME_DISABLE_DP_FAIL_ERROR
TASK_HOME_DISABLE_DP_START
TASK_HOME_DISABLE_DP_SUCCESS_DURATION
TASK_HOME_DISCUSSION_BOARD
TASK_HOME_ENABLE_DP_FAIL_DURATION
TASK_HOME_ENABLE_DP_FAIL_ERROR
TASK_HOME_ENABLE_DP_START
TASK_HOME_ENABLE_DP_SUCCESS_DURATION
TASK_HOME_MAINTENANCE
TASK_HOME_MANAGE_CALS
TASK_HOME_MANAGE_COMPUTERS
TASK_HOME_NORMAL
TASK_HOME_REMAP
TASK_HOME_REMOVE_CALS
TASK_HOME_RESTART
TASK_HOME_SAVE_CONNECTION
TASK_HOME_SETTINGS
TASK_HOME_SHUTDOWN
TASK_HOME_WEB
TASK_STATUS_AUTOLOGON
TASK_STATUS_IDENTIFY
TASK_STATUS_IDENTIFY_ALL
TASK_STATUS_LOGOFF
TASK_STATUS_LOGOFF_ALL
TASK_STATUS_SPLIT_SCREEN
TASK_STATUS_STATION_NAME
TASK_STATUS_STOP_IDENTIFY_ALL
TASK_STATUS_SUSPEND
TASK_STATUS_SUSPEND_ALL
TASK_STATUS_UNSPLIT_SCREEN
TASK_USERS_ADD_ACCOUNT
TASK_USERS_CHANGE_ACCESS
TASK_USERS_CHANGE_FULL_NAME
TASK_USERS_CHANGE_PASSWORD
TASK_USERS_DELETE_ACCOUNT
TASK_VDI_DISABLE_FAIL_DURATION
TASK_VDI_DISABLE_FAIL_ERROR
TASK_VDI_DISABLE_START
TASK_VDI_DISABLE_SUCCESS_DURATION
TASK_VDI_ENABLE_FAIL_DURATION
TASK_VDI_ENABLE_FAIL_ERROR
TASK_VDI_ENABLE_START
TASK_VDI_ENABLE_SUCCESS_DURATION
TASK_VDI_IMPORT_DESKTOP_FAIL_DURATION
TASK_VDI_IMPORT_DESKTOP_FAIL_ERROR
TASK_VDI_IMPORT_DESKTOP_START
TASK_VDI_IMPORT_DESKTOP_SUCCESS_DURATION
TASK_VDI_IMPORT_DESKTOP_VHD_LOCATION
TASK_VDI_NEW_DESKTOP_DOMAIN
TASK_VDI_NEW_DESKTOP_FAIL_DURATION
TASK_VDI_NEW_DESKTOP_FAIL_ERROR
TASK_VDI_NEW_DESKTOP_START
TASK_VDI_NEW_DESKTOP_SUCCESS_DURATION
TASK_VDI_NEW_DESKTOP_TEMPLATE_DOMAIN
TASK_VDI_NEW_DESKTOP_TEMPLATE_FAIL_DURATION
TASK_VDI_NEW_DESKTOP_TEMPLATE_FAIL_ERROR
TASK_VDI_NEW_DESKTOP_TEMPLATE_START
TASK_VDI_NEW_DESKTOP_TEMPLATE_SUCCESS_DURATION
TASK_VDI_NEW_DESKTOP_TEMPLATE_VHD_LOCATION
TASK_VDI_NEW_DESKTOP_VHD_LOCATION
TASK_VDI_OPEN_DESKTOP_DOMAIN
TASK_VDI_OPEN_DESKTOP_FAIL_DURATION
TASK_VDI_OPEN_DESKTOP_FAIL_ERROR
TASK_VDI_OPEN_DESKTOP_START
TASK_VDI_OPEN_DESKTOP_SUCCESS_DURATION
TaskCompletedEventName
teacherName
teacherServerName
teacherSessionId
teacherUserName
TelemetryEventSource
TelemetryGroup
telemetryGroup
TelemetryInfoOption
TelemetryKeyword
TelemetryOptions
tempAutologonDomain
tempAutologonUserName
templatePrefix
templatePrefixMaxLength
templateUnattendFile
templateVhdPath
templateVirtualMachineName
tempSplitState
tempVirtualMachineName
TerminalServiceSetting
Terminated
TerminateSession
Test-Admin {
TextWriter
The specified server name is not a valid hostname (or) not a valid IPV4 address (or) is not reachable. Please verify and check if the server is reachable.
This $VHDFormat was created by Convert-WindowsImage.ps1 (WIM2VHD8) $myVersion $vQuality
thisWindowPtr
threadContext
throw new-object Microsoft.SharedComputing.Utils.WmsCmdletException({0}, '{1}');
ThrowErrorIfMogIsNotApplicable
throwException
ThrowExceptionForHR
ThrowExceptionFromLastError
ThrowExceptionIfVirtualDiskIsInUse
ThrowWmsCmdletException
ThumbnailSizePS
timeAllowedForCustomScriptInMinutes
TimeoutException
TimeSpan
timesToFlash
TimeToScheduleUpdates
timeToScheduleUpdates
title
title is null or empty
tmpIsDisconnected
tmpIsLocked
tmpIsPrivate
ToArray
ToBase64String
ToCharArray
ToInt64
ToLower
ToLowerInvariant
ToObject
topic
ToString
ToUInt32
TraceLoggingWriteUiDuration
TraceLoggingWriteUiEvent
TraceLoggingWriteUiException
TraceLoggingWriteUiMetric
TraceLoggingWriteUiScenarioError
TransferCredentials
Translation
try {
TryDequeue
TryGetEventName
TryGetValue
TryParse
TSGeneralSetting
TSLicenseKeyPackQuery
TSLicenseServerQuery
TSNetworkAdapterSetting
TSPublishedApplications
TSSessionState
TurnedOff
TurnOffStationVirtualMachines
uCount
UI_EXCEPTION
uiInfo
UInt16
UInt64
ullCreateTime
Unable to find SQM event name for dataId: {0}
Unattend-c.xml
UnattendConfig
unattendConfigs
Unattend-s.xml
Unattend-t.xml
UnauthorizedAccessException
UnblockUsbStorageDevices
UnblockUsbStorageDevicesAllStations
Uninstall
UnInstallDiskProtection
UnInstallDiskProtectionService
uniqueId
UnregisterChatEventSink
UnregisterCoreEventSink
UnregisterEventSink
UnregisterEventSinkAction
UnsplitStation
Unsupported Windows Edition
Unused
UnverifiableCodeAttribute
UpdateCustomizeUnattendFile
updateTime
UriBuilder
uriForEndpoint
UriFormatException
urlForAcl
urlList
usbStorageDeviceBlocking
use multimon:i:1
useHardwareGpu
USER_MODALS_INFO_2
user32
user32.dll
User32.dll
userDomain
UserEventArgs
UserModalsInfo2
userName
username
UserName cannot be null or empty and its length cannot be greater than 
UserName has invalid characters
userName is null or empty
Username is wrong.
Username or password is null.
UserNameLength
UserNamePasswordClientCredential
UserNamePasswordServiceCredential
UserNameRegexInvalidChars
UserNameRegexPeriodSpace
userNameTarget
UserNameType
UsersGroupSid
UsersSubTabEventName
UserType
userType
UserTypeField
UserTypePS
userWsArray
using Microsoft.Win32.SafeHandles;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security;
using System.Text.RegularExpressions;
using System.Text;
using System.Threading;
using System.Xml.Linq;
using System.Xml.XPath;
using System;
uThe autologon user to be set duplicates the ones on other stations. Two stations cannot have the same autologon user.
v4.0.30319
Validate
ValidateAutoLogonAccountRequest
ValidateAutoLogonAccountRequestBody
ValidateAutoLogonAccountResponse
ValidateAutoLogonAccountResponseBody
ValidateAutoLogonAccountT
ValidateComputerName
ValidateDescription
ValidateDomainUserName
ValidateFullName
ValidateManagedServer
ValidateManagedSystemsType
ValidateUserName
ValidateVirtualDesktopImage
ValidateWmsServerCert
ValidationChecks
validFlags
value
value__
ValueFromPipelineByPropertyName
ValueType
VarFileInfo
VDI is not enabled
VdiDomainOptions
version
Version $myVersion $vQuality
VersionMismatch
vhdLocation
vhdPath
-VHDPath
view is null
ViewDesktopRequest
ViewDesktopRequestBody
ViewDesktopResponse
ViewDesktopResponseBody
ViewDesktopResponseT
ViewDesktopT
Virtual disk image is locked for use by another process.
VirtualDesktopCmdletTimeoutInSeconds
virtualDesktopName
VirtualDesktopNotificationEventArgs
VirtualDesktopOnlineEventArgs
virtualDesktopsRegistryPath
VirtualDesktopSubTabEventName
VirtualDesktopTemplateMaxStages
VirtualDesktopTemplateStages
virtualDiskImage
virtualDiskPath
VirtualDiskType
VirtualMachineConnectionType
virtualMachineFqdn
virtualMachineId
virtualMachineName
VirtualMachineName
virtualMachineProperty
VirtualMachinePropertyType
VirtualMachineRegistryPath
VirtualMachineState
VirtualMachineType
VMConnect.EXE
vmConnectList
VPath
VS_VERSION_INFO
WaitAny
WaitForConnectionTimeout
WaitForServicesTimeout
WaitForVirtualMachineToCompleteSysprep
WaitForVirtualMachineToTurnOff
WaitForVirtualSwitchToBeConnected
WaitOne
Web service call failed
WebLimitSetting
WebServiceCallFailed
WellKnownSidType
WERConsentRegKeyPath
WERRegKeyPath
Where
Win32_NetworkAdapterSetting
win32Error
Win32Exception
Win32OperatingSystemQuery
WinAccountAdministratorSid
WinAccountCertAdminsSid
WinAccountComputersSid
WinAccountControllersSid
WinAccountDomainAdminsSid
WinAccountDomainGuestsSid
WinAccountDomainUsersSid
WinAccountEnterpriseAdminsSid
WinAccountGuestSid
WinAccountKrbtgtSid
WinAccountPolicyAdminsSid
WinAccountRasAndIasServersSid
WinAccountSchemaAdminsSid
WinAnonymousSid
WinAuthenticatedUserSid
WinBatchSid
WinBuiltinAccountOperatorsSid
WinBuiltinAdministratorsSid
WinBuiltinBackupOperatorsSid
WinBuiltinDomainSid
WinBuiltinGuestsSid
WinBuiltinNetworkConfigurationOperatorsSid
WinBuiltinPowerUsersSid
WinBuiltinPreWindows2000CompatibleAccessSid
WinBuiltinPrintOperatorsSid
WinBuiltinRemoteDesktopUsersSid
WinBuiltinReplicatorSid
WinBuiltinSystemOperatorsSid
WinBuiltinUsersSid
WinCreatorGroupServerSid
WinCreatorGroupSid
WinCreatorOwnerServerSid
WinCreatorOwnerSid
WinDialupSid
windowHandle
windowId
WindowIdField
Windows MultiPoint Server
Windows(R) Image to Virtual Hard Disk (WIM2VHD) Converter for Windows(R) 8
WindowsAndOtherPrograms
WindowsCoreTelemetry
windowsCoreTelemetryTraits
windowsEdition
WindowShowStyle
WindowsIdentity
WindowsOnly
windowStationName
WinEnterpriseControllersSid
WinInteractiveSid
WinLocalServiceSid
WinLocalSid
WinLocalSystemSid
WinLogonIdsSid
WinNetworkServiceSid
WinNetworkSid
WinNT://{0}/{1},user
WinNtAuthoritySid
WinNullSid
WinProxySid
WinRemoteLogonIdSid
WinRestrictedCodeSid
WinRMHttpUri
WinSelfSid
WinServiceSid
WinTerminalServerSid
WinWorldSid
WizardLoadedEventName
wmiNamespace
WMS VDI Powershell Cmdlets
WMS Virtual Desktop roles are not enabled
WMS_Domain_notJoined
WMS_Domin_Joined
WMS_RUNNING_APP_WST
WMS_SESSION_INFO
WMS_SESSION_INFO_WST
WMS_Setting_Admin_Orchestration
WMS_Setting_Allow_Chat
WMS_Setting_Allow_Monitoring
WMS_Setting_Boot_To_Console_Mode
WMS_Setting_Multiple_Sessions
WMS_Setting_Remote_Management
WMS_Setting_Unique_IP
WMS_Sku_Premium
WMS_Sku_Standard
WMS_USER_WST
wmsAlertType
WmsBitField
WmsCallbackUserName
WmsChatEventSink
WmsCmdlet
wmsCmdletError
WmsCmdletError
WmsControl
WmsControlAccountName
WmsCoreEventSink
WmsDashboard.exe
WmsEventSink
WmsFaultType
WmsFaultTypeT
WMSHKCURegistryPath
WMSHKLMRegistryPath
wmsIpAddressList
WmsManager.exe
WmsOperators
WMSPolicyRegistryPath
WmsPowerShellNamespace
WMSRegistryPath
WmsRemoteCmdlet
WMSRemoteManagementRegistryPath
WMSReserved
WmsRunningApp
wmsRunningAppWsArray
WmsScheduledUpdate
WMSSelfHealingRegistryPath
WmsSession
WmsSessionStatus
WmsShell
WmsShellConfigTask
WmsShellConfigTaskBackup
WmsShellProcessName
WmsShellUserName
WmsSqm
wmsStation
WmsStation
WmsSvc.Interop
wmsSvcComWrapper
WmsSvcComWrapper
WmsSvcNotRunning
WmsSystemKeyFormat
wmsutils.dll
WmsVcfFirstWarningThreshold
WmsVcfSecondWarningThreshold
WMSVersionRegistryPath
WmsVirtualDesktop
WmsVirtualDesktopRole
WmsVirtualDesktopTemplate
workerThread
WrapNonExceptionThrows
WriteAllText
WriteError
WriteObject
Write-Verbose $header
Write-W2VError {
Write-W2VInfo {
Write-W2VTrace {
Write-W2VWarn {
WS_E_ENDPOINT_ACCESS_DENIED
wsDescriptionField
wsDomainField
wsErrorMsg
wsFileToRun
wsFqdnManagingServer
wsFullNameField
wsHostName
WSHttpBinding
WSHttpBindingBase
WSHttpSecurity
wsIpAddress
wsIpAddresses
wsLockMessage
wsMessage
wsNameField
wsPassword
wsRemoteFqdn
wssg.wms
wsStationHost
wsStationName
wsTeacherName
wsTeacherServerName
wsTeacherUserName
wsTitle
wsUser
wsUserNameField
wsWinStationField
wsWmsSystemHostName
wsWmsSystemIpAddress
WTS_CONSOLE_CONNECT
WTS_CONSOLE_DISCONNECT
Wts_Info_Class
WTS_REMOTE_CONNECT
WTS_REMOTE_DISCONNECT
Wts_Session_Info
WTS_SESSION_LOCK
WTS_SESSION_LOGOFF
WTS_SESSION_LOGON
WTS_SESSION_REMOTE_CONTROL
WTS_SESSION_UNLOCK
wtsapi32.dll
Wtsapi32.dll
WtsApplicationName
WtsClientAddress
WtsClientBuildNumber
WtsClientDirectory
WtsClientDisplay
WtsClientHardwareId
WtsClientInfo
WtsClientName
WtsClientProductId
WtsClientProtocolType
WtsConnectState
WTSDisconnectSession
WtsDomainName
WTSEnumerateSessions
WTSFreeMemory
WtsIdleTime
WtsIncomingBytes
WtsIncomingFrames
WTSINFO
wtsInfoClass
WtsInitialProgram
WTSLogoffSession
WtsLogonTime
WtsOEMId
WtsOutgoingBytes
WtsOutgoingFrames
WTSQuerySessionInformation
WtsSessionId
WtsSessionInfo
WtsUserName
WtsWinStationName
WtsWorkingDirectory
X509Certificate
X509Certificate2
X509Certificate2Collection
X509CertificateCollection
X509CertificateRecipientServiceCredential
X509Chain
X509FindType
X509Store
XmlDictionaryReader
XmlReader
XmlReflectionImporter
XmlRootAttribute
XmlTextReader
XmlTypeMapping
You can use the fields below to configure the VHD or VHDX that you want to create!
ZeroFreeGlobalAllocUnicode
