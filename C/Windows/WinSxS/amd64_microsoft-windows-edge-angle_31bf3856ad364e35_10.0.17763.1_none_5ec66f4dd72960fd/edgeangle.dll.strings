        
                            insertMask);
                           insertMask);
            lsb += 1;
            lsb = 0;
            msb += 1;
         output.gl_Layer = _ViewID_OVR;
         output.gl_ViewportIndex = _ViewID_OVR;
         output.gl_ViewportIndex = 0;
        {
        }
        else
        if (
        if (lsb == 0xffffffff)
        int baseLevel;
        int internalFormatBits;
        int padding;
        int wrapModes;
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
        lsb = ~lsb;
        msb = ~msb;
        output.gl_Layer = input.gl_ViewID_OVR;
        output.gl_ViewportIndex = 0;
        output.gl_ViewportIndex = input.gl_ViewID_OVR;
        resultUnsigned |= ((resultUnsigned & maskMsb) >> (bits - 1)) * higherBitsMask;
        resultUnsigned |= higherBitsMask;
        return 0;
        return 0u;
        return base;
        return int2(0, 0);
        return int3(0, 0, 0);
        return int4(0, 0, 0, 0);
        return N;
        return -N;
        return uint2(0u, 0u);
        return uint3(0u, 0u, 0u);
        return uint4(0u, 0u, 0u, 0u);
        uint higherBitsMask = ((1u << (32 - bits)) - 1u) << bits;
     - m[0][0] * m[2][1] * m[1][2] - m[1][0] * m[0][1] * m[2][2] - m[2][0] * m[1][1] * 
     - m[0][0] * m[2][1] * m[1][3] - m[1][0] * m[0][1] * m[2][3] - m[2][0] * m[1][1] * 
     - m[0][0] * m[2][2] * m[1][3] - m[1][0] * m[0][2] * m[2][3] - m[2][0] * m[1][2] * 
     - m[0][0] * m[3][1] * m[1][2] - m[1][0] * m[0][1] * m[3][2] - m[3][0] * m[1][1] * 
     - m[0][0] * m[3][1] * m[1][3] - m[1][0] * m[0][1] * m[3][3] - m[3][0] * m[1][1] * 
     - m[0][0] * m[3][1] * m[2][2] - m[2][0] * m[0][1] * m[3][2] - m[3][0] * m[2][1] * 
     - m[0][0] * m[3][1] * m[2][3] - m[2][0] * m[0][1] * m[3][3] - m[3][0] * m[2][1] * 
     - m[0][0] * m[3][2] * m[1][3] - m[1][0] * m[0][2] * m[3][3] - m[3][0] * m[1][2] * 
     - m[0][0] * m[3][2] * m[2][3] - m[2][0] * m[0][2] * m[3][3] - m[3][0] * m[2][2] * 
     - m[0][1] * m[2][2] * m[1][3] - m[1][1] * m[0][2] * m[2][3] - m[2][1] * m[1][2] * 
     - m[0][1] * m[3][2] * m[1][3] - m[1][1] * m[0][2] * m[3][3] - m[3][1] * m[1][2] * 
     - m[0][1] * m[3][2] * m[2][3] - m[2][1] * m[0][2] * m[3][3] - m[3][1] * m[2][2] * 
     - m[1][0] * m[3][1] * m[2][2] - m[2][0] * m[1][1] * m[3][2] - m[3][0] * m[2][1] * 
     - m[1][0] * m[3][1] * m[2][3] - m[2][0] * m[1][1] * m[3][3] - m[3][0] * m[2][1] * 
     - m[1][0] * m[3][2] * m[2][3] - m[2][0] * m[1][2] * m[3][3] - m[3][0] * m[2][2] * 
     - m[1][1] * m[3][2] * m[2][3] - m[2][1] * m[1][2] * m[3][3] - m[3][1] * m[2][2] * 
     cof02, cof12, cof22, cof32, cof03, cof13, cof23, cof33 };
    _ViewID_OVR = input.gl_ViewID_OVR;
    {
    | ((asuint(y) & 0xffu) << 8) | (asuint(x) & 0xffu);
    }
    } else {
    };
    bool
    bool isNonZero = (exponent >= -25.0);
    bool negative = (x < 0) != (y < 0);
    bool negative = (xMajor && t.x < 0.0f) || (yMajor && t.y < 0.0f) || (zMajor && t.z < 0.0f);
    bool xMajor = abs(t.x) > abs(t.y) && abs(t.x) > abs(t.z);
    bool yMajor = abs(t.y) > abs(t.z) && abs(t.y) > abs(t.x);
    bool zMajor = abs(t.z) > abs(t.x) && abs(t.z) > abs(t.y);
    bool2 isnan;
    bool3 isnan;
    bool4 isnan;
    borrow = uint(x < y);
    borrow = uint2(x < y);
    borrow = uint3(x < y);
    borrow = uint4(x < y);
    bvec
    carry = uint(x > (0xffffffffu - y));
    carry = uint2(x > (0xffffffffu - y));
    carry = uint3(x > (0xffffffffu - y));
    carry = uint4(x > (0xffffffffu - y));
    centroid 
    const uint samplerArrayIndex = samplerIndex - samplerIndexOffset
    const uint textureIndex = samplerIndex - textureIndexOffset
    copyVertex(output, input[
    depth = max(depth >> lod, 1);
    else
    exp = int(fexp);
    exp = int2(fexp);
    exp = int3(fexp);
    exp = int4(fexp);
    float cof00 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
    float cof00 = m[1][1] * m[2][2] * m[3][3] + m[2][1] * m[3][2] * m[1][3] + m[3][1] * 
    float cof01 = -(m[1][0] * m[2][2] - m[2][0] * m[1][2]);
    float cof01 = -(m[1][0] * m[2][2] * m[3][3] + m[2][0] * m[3][2] * m[1][3] + m[3][0] * 
    float cof02 = m[1][0] * m[2][1] - m[2][0] * m[1][1];
    float cof02 = m[1][0] * m[2][1] * m[3][3] + m[2][0] * m[3][1] * m[1][3] + m[3][0] * 
    float cof03 = -(m[1][0] * m[2][1] * m[3][2] + m[2][0] * m[3][1] * m[1][2] + m[3][0] * 
    float cof10 = -(m[0][1] * m[2][2] - m[2][1] * m[0][2]);
    float cof10 = -(m[0][1] * m[2][2] * m[3][3] + m[2][1] * m[3][2] * m[0][3] + m[3][1] * 
    float cof11 = m[0][0] * m[2][2] - m[2][0] * m[0][2];
    float cof11 = m[0][0] * m[2][2] * m[3][3] + m[2][0] * m[3][2] * m[0][3] + m[3][0] * 
    float cof12 = -(m[0][0] * m[2][1] - m[2][0] * m[0][1]);
    float cof12 = -(m[0][0] * m[2][1] * m[3][3] + m[2][0] * m[3][1] * m[0][3] + m[3][0] * 
    float cof13 = m[0][0] * m[2][1] * m[3][2] + m[2][0] * m[3][1] * m[0][2] + m[3][0] * 
    float cof20 = m[0][1] * m[1][2] - m[1][1] * m[0][2];
    float cof20 = m[0][1] * m[1][2] * m[3][3] + m[1][1] * m[3][2] * m[0][3] + m[3][1] * 
    float cof21 = -(m[0][0] * m[1][2] - m[1][0] * m[0][2]);
    float cof21 = -(m[0][0] * m[1][2] * m[3][3] + m[1][0] * m[3][2] * m[0][3] + m[3][0] * 
    float cof22 = m[0][0] * m[1][1] - m[1][0] * m[0][1];
    float cof22 = m[0][0] * m[1][1] * m[3][3] + m[1][0] * m[3][1] * m[0][3] + m[3][0] * 
    float cof23 = -(m[0][0] * m[1][1] * m[3][2] + m[1][0] * m[3][1] * m[0][2] + m[3][0] * 
    float cof30 = -(m[0][1] * m[1][2] * m[2][3] + m[1][1] * m[2][2] * m[0][3] + m[2][1] * 
    float cof31 = m[0][0] * m[1][2] * m[2][3] + m[1][0] * m[2][2] * m[0][3] + m[2][0] * 
    float cof32 = -(m[0][0] * m[1][1] * m[2][3] + m[1][0] * m[2][1] * m[0][3] + m[2][0] * 
    float cof33 = m[0][0] * m[1][1] * m[2][2] + m[1][0] * m[2][1] * m[0][2] + m[2][0] * 
    float coordWrapped = 1.0 - abs(frac(abs(
    float dfacexdx = 0.5f * (m * dudx - u * dmdx) / (m * m);
    float dfacexdy = 0.5f * (m * dudy - u * dmdy) / (m * m);
    float dfaceydx = 0.5f * (m * dvdx - v * dmdx) / (m * m);
    float dfaceydy = 0.5f * (m * dvdy - v * dmdy) / (m * m);
    float diff;
    float dmdx = xMajor ? ddx[0] : (yMajor ? ddx[1] : ddx[2]);
    float dmdy = xMajor ? ddy[0] : (yMajor ? ddy[1] : ddy[2]);
    float dudx = xMajor ? ddx[2] : (yMajor && t.y < 0.0f ? -ddx[0] : ddx[0]);
    float dudy = xMajor ? ddy[2] : (yMajor && t.y < 0.0f ? -ddy[0] : ddy[0]);
    float dvdx = yMajor ? ddx[2] : (negative ? ddx[1] : -ddx[1]);
    float dvdy = yMajor ? ddy[2] : (negative ? ddy[1] : -ddy[1]);
    float dx = length(ddx(tSized));
    float dy = length(ddy(tSized));
    float far;
    float fexp;
    float gl_Depth : 
    float gl_PointSize : 
    float gl_PointSize = clamp(input[0].gl_PointSize, minPointSize, maxPointSize);
    float lengthfaceddx2 = dot(faceddx, faceddx);
    float lengthfaceddy2 = dot(faceddy, faceddy);
    float lod = 0.5f * log2(max(dot(dx, dx), dot(dy, dy)));
    float lod = log2(max(dot(sizeDdx, sizeDdx), dot(sizeDdy, sizeDdy))) * 0.5f;
    float lod = log2(max(dx, dy));
    float lod = log2(max(lengthfaceddx2, lengthfaceddy2)) * 0.5f;
    float m = xMajor ? t.x : (yMajor ? t.y : t.z);
    float mantissa = frexp(abs(x), fexp) * sign(x);
    float multiviewSelectViewportIndex : packoffset(c3.z);
    float near;
    float pad_
    float rhw = 1.0 / input.gl_FragCoord.w;
    float u = xMajor ? -t.z : (yMajor && t.y < 0.0f ? -t.x : t.x);
    float v = yMajor ? t.z : (negative ? t.y : -t.y);
    float width; float height; float depth; float levels;
    float width; float height; float layers; float levels;
    float width; float height; float levels;
    float2 dx = ddx(tSized);
    float2 dx_ViewCoords : packoffset(c2);
    float2 dx_ViewScale  : packoffset(c3);
    float2 dx_ViewScale : packoffset(c3);
    float2 dy = ddy(tSized);
    float2 faceddx = float2(dfacexdx, dfaceydx) * sizeVec;
    float2 faceddy = float2(dfacexdy, dfaceydy) * sizeVec;
    float2 fexp;
    float2 gl_PointCoord : 
    float2 mantissa = frexp(abs(x), fexp) * sign(x);
    float2 sizeDdx = ddx * sizeVec;
    float2 sizeDdy = ddy * sizeVec;
    float2 sizeVec = float2(width, height);
    float2 spriteTexCoord : SPRITETEXCOORD0;
    float2 tSized = float2(t.x * width, t.y * height);
    float2 v;
    float2 viewportScale = float2(1.0f / dx_ViewCoords.x, 1.0f / dx_ViewCoords.y) * dx_Position.w;
    float2( 0.5f,  0.5f),
    float2( 0.5f, -0.5f),
    float2(0.0f, 0.0f)
    float2(0.0f, 1.0f),
    float2(-0.5f,  0.5f)
    float2(-0.5f, -0.5f),
    float2(1.0f, 0.0f),
    float2(1.0f, 1.0f),
    float2x2 cof = { m[1][1], -m[0][1], -m[1][0], m[0][0] };
    float3 dx_DepthFront : packoffset(c2);
    float3 dx_DepthRange : packoffset(c0);
    float3 fexp;
    float3 mantissa = frexp(abs(x), fexp) * sign(x);
    float3 sizeDdx = ddx * sizeVec;
    float3 sizeDdy = ddy * sizeVec;
    float3 sizeVec = float3(width, height, depth);
    float3 spriteVertexPos : SPRITEPOSITION0;
    float3 tSized = float3(t.x * width, t.y * height, t.z * depth);
    float3 v;
    float3x3 cof = { cof00, cof10, cof20, cof01, cof11, cof21, cof02, cof12, cof22 };
    float4 dx_Position : 
    float4 dx_Position = input[0].dx_Position;
    float4 dx_ViewAdjust : packoffset(c1);
    float4 dx_ViewCoords : packoffset(c1);
    float4 fexp;
    float4 gl_FragCoord : 
    float4 gl_Position : 
    float4 mantissa = frexp(abs(x), fexp) * sign(x);
    float4 v;
    float4(0, 0, 0, 0)
    float4x4 cof = { cof00, cof10, cof20, cof30, cof01, cof11, cof21, cof31,
    for (int i = 0; i < 
    for (int i = 0; i < 2; i++)
    for (int i = 0; i < 3; i++)
    for (int i = 0; i < 4; i++)
    gl_FragCoord.w = rhw;
    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_ViewCoords.x + dx_ViewCoords.z;
    gl_FragCoord.x = input.dx_Position.x + 0.5;
    gl_FragCoord.x = input.dx_Position.x;
    gl_FragCoord.y = (1.0f + dx_ViewScale.y) * gl_FragCoord.y /(1.0f - input.gl_FragCoord.y * rhw)  - dx_ViewScale.y * gl_FragCoord.y;
    gl_FragCoord.y = (input.gl_FragCoord.y * rhw) * dx_ViewCoords.y + dx_ViewCoords.w;
    gl_FragCoord.y = input.dx_Position.y + 0.5;
    gl_FragCoord.y = input.dx_Position.y;
    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_DepthFront.x + dx_DepthFront.y;
    gl_FrontFacing = (vFace * dx_DepthFront.z >= 0.0);
    gl_FrontFacing = isFrontFace;
    gl_GlobalInvocationID = input.dx_GlobalInvocationID;
    gl_LocalInvocationID = input.dx_LocalInvocationID;
    gl_LocalInvocationIndex = input.dx_LocalInvocationIndex;
    gl_main();
    gl_PointCoord.x = input.gl_PointCoord.x;
    gl_PointCoord.y = 1.0 - input.gl_PointCoord.y;
    gl_PointSize = clamp(gl_PointSize, minPointSize, maxPointSize);
    gl_WorkGroupID = input.dx_WorkGroupID;
    GS_OUTPUT output = (GS_OUTPUT)0;
    height = max(height >> lod, 1);
    if (bits != 32 && (resultUnsigned & maskMsb) != 0)
    if (bits != 32)
    if (multiviewSelectViewportIndex)
    if (negative)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    if(dot(Nref, I) >= 0)
    if(x == 0 && y == 0) x = 1;
    if(x[0] == 0 && y[0] == 0) x[0] = 1;
    if(x[1] == 0 && y[1] == 0) x[1] = 1;
    if(x[2] == 0 && y[2] == 0) x[2] = 1;
    if(x[3] == 0 && y[3] == 0) x[3] = 1;
    imulExtended_emu(x.w, y.w, msb.w, lsb.w);
    imulExtended_emu(x.x, y.x, msb.x, lsb.x);
    imulExtended_emu(x.y, y.y, msb.y, lsb.y);
    imulExtended_emu(x.z, y.z, msb.z, lsb.z);
    initAttributes(input);
    insertMask);
    int baseLevel = 0;
    int baseLevel = samplerMetadata[samplerIndex].baseLevel;
    int face = (int)negative + (int)yMajor * 2 + (int)zMajor * 4;
    int w = webgl_toSnorm8(v.w);
    int x = webgl_toSnorm16(v.x);
    int x = webgl_toSnorm8(v.x);
    int xi = asint(x & 0x7fffu) - asint(x & 0x8000u);
    int xi = asint(x & 0x7fu) - asint(x & 0x80u);
    int y = webgl_toSnorm16(v.y);
    int y = webgl_toSnorm8(v.y);
    int z = webgl_toSnorm8(v.z);
    lod += bias;
    lsb = asint(unsignedLsb);
    lsb = x * y;
    m[0][1] * m[1][2]
    m[0][1] * m[1][3]
    m[0][1] * m[2][2]
    m[0][1] * m[2][3]
    m[0][2] * m[1][3]
    m[0][2] * m[2][3]
    m[0][2]);
    m[0][2];
    m[0][3]);
    m[0][3];
    m[1][1] * m[2][2]
    m[1][1] * m[2][3]
    m[1][2] * m[2][3]
    m[1][2]);
    m[1][3]);
    m[1][3];
    mip = uint(min(max(round(lod), 0), levels - 1));
    msb = ((ad + bc) >> 16) + (carry << 16) + b * d;
    msb = asint(unsignedMsb);
    nointerpolation 
    nointerpolation uint gl_Layer : 
    nointerpolation uint gl_ViewID_OVR : 
    nointerpolation uint gl_ViewportIndex : 
    output.
    output.dx_Position = dx_Position + float4(1.0f, -dx_ViewScale.y, 1.0f, 1.0f)        * float4(pointSpriteCorners[
    output.dx_Position = dx_Position + float4(pointSpriteCorners[
    output.dx_Position = input.dx_Position;
    output.dx_Position.w = gl_Position.w;
    output.dx_Position.x += (input.spriteVertexPos.x * gl_PointSize / (dx_ViewCoords.x*2)) * output.dx_Position.w;
    output.dx_Position.x = gl_Position.x * dx_ViewAdjust.z + dx_ViewAdjust.x * gl_Position.w;
    output.dx_Position.x = gl_Position.x;
    output.dx_Position.y += (-dx_ViewScale.y * input.spriteVertexPos.y * gl_PointSize / (dx_ViewCoords.y*2)) * output.dx_Position.w;
    output.dx_Position.y += (input.spriteVertexPos.y * gl_PointSize / (dx_ViewCoords.y*2)) * output.dx_Position.w;
    output.dx_Position.y = - gl_Position.y;
    output.dx_Position.y = -(gl_Position.y * dx_ViewAdjust.w + dx_ViewAdjust.y * gl_Position.w);
    output.dx_Position.y = dx_ViewScale.y * (gl_Position.y * dx_ViewAdjust.w + dx_ViewAdjust.y * gl_Position.w);
    output.dx_Position.y = dx_ViewScale.y * gl_Position.y;
    output.dx_Position.z += input.spriteVertexPos.z * output.dx_Position.w;
    output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;
    output.gl_Depth = gl_Depth; 
    output.gl_FragCoord = gl_Position;
    output.gl_FragCoord = input.gl_FragCoord;
    output.gl_Layer = input.gl_Layer;
    output.gl_PointCoord = float2(0.5, 0.5);
    output.gl_PointCoord = input.spriteTexCoord;
    output.gl_PointCoord = pointSpriteTexcoords[
    output.gl_PointSize = gl_PointSize;
    output.gl_PointSize = input.gl_PointSize;
    output.gl_Position = gl_Position;
    output.gl_Position = input.gl_Position;
    output.gl_ViewID_OVR = _ViewID_OVR;
    output.gl_ViewID_OVR = input.gl_ViewID_OVR;
    output.gl_ViewportIndex = input.gl_ViewportIndex;
    output.v
    outStream.Append(output);
    outStream.RestartStrip();
    PS_OUTPUT output;
    return 
    return ((asuint(w) & 0xffu) << 24) | ((asuint(z) & 0xffu) << 16) 
    return (asuint(y) << 16) | (asuint(x) & 0xffffu);
    return (base & baseMask) | ((insert << offset) & insertMask);
    return (frac(x) == 0.5 && trunc(x) % 2.0 == 0.0) ? trunc(x) : round(x);
    return (p || q) && !(p && q);
    return (value & mask) >> offset;
    return (w << 24) | (z << 16) | (y << 8) | x;
    return (x > 0.0 || x < 0.0) ? false : x != 0.0;
    return (y << 16) | x;
    return 0.5 * log((1.0 + x) / (1.0 - x));
    return a ? y : x;
    return asint(resultUnsigned);
    return atan2(y, x);
    return clamp(float(xi) / 127.0, -1.0, 1.0);
    return clamp(float(xi) / 32767.0, -1.0, 1.0);
    return cof / determinant(transpose(m));
    return float(x) / 255.0;
    return float(x) / 65535.0;
    return float2(atan2(y[0], x[0]), atan2(y[1], x[1]));
    return float2(f16tof32(x), f16tof32(y));
    return float2(webgl_fromSnorm16(x), webgl_fromSnorm16(y));
    return float2(webgl_fromUnorm16(x), webgl_fromUnorm16(y));
    return float3(atan2(y[0], x[0]), atan2(y[1], x[1]), atan2(y[2], x[2]));
    return float4(atan2(y[0], x[0]), atan2(y[1], x[1]), atan2(y[2], 
    return float4(webgl_fromSnorm8(x), webgl_fromSnorm8(y), 
    return float4(webgl_fromUnorm8(x), webgl_fromUnorm8(y), 
    return generateOutput();
    return int(round(clamp(x, -1.0, 1.0) * 127.0));
    return int(round(clamp(x, -1.0, 1.0) * 32767.0));
    return int2(width, height);
    return int3(width, height, depth);
    return isnan;
    return ldexp(x, float(exp));
    return ldexp(x, float2(exp));
    return ldexp(x, float3(exp));
    return ldexp(x, float4(exp));
    return log(x + sqrt(pow(x, 2.0) + 1.0));
    return log(x + sqrt(x + 1.0) * sqrt(x - 1.0));
    return mantissa;
    return mul(float2x1(r), float1x2(c));
    return mul(float2x1(r), float1x3(c));
    return mul(float2x1(r), float1x4(c));
    return mul(float3x1(r), float1x2(c));
    return mul(float3x1(r), float1x3(c));
    return mul(float3x1(r), float1x4(c));
    return mul(float4x1(r), float1x2(c));
    return mul(float4x1(r), float1x3(c));
    return mul(float4x1(r), float1x4(c));
    return output;
    return rounded;
    return structure;
    return true;
    return uint(round(clamp(x, 0.0, 1.0) * 255.0));
    return uint(round(clamp(x, 0.0, 1.0) * 65535.0));
    return v * 0.00390625;
    return v * exp2(exponent) * (float
    return v * exp2(exponent) * vec
    return v;
    return x - y * floor(x / y);
    return x - y;
    return x * 0.00390625;
    return x * exp2(exponent) * float(isNonZero);
    return x + y;
    return x;
    rounded[
    SamplerMetadata samplerMetadata[
    struct SamplerMetadata
    t.x = (u * 0.5f / m) + 0.5f;
    t.y = (v * 0.5f / m) + 0.5f;
    uint a = (x & 0xffffu);
    uint ad = a * d + ((a * c) >> 16);
    uint b = (x >> 16);
    uint baseMask = ~insertMask;
    uint bc = b * c;
    uint c = (y & 0xffffu);
    uint carry = uint(ad > (0xffffffffu - bc));
    uint d = (y >> 16);
    uint dx_LocalInvocationIndex : 
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint lastVertexIndex = 
    uint lastVertexIndex = (primitiveID % 2 == 0 ? 2 : 1);
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    uint maskMsb = (1u << (bits - 1));
    uint mip = 0;
    uint mip = bias;
    uint mip = uint(min(max(round(lod), 0), levels - 1));
    uint resultUnsigned = (asuint(base) & baseMask) | ((asuint(insert) << offset) & 
    uint resultUnsigned = (asuint(value) & mask) >> offset;
    uint unsignedLsb;
    uint unsignedMsb;
    uint w = (u >> 24) & 0xffu;
    uint w = (u >> 24);
    uint w = webgl_toUnorm8(v.w);
    uint width; uint height;
    uint width; uint height; uint depth;
    uint width; uint height; uint depth; uint numberOfLevels;
    uint width; uint height; uint numberOfLevels;
    uint width; uint height; uint samples;
    uint x = f32tof16(v.x);
    uint x = u & 0xffffu;
    uint x = u & 0xffu;
    uint x = u;
    uint x = webgl_toUnorm16(v.x);
    uint x = webgl_toUnorm8(v.x);
    uint y = (u >> 16);
    uint y = (u >> 8) & 0xffu;
    uint y = (u >> 8);
    uint y = f32tof16(v.y);
    uint y = webgl_toUnorm16(v.y);
    uint y = webgl_toUnorm8(v.y);
    uint z = (u >> 16) & 0xffu;
    uint z = (u >> 16);
    uint z = webgl_toUnorm8(v.z);
    uint2 resultUnsigned = (asuint(base) & baseMask) | ((asuint(insert) << offset) & 
    uint2 resultUnsigned = (asuint(value) & mask) >> offset;
    uint3 dx_GlobalInvocationID : 
    uint3 dx_LocalInvocationID : 
    uint3 dx_WorkGroupID : 
    uint3 gl_NumWorkGroups : packoffset(c0);
    uint3 resultUnsigned = (asuint(base) & baseMask) | ((asuint(insert) << offset) & 
    uint3 resultUnsigned = (asuint(value) & mask) >> offset;
    uint4 resultUnsigned = (asuint(base) & baseMask) | ((asuint(insert) << offset) & 
    uint4 resultUnsigned = (asuint(value) & mask) >> offset;
    umulExtended_emu(uint(abs(x)), uint(abs(y)), unsignedMsb, unsignedLsb);
    umulExtended_emu(x.w, y.w, msb.w, lsb.w);
    umulExtended_emu(x.x, y.x, msb.x, lsb.x);
    umulExtended_emu(x.y, y.y, msb.y, lsb.y);
    umulExtended_emu(x.z, y.z, msb.z, lsb.z);
    v = clamp(v, -2.0, 2.0);
    v = clamp(v, -65504.0, 65504.0);
    v = sign(v) * floor(abs(v));
    v = v * 256.0;
    v = v * exp2(-exponent);
    v[0] = (frac(x[0]) == 0.5 && trunc(x[0]) % 2.0 == 0.0) ? trunc(x[0]) : round(x[0]);
    v[1] = (frac(x[1]) == 0.5 && trunc(x[1]) % 2.0 == 0.0) ? trunc(x[1]) : round(x[1]);
    v[2] = (frac(x[2]) == 0.5 && trunc(x[2]) % 2.0 == 0.0) ? trunc(x[2]) : round(x[2]);
    v[3] = (frac(x[3]) == 0.5 && trunc(x[3]) % 2.0 == 0.0) ? trunc(x[3]) : round(x[3]);
    VS_OUTPUT output;
    webgl_fromSnorm8(z), webgl_fromSnorm8(w));
    webgl_fromUnorm8(z), webgl_fromUnorm8(w));
    width = max(width >> lod, 1);
    x = angle_frl(angle_frl(x) 
    x = angle_frm(angle_frm(x) 
    x = clamp(x, -2.0, 2.0);
    x = clamp(x, -65504.0, 65504.0);
    x = sign(x) * floor(abs(x));
    x = x * 256.0;
    x = x * exp2(-exponent);
    x[2]), atan2(y[3], x[3]));
   selectView(output, input[
 !"#$%%%%%%&%'%%()*+%%,-%.
 !"#$%&'
 !"#$%&'()
 !"#$%&'()*+,-./01
 !"#$%&'()*+,-./0123456789:;<=>
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOP
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVVVWXYZ[\]^_`abcdefghiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkklmmmnnnooopppqrstuvwxyz{|}~
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
 !"#$%&'()*+,-./0123456789:;<=>@ABCDEFGHIJKLMNOPRSTUVWXYZ[\]^_`abcdg
 !%&'()*+,-./01234
 (ANGLE 
 (const float)
 (const int)
 (const uint)
 (const yuvCscStandardEXT)
 (field '
 (internal function)
 (or there is no acceptable conversion)
' (or there is no acceptable conversion)
 (structure contains a sampler)
 (symbol id 
 * coordWrapped));
 * frac(
 / t.w
 / t.z
 : register(b
 : register(s
 : register(t
 : register(u
 + float(
 <<= 
 = clamp(int(floor(
 = false;
 = input.v
 = int(floor(
 = mul(
 = transpose(mul(transpose(
 = true; break;}
 == 1)
 == 3)
 >>= 
 A^_^
 A^A]_
 A^A]A\
 A__^
 A_A\_
 A_A^]
 A_A^_
 A_A^_^[
 A_A^_^]
 A_A^A\
 A_A^A\_^
 A_A^A\_^][
 A_A^A]
 A_A^A]_^
 A_A^A]A\]
 A_A^A]A\^
 A_A^A]A\_
 A_A^A]A\_^]
' aliases attribute '
 and '
' and a right operand of type '
 angle_compound_
 angle_frl(
 angle_frl(in 
 angle_frm(
 angle_frm(in 
' at location 
' between vertex and fragment shaders
 bytes each exceeds the maximum buffer size.
 cache limit of 
 cannot initialize this type of qualifier 
 components (
' conflicting location with previously defined '
 conflicts with 
 differ between vertex and fragment shaders
' differ between vertex and fragment shaders
 differ between vertex and fragment shaders.
 differs between vertex and fragment shaders.
 Direct3D11
 does not exist in the vertex shader.
 does not match any vertex varying
 elements, removing the least recently used to make room.
 exceeds maximum allowed nesting level of 
' exists that takes a left-hand operand of type '
' exists that takes an operand of type 
 exponent = floor(log2(abs(v) + 1e-30)) - 10.0;
 exponent = floor(log2(abs(x) + 1e-30)) - 10.0;
 EXT_create_context_robustness.
 extra bytes in internal vertex buffer, it would result in an overflow.
 field selection requires structure or vector on left hand side
 field selection requires structure, vector, or interface block on left hand side
 flags. (
 for(
 GS_INPUT input[
 H;\$(u
 H3E H3E
 has internal format 
 Hc|$`3
 I;]8u
 indices of 
 inout 
 is not requestable.
 is the maximum.
 is too big to fit
 isNonZero = exponent < -25.0;
 isNonZero = greaterThanEqual(exponent, vec
 left of '[' is not of type array, matrix, or vector 
 l-value of swizzle cannot have duplicate components
 l-value required
 m) {
 matrix of 
' member '
 Microsoft Corporation. All rights reserved.
 must be positive
 no such field in interface block
 no such field in structure
 non-matching types for const initializer 
' of 
 of interface block '
 out_
 Retrying with 
 rounded;
 sampler_
 samplers
 samples, 
 SHADER BEGIN
 SHADER END
 specified multiple times
 structure = { 
 supported in compute shaders only
 supported in GLSL ES 1.00 only
 supported in vertex shaders only
 texture_
 textures
' to '
 types are not allowed in interface blocks
 uint
 v) {
 valid for GLES with EGL 1.4 and KHR_create_context. Use
 with expression
 x) {
 x, in 
 y) {
!!!!!!!!
!!!!!!!! 
!!!!!!!!!
!!#$%#+$
!"#$%&
!l$XI
!t$0H
!This program cannot be run in DOS mode.
"""""""
""#%o%#
"tmA+
#\$0A
#D$0A
#define ANGLE_POINT_SPRITE_SHADER
#define ANGLE_REQUIRES_IEEE_STRICT_COMPILING
#define ANGLE_USES_DISCARD_REWRITING
#define ANGLE_USES_NESTED_BREAK
#define FLATTEN
#define FLATTEN [flatten]
#define GL_ANGLE_MULTIVIEW_ENABLED
#define GL_USES_DEPTH_RANGE
#define GL_USES_FRAG_COLOR
#define GL_USES_FRAG_COORD
#define GL_USES_FRAG_DATA
#define GL_USES_FRAG_DEPTH
#define GL_USES_FRONT_FACING
#define GL_USES_GLOBAL_INVOCATION_ID
#define GL_USES_LOCAL_INVOCATION_ID
#define GL_USES_LOCAL_INVOCATION_INDEX
#define GL_USES_MRT
#define GL_USES_NUM_WORK_GROUPS
#define GL_USES_POINT_COORD
#define GL_USES_POINT_SIZE
#define GL_USES_VIEW_ID
#define GL_USES_WORK_GROUP_ID
#define LOOP
#define LOOP [loop]
#else
#endif
#endif  // ANGLE_POINT_SPRITE_SHADER
#ifdef ANGLE_ENABLE_LOOP_FLATTEN
#ifndef ANGLE_POINT_SPRITE_SHADER
#line 
#pragma pack_matrix(column_major)
#pragma pack_matrix(row_major)
#pragma STDGL invariant(all) can not be used in fragment shader
#version directive must occur before anything else, except for comments and white space
#version directive must occur on the first line of the shader
$E9>~YE
$I;]8
$I;L$
$I9q`t
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%d)\%hs!%p: 
&$"##!
&2&]1
&-ON.
(|$ H
(|$ I
(|$@D
(|$@I
(|$0D
(|$0I
(|$pL
(-25.0));
(A_A^_]
(A_A^A]A\_^][
(adapter LUID: %08x%08x)
(C3,(
(caller: %p) 
(D$ f
(D$ H
(D$ L
(D$@f
(D$@H
(D$`L
(D$0H
(D$0I
(H;\$`u
(input.
(isNonZero);
(L$pA
(out 
(symbol id 
(t$ H
(t$@L
(t$0D
(t$0H
(t$0L
(t$PL
) - 1);
) { return false; }
) at location 
) exceed the maximum interleaved components (
) exceed the maximum separate components (
)' used in the following call chain:
) with the following call chain: 
)(isNonZero);
))(*&)),).
)*+.-01563489;=?ACE
), bias
), ddx, ddy
), index
), lod
), t.w
), t.z
), transpose(
)\$`M
)\$pD
)\,(?%-*+++./S00189R232245666;<@WWW272QOAE2FFF222EGHEEE2 JJJ11D2KL222C222:222ZZZ&2MM#"NNNEEE! ^^EETT^^UUUTT2^VVVX^^^^^2Y2WWW^H^L^[ZZZ^^^^^]
)|$ I
)A;h t
)D$ D
)D$`A
)d$`L
)D$0D
)D$0H
)D$pA
)d$pD
)d$pM
)D8a@u
)H;D$8sOI
)L$@@
)l$`D
)L$pA
)T$`A
)T$`H
)T$`M
)t$PD
*+,-./01234
*9k t1
*C34*
, 0.0)
, bias
, const uint 
, float bias
, float lod
, float2 ddx, float2 ddy
, float2 t
, float3 ddx, float3 ddy
, float3 t
, float4 data
, float4 t
', in fragment: '
, int index
, int lod
, int mip
, int2 offset
, int2 p
, int2 t
, int3 offset
, int3 p
, int3 t
, int4 data
, lod
, mip)
, offset
, sampler_
, texture_
, transpose(
, uint4 data
,/27:<>@BDFW
,'H9]P
./0123
.?AV<lambda_0296470f3aa677865b67e6d0cd54446b>@@
.?AV<lambda_1b3dd992f53350e8571a7fd65b6dbaae>@@
.?AV<lambda_30752acf91dc37c42379b18b4ad5f90a>@@
.?AV<lambda_8d5bc7bc0cac28deff49146e5fb64a2d>@@
.?AVtype_info@@
.00cfg
.bss$00
.bss$dk00
.bss$pr00
.bss$zz
.CRT$XCA
.CRT$XCAA
.CRT$XCB
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.data
.data$00
.data$00$brc
.data$dk00
.data$dk00$brc
.data$r$brc
.data$zz
.data$zz$brc
.didat$2
.didat$3
.didat$4
.didat$5
.didat$7
.edata
.GetDimensions(0, width, height, depth, levels);
.GetDimensions(0, width, height, layers, levels);
.GetDimensions(0, width, height, levels);
.GetDimensions(baseLevel, width, height, depth, numberOfLevels);
.GetDimensions(baseLevel, width, height, numberOfLevels);
.GetDimensions(mip, width, height, depth, levels);
.GetDimensions(mip, width, height, layers, levels);
.GetDimensions(mip, width, height, levels);
.GetDimensions(width, height);
.GetDimensions(width, height, depth);
.GetDimensions(width, height, samples);
.gfids
.giats
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.length()
.Load(
.pdata
.rdata
.rdata$00
.rdata$brc
.rdata$r
.rdata$T$brc
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zz
.rdata$zz$brc
.rdata$zzzdbg
.rsrc
.rsrc$01
.rsrc$02
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.Sample(
.SampleBias(
.SampleCmp(
.SampleCmpLevelZero(
.SampleGrad(
.SampleLevel(
.stls
.text
.text$di
.text$lp00edgeangle.dll!20_pri7
.text$mn
.text$mn$00
.text$np
.text$x
.text$yd
.text$zy
.text$zz
.tls$
.tls$ZZZ
.xdata
.xyzw
// Array constructor functions
// Assignment functions
// Attributes
// COMPILER INPUT HLSL BEGIN
// COMPILER INPUT HLSL END
// Equality functions
// GEOMETRY SHADER BEGIN
// GLSL BEGIN
// GLSL END
// INITIAL HLSL BEGIN
// INITIAL HLSL END
// Structures from std140 blocks with padding removed
// Uniform Blocks
// Uniforms
// Varyings
//////
: (in vertex: '
': (in vertex: '
:ARB_texture_rectangle:
:ARM_shader_framebuffer_fetch:
:EXT_blend_func_extended:
:EXT_draw_buffers:
:EXT_frag_depth:
:EXT_shader_framebuffer_fetch:
:EXT_shader_texture_lod:
:EXT_YUV_target:
:FragmentPrecisionHigh:
:MaxAtomicCounterBindings:
:MaxAtomicCounterBufferSize:
:MaxCallStackDepth:
:MaxCombinedAtomicCounterBuffers:
:MaxCombinedAtomicCounters:
:MaxCombinedImageUniforms:
:MaxCombinedShaderOutputResources:
:MaxCombinedTextureImageUnits:
:MaxComputeAtomicCounterBuffers:
:MaxComputeAtomicCounters:
:MaxComputeImageUniforms:
:MaxComputeTextureImageUnits:
:MaxComputeUniformComponents:
:MaxComputeWorkGroupCountX:
:MaxComputeWorkGroupCountY:
:MaxComputeWorkGroupCountZ:
:MaxComputeWorkGroupSizeX:
:MaxComputeWorkGroupSizeY:
:MaxComputeWorkGroupSizeZ:
:MaxDrawBuffers:
:MaxDualSourceDrawBuffers:
:MaxExpressionComplexity:
:MaxFragmentAtomicCounterBuffers:
:MaxFragmentAtomicCounters:
:MaxFragmentImageUniforms:
:MaxFragmentInputVectors:
:MaxFragmentUniformVectors:
:MaxFunctionParameters:
:MaxGeometryAtomicCounterBuffers:
:MaxGeometryAtomicCounters:
:MaxGeometryImageUniforms:
:MaxGeometryInputComponents:
:MaxGeometryOutputComponents:
:MaxGeometryOutputVertices:
:MaxGeometryShaderInvocations:
:MaxGeometryShaderStorageBlocks:
:MaxGeometryTextureImageUnits:
:MaxGeometryTotalOutputComponents:
:MaxGeometryUniformBlocks:
:MaxGeometryUniformComponents:
:MaxImageUnits:
:MaxProgramTexelOffset:
:MaxProgramTextureGatherOffset:
:MaxTextureImageUnits:
:MaxVaryingVectors:
:MaxVertexAtomicCounterBuffers:
:MaxVertexAtomicCounters:
:MaxVertexAttribs:
:MaxVertexImageUniforms:
:MaxVertexOutputVectors:
:MaxVertexTextureImageUnits:
:MaxVertexUniformVectors:
:MaxViewsOVR:
:MinProgramTexelOffset:
:MinProgramTextureGatherOffset:
:NV_draw_buffers:
:NV_EGL_stream_consumer_external:
:NV_shader_framebuffer_fetch:
:OES_EGL_image_external:
:OES_EGL_image_external_essl3:
:OES_geometry_shader:
:OES_standard_derivatives:
:OVR_multiview:
:WEBGL_debug_shader_precision:
; ++i)
;\$@r
;]Hu2H
;ADr0
;ADr5
;C |.
;C t*
;D$(}|H
;D$(u
;G u&H
;P }#H
;P }$H
;P }&H
;Q |09Q |"
;Q |29Q |'
;Q }&H
;Q }'H
;S }T
;x }7I
;x s>H
;x s7I
;yp~QH
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@AEAH@Z
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@AEAI@Z
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@AEAM@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_K@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@I@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
?_BADOFF@std@@3_JB
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
?333?
?classic@locale@std@@SAAEBV12@XZ
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?fail@ios_base@std@@QEBA_NXZ
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
?flags@ios_base@std@@QEAAHH@Z
?flags@ios_base@std@@QEBAHXZ
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
?good@ios_base@std@@QEBA_NXZ
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?imbue@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAA?AVlocale@2@AEBV32@@Z
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
?Index buffer map range is not inside the buffer.
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?precision@ios_base@std@@QEAA_J_J@Z
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
?RSDS:I
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
?setf@ios_base@std@@QEAAHH@Z
?setf@ios_base@std@@QEAAHHH@Z
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
?unsetf@ios_base@std@@QEAAXH@Z
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
?width@ios_base@std@@QEAA_J_J@Z
?width@ios_base@std@@QEBA_JXZ
?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEBD_J@Z
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
@ A9B
@ Ic@$
@$A8B
@$A9A
@$A9B
@$A9F
@%A8B
@(A9A
@(A9B
@(H9G
@(I9B
@.data
@.didat
@.reloc
@@ PIXEL OUTPUT @@
@@ VERTEX ATTRIBUTES @@
@0I9B
@49B4u
@8~*t
@8=Re
@80t+H
@8l$(
@8n:t
@8qQu
@8s4u
@8t$ t
@8t$ tRH
@8t$0
@8t$p
@8w t
@8w!t
@8w"t
@8w#t
@8whv
@8wiw
@8xhu
@A^_^
@A^_^][
@A^A\]
@A_A]A\_^
@A_A^]
@A_A^_
@A_A^A\
@A_A^A\^]
@A_A^A\_^
@A_A^A\_^[]
@A_A^A]
@A_A^A]A\_^[
@A_A^A]A\_^]
@ABCDEFGHIJKLMNOP
@EGL_ANGLE_robust_resource_initialization
@H;|$8
@H9SHw
@HLcC8H
@PA:AQ
@pI9@hu
@SUVWATAUAVAWH
@SUVWATAVAWH
@SUVWAVAWH
@SUVWAVH
@SUVWH
@SVWAVAWH
@SVWH
@USVATAUAVH
@USVAUAVH
@USVAVAWH
@USVWATAUAVAWH
@USVWATAUAVH
@USVWATAUH
@USVWATAVAWH
@USVWATAVH
@USVWAUAVAWH
@USVWAVAWH
@USVWAVH
@USVWH
@USWATAUAWH
@USWAVAWH
@USWH
@UVAVH
@UVWH
@UWATAUAWH
@UWAVAWH
@VWAVH
@WAVH
@x#Bx
[%hs(%hs)]
[%hs]
[maxvertexcount(
[numthreads(
[p] = data;
[samplerArrayIndex]
[samplerIndex]
[textureIndex]
[uint2(p.x, p.y)];
[uint3(p.x, p.y, p.z)];
\$ E3
\$ E8j
\$ H;\$(t4H
\$ H+
\$ I;
\$ I;^
\$ L+
\$ UH
\$ UVATAUAVH
\$ UVWATAUAVAWH
\$ UVWAVAWH
\$ UVWH
\$ VWAWH
\$ WH
\$(E3
\$@E3
\$@H;
\$@H+
\$@H9V
\$`E3
\$`H;
\$0H+
\$0H9O
\$0I;
\$8A;
\$PH;
\$PHc
\$pI;
\$PI+
\$XE3
] * viewportScale * gl_PointSize, 0.0f, 0.0f);
] : packoffset(
] of 
], input[lastVertexIndex]);
]0H9W
]8H9W(t
]PH;W
]t<A;
^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^`^^a^^^^^^^^^^^^^^^^b^^
^PI+^HH
^pL)k
_ H;_ 
__^^^^^^^^^^^^^^^^
__C_specific_handler
__CxxFrameHandler3
__FILE__
__LINE__
__samplerExternal2DY2YEXT
__std_terminate
__VERSION__
_ctor
_External
_fdtest
_frl(inout 
_frm(inout 
_initterm
_initterm_e
_level_9_3
_o___acrt_iob_func
_o___std_type_info_destroy_list
_o___stdio_common_vfprintf
_o___stdio_common_vsprintf
_o___stdio_common_vsprintf_s
_o___stdio_common_vswprintf
_o__cexit
_o__configure_narrow_argv
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__fdsign
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__invalid_parameter_noinfo_noreturn
_o__purecall
_o__register_onexit_function
_o__seh_filter_dll
_o__wcsicmp
_o_acoshf
_o_asinhf
_o_atanhf
_o_atoi
_o_ceil
_o_exit
_o_exp2f
_o_free
_o_fwrite
_o_isdigit
_o_log
_o_malloc
_o_mbstowcs_s
_o_pow
_o_powf
_o_realloc
_o_round
_o_roundf
_o_strcpy_s
_o_strtoul
_o_wcstombs
_type
_webgl_
_webgl_struct_
` AUAVAWH
` AUAVAWL
` AVAWL
` UAVAWH
`.rdata
`A^_^[]
`A^_^][
`A^A]^[]
`A_A^_^]
`A_A^A\_^[]
`A_A^A]A\_^]
{ AVH
{Break
{int 
|#H=P4
|$ (H
|$ A;
|$ ATAVAWH
|$ AVH
|$ D;v
|$ E3
|$ I+
|$ UATAUAVAWH
|$ UATAVH
|$ UATAWH
|$ UAVAWH
|$ UH
|$(A^
|$(D8v
|$(E3
|$(I+
|$(L+
|$@A_A^A]A\
|$@E3
|$@H9V0tDD
|$@L;
|$`@I
|$`D88t/H
|$`E3
|$`L;
|$09|$ tDH
|$0A_A^
|$0E3
|$0H9S
|$0H9V
|$0Ic
|$8A_A^A\
|$A;@
|$DH9W
|$HE3
|$hE3
|$HE3
|$HM;
|$P@8
|$p9o t
|$PD88
|$pdu
|$PE3
|$pfA
|$PH;
|$pH;
|$PH9S
|$PI;
|$pI;
|$X@88
|$xD8
|$XE3
|$XH+
|$XH9S
|)A;B
|9A9x
|H;D$`
}@L9z
}_@8{
}>LcB
}0H+}(H
}8H9S
~`D;w(t^N
~}|{yxvutsrqnmlkjihgedcba`_]\[WS5/-' 
~0D9U
~ujowpNxqOyzv
+0+++555++++++/ ///11
+D9p t
+L$(A
+L$`A
+T$dE
< L;|$x
<1;|$(t
<PJ*Ax
<unknown op>
=D9`t
>!w"Hc
>?t_H
>m^-|
0 (ANGLE 
013M1M300,^01.^3.00102HH
040904B0
0A^_]
0A^_^
0A^_^[]
0A^A]A\
0A^A]A\_^
0A__^
0A_A\]
0A_A^]
0A_A^_
0A_A^_^]
0A_A^A\
0A_A^A\_^
0A_A^A]
0A_A^A]_]
0A_A^A]A\]
0A_A^A]A\_
0A_A^A]A\_^]
0D9s u$H
11.00.17763.1
11.00.17763.1 (WinBuild.160101.0800)
1A;p 
1A;p t
1fB341f
1I;p 
2.1.0.d0cdd066eca2
2^^^^^`^^^^a^^++EEb/22^32c2^^^GK^22^^2^
222TTT
2333333
23456789:%;<=>?@%ABCDEFGHIJKLM
23456789:;<=>?@AB
2D_comparison
2D_int4_
2D_snorm_float4_
2D_uint4_
2D_unorm_float4_
2DArray
2DArray_comparison
2DArray_int4_
2DArray_snorm_float4_
2DArray_uint4_
2DArray_unorm_float4_
2DMS_int4_
2DMS_uint4_
2fB3<2f
2H;D$@stE3
2KK2fLp
2t^A+
2VL=N
3333333
333EEE
3D_int4_
3D_snorm_float4_
3D_uint4_
3D_unorm_float4_
3L$`#D$`
3L$X#D$X
6789:;<:::::::::::::::::::::::::::===============:::=========================::::?@ADFHHHHHHHHHH
7*($&)&
7fA#U
8 8@8`8
8?u5H
8\$ht3
8\$Xt:
8]HurH
8_^][
8A(rQ:A(r
8A)rCA
8A_A^A]A\_^][
8D9{ t^
8E8Vt
8H$re:H$r
8H%rW:H%r
9\$@H
9\$@t)H
9\$Dw'9\$Hw!H9_ 
9\$P~;
9]0u+D9u4u%
93~*E3
98u5D9X
99t"H
9A u6
9A$|_;A$|
9A$u.
9A9x 
9C |2;C |
9C tJ
9C$|$H
9C(|*2
9D$ u
9D$$t
9D$(vE
9D$@H
9H |%;H |
9H |s;H |%A
9H(|IH
9HDu69~
9I9x 
9JcD'
9p$t%H
9t$htOH
9t$Pt
9t$Xu
9w }&
9z rjH
A A;P4v
A buffer must be bound.
A program must be bound.
A renderbuffer must be bound.
a struct cannot be used as a constructor argument for this type
A texture must be bound.
A$9G$|#;G$|
A$A9@
A$A9C
A(8G(r
A(A8@
A(A9@
A(A9C
A(H+A H
A)8G)r
A)A8@
a/XpL
A:A(r
A;A t
A;A$u
A;H t
A;P |
A;Q |
A;q s&I
A;X t
A;Y@A
A@H9A8u
A]A\[]
A]A\_^[]
A^_^[]
A^_^][
A^A\]
A^A\_[]
A^A\_^[]
A^A\_^]
A^A]A\^[]
A^A]A\^]
A^A]A\_]
A^A]A\_^[]
A_A\]
A_A\_^[
A_A\_^]
A_A]]
A_A]A\_[]
A_A]A\_]
A_A]A\_^
A_A^]
A_A^^[]
A_A^_
A_A^_[]
A_A^_^[]
A_A^_^]
A_A^_^][
A_A^A\
A_A^A\_]
A_A^A\_^
A_A^A\_^[]
A_A^A\_^][
A_A^A]
A_A^A]_]
A_A^A]_^
A_A^A]_^[]
A_A^A]A\]
A_A^A]A\_
A_A^A]A\_^[]
A_A^A]A\_^]
A_A^A]A\_^][
A8@hv
A8@iE
A8@Pv
A8@Qu
A8^)H
A8A(r
A8A)r
A8APv
A8AQu
A8H9x
A8IUu{
A8L9@
A8L9H
A9A |
A9A t
A9A u$I
A9A$|
A9A$|(A;A$|
A9A$u
A9A(|
A9ADA
A9B$}1H
A9B$u
A9B(|
A9E`u{A
A9EDu
A9EHu
A9G`A
A9P |
A9Q |
A9Q t
A9r sEH
A9r t
acos(
acosf
acosh
AcquireSRWLockExclusive
AcquireSRWLockShared
Active attribute (
ActivityStoppedAutomatically
add second child into first child
AhI9Bh
All contexts within a share group must be created with the same value of EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE.
An enabled vertex array has no buffer and no pointer.
An enabled vertex array has no buffer.
angle
ANGLE (
ANGLE Display::initialize error 
angle::DestroyThenDelete<class gl::Context,class egl::Display>::operator ()
angle::DestroyThenDelete<class gl::Texture,class gl::Context>::operator ()
angle::DestroyThenDelete<class rx::TextureStorage,class gl::Context>::operator ()
angle::TrimCache
angle_
angle_assign
angle_compound_
angle_construct_into
ANGLE_ENABLE_LOOP_FLATTEN
angle_eq
angle_eq_
angle_frl
angle_frm
ANGLE_lossy_etc_decode extension is not supported.
ANGLE_REQUIRES_IEEE_STRICT_COMPILING
angle_return
ANGLE_texture_rectangle extension not present
ANGLE_USES_DISCARD_REWRITING
ANGLE_USES_NESTED_BREAK
Aon9\
Aon9d
Aon9p
Aon9t
APA8@P
APA8@PukA
ApH;Axu
APH9AHt
APH9AHu
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-delayload-l1-1-0.dll
api-ms-win-core-delayload-l1-1-1.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-2.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-1.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-libraryloader-l1-2-1.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-shlwapi-legacy-l1-1-0.dll
api-ms-win-core-shlwapi-obsolete-l1-1-0.dll
api-ms-win-core-string-obsolete-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-sysinfo-l1-2-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-crt-math-l1-1-0.dll
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-runtime-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
APOSITION
AQA8@Qua
ARB_texture_rectangle
ARM_shader_framebuffer_fetch
array / non-array mismatch
Array constructor argument has an incorrect type
array constructor needs one argument per array element
array constructor supported in GLSL ES 3.00 and above only
array index for gl_FragData must be constant zero
array index for gl_FragData must be zero when GL_EXT_draw_buffers is disabled
array index out of range
array indexes for fragment outputs must be constant integral expressions
array indexes for uniform block arrays and shader storage block arrays must be constant integral expressions
Array length
array members of interface blocks must specify a size
array members of structs must specify a size
array size mismatch
array size must be a constant integer expression
array size must be greater than zero
array size must be non-negative
Array size or input primitive declaration doesn't match the size of earlier sized array inputs.
array size too large
Array sizes differ for interface block '
Array sizes for 
array[
arrays of arrays supported in GLSL ES 3.10 only
asfloat(
asin(
asinf
asinh
asint(
assign
assigning non-constant to '
asuint(
At least one enabled attribute must have a divisor of zero.
atan(
atan2f
atanf
atanh
ATAUAVH
ATAVAWH
atomic counter
atomic counter binding greater than gl_MaxAtomicCounterBindings
atomic counter count exceeds MAX_COMBINED_ATOMIC_COUNTERS
atomic_uint
atomicAdd
atomicAnd
atomicCompSwap
atomicCounter
atomicCounterDecrement
atomicCounterIncrement
atomicExchange
atomicMax
atomicMin
atomicOr
atomicXor
Attached compute shader is not compiled.
Attachment type must be compatible with attachment object.
Attempting to read from a multi-view framebuffer.
attribute
Attribute '
Attribute EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM requires EGL_CHROMIUM_create_context_bind_generates_resource.
Attribute EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE requires EGL_ANGLE_create_context_client_arrays.
Attribute EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE requires EGL_ANGLE_program_cache_control.
Attribute EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE requires EGL_ANGLE_create_context_webgl_compatibility.
Attribute EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE requires EGL_ANGLE_display_texture_share_group.
Attribute EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE requires EGL_ANGLE_robust_resource_initialization.
Attribute must be EGL_TRUE or EGL_FALSE.
Attributes that begin with 'gl_' are not allowed.
Attributes that begin with 'webgl_', or '_webgl_' are not allowed.
atVA+
AuthD
authhost.exe
avoid flow control
B 9A 
B$9A$
B(9A(
B(HcH
B,A9@,
B^^BBI^IIIPP
B<A9@<
B842u
Bad access.
Bad allocation.
Bad attribute.
Bad config.
Bad context.
Bad current surface.
Bad device.
Bad display.
Bad match.
Bad native window.
Bad parameter.
Bad platform type.
Bad state.
Bad stream.
Bad surface.
barrier
Base level must be 0 for external textures.
Base level must be 0 for multisampled textures.
Base level must be 0 for rectangle textures.
Basic Render
bbbcc^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
behavior invalid
BhH9Ahu
bias(
binding
Binding for fragment input 
Binding layout qualifiers for 
bitCount
bitfieldExtract
bitfieldInsert
bitfieldReverse
bit-wise and
bit-wise and second child into first child
bit-wise not
bit-wise operator supported in GLSL ES 3.00 and above only
bit-wise or
bit-wise or second child into first child
bit-wise shift first child left by second child
bit-wise shift first child right by second child
bit-wise shift left
bit-wise shift right
bit-wise xor
bit-wise xor second child into first child
blend state
BlendState
Blit11 2D depth pixel shader
Blit11 2D input layout
Blit11 2D vertex shader
Blit11 3D geometry shader
Blit11 3D input layout
Blit11 3D vertex shader
Blit11 Alpha Mask Blend
Blit11::initResources
Blit11::mResolveDepthPS
Blit11::mResolveDepthStencilPS
Blit11::mResolveDepthStencilVS
Blit11::mResolveStencilPS
bool 
bool Break
bool isnan_emu(float x)
bool xor(bool p, bool q)
bool2
bool2 isnan_emu(float2 x)
bool3
bool3 isnan_emu(float3 x)
bool4
bool4 isnan_emu(float4 x)
boolean expression expected
Border must be 0.
Both a compute and non-compute shaders are attached to the same program.
BP8APu
BQ8AQu
Branch: Break
Branch: Continue
Branch: Kill
Branch: Return
Branch: Unknown Branch
break
break statement only allowed in loops and switch statements
browser.exe
browser_broker.exe
bs_unspecified
BtA9@t
buffer
Buffer
Buffer size does not align with data type.
Buffer value is greater than MAX_DRAW_BUFFERS
Buffer4F
Buffer4I
Buffer4UI
BufferCopyParams
built-in functions cannot be redefined
bvec2
bvec3
bvec4
C 9G 
C H+C
c UAVAWH
C(I9@
C(L;G
C:\fakepath
C`H9CX
C0A9B0s
C0H9C(
C0I9@
C9fD97u-
Call a built-in function
Call an internal function with raw implementation
Call an user-defined function
Call stack too deep (larger than 
CallContext:[%hs] 
Can only be highp
cannot apply dot operator to an array
cannot be a parameter type except for '(void)'
cannot be a structure containing a bool
cannot be a structure containing a structure
cannot be a structure containing an array
cannot be an array of structures
cannot be array
cannot be bool
cannot be bool or int
cannot be matrix
Cannot be qualified as invariant.
cannot be used with a structure
cannot be used with a yuvCscStandardEXT
Cannot change active program while transform feedback is unpaused.
cannot construct this type
cannot convert a variable with type 
cannot convert a variable with writeonly
cannot convert a void
cannot convert from '
cannot declare arrays of arrays
cannot declare arrays of structs of this qualifier
cannot declare arrays of this qualifier
cannot declare buffer variables at global scope(outside a block)
Cannot have multiple different invocations specifiers
Cannot have multiple different max_vertices specifiers
Cannot have multiple different primitive specifiers
Cannot have multiple different work group size specifiers
Cannot have negative height or width.
Cannot have negative start.
Cannot have negative stride.
Cannot link program while program is associated with an active transform feedback object.
Cannot load program binaries across different ES context versions.
Cannot pack these varyings on D3D9.
cannot use both gl_FragData and gl_FragColor
cannot use both output variable sets (gl_FragData, gl_SecondaryFragDataEXT) and (gl_FragColor, gl_SecondaryFragColorEXT)
Cannot use negative values in PixelStorei
can't modify a const
can't modify a readonly variable
can't modify a uniform
can't modify a variable with type 
can't modify a varying
can't modify an attribute
can't modify an input
can't modify any member in gl_in
can't modify gl_FragCoord
can't modify gl_FrontFacing
can't modify gl_GlobalInvocationID
can't modify gl_InvocationID
can't modify gl_Layer in a fragment shader
can't modify gl_LocalInvocationID
can't modify gl_LocalInvocationIndex
can't modify gl_NumWorkGroups
can't modify gl_PointCoord
can't modify gl_PrimitiveID in a fragment shader
can't modify gl_PrimitiveIDIn
can't modify gl_ViewID_OVR
can't modify gl_WorkGroupID
can't modify gl_WorkGroupSize
can't modify void
can't modify work group size variable
Capture of array elements is undefined and not supported.
Capture of arrays is undefined and not supported.
case (
case label must be a scalar integer
case label must be constant
case label must have a condition
case label type does not match switch init-expression type
case labels need to be inside switch statements
cbuffer 
cbuffer DriverConstants : register(b0)
cbuffer DriverConstants : register(b1)
CD$ H
CD$`I
CD$0H
CDEFGHIJKLMNOPQRS
CDEFGHIJKLMNOPQRSTU
ceil(
ceilf
centroid
chakra.dll
ChH9Ght
CL$ L
Cl$8L
CL$PM;A
clamp
clamp(
Cleanup: discarding lookahead
Cleanup: popping
Clear11 GS Multiview
Clear11 PS Depth
Clear11 PS Float1
Clear11 PS Float2
Clear11 PS Float3
Clear11 PS Float4
Clear11 PS Float5
Clear11 PS Float6
Clear11 PS Float7
Clear11 PS Float8
Clear11 PS FloatFL9
Clear11 PS Sint1
Clear11 PS Sint2
Clear11 PS Sint3
Clear11 PS Sint4
Clear11 PS Sint5
Clear11 PS Sint6
Clear11 PS Sint7
Clear11 PS Sint8
Clear11 PS Uint1
Clear11 PS Uint2
Clear11 PS Uint3
Clear11 PS Uint4
Clear11 PS Uint5
Clear11 PS Uint6
Clear11 PS Uint7
Clear11 PS Uint8
Clear11 VS
Clear11 VS FL9
Clear11 VS Multiview
Clear11::ensureResourcesInitialized
client buffer is not a ID3D11Texture2D
Client data cannot be used with a non-default vertex array object.
CloseHandle
CloseThreadpoolTimer
Code block
coherent
COLOR
Color buffer component types are not compatible.
Color buffer sizes are not compatible.
Color buffer types are not compatible.
color_Float
color_Sint
color_Uint
ColorAndDepthDataFloat
ColorAndDepthDataSint
ColorAndDepthDataUint
column_major
comma
CompanyName
Compare Equal
Compare Greater Than
Compare Greater Than or Equal
Compare Less Than
Compare Less Than or Equal
Compare Not Equal
comparison operator only defined for scalars
Component must be in the range [0;3]
-component vector of 
component-wise equal
component-wise greater than
component-wise greater than or equal
component-wise less than
component-wise less than or equal
component-wise multiply
component-wise not
component-wise not equal
Compressed texture dimensions must exactly match the dimensions of the data passed in.
COMPUTE
Compute shader active uniforms exceed MAX_COMPUTE_UNIFORM_COMPONENTS (
Compute shader atomic counter count exceeds MAX_COMPUTE_ATOMIC_COUNTERS (
Compute shader image count exceeds MAX_COMPUTE_IMAGE_UNIFORMS (
compute shader precision not yet implemented.
Compute shader sampler count exceeds MAX_COMPUTE_TEXTURE_IMAGE_UNITS (
Compute shader shader storage block count exceeds GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS (
Compute shader uniform block count exceeds GL_MAX_COMPUTE_UNIFORM_BLOCKS (
ComputeShader
Condition
conflicting output locations with previously defined output '
const
const bool
const uint 
constant expression required
Constant folded addition overflowed to infinity
Constant folded division overflowed to infinity
Constant folded multiplication overflowed to infinity
Constant folded subtraction overflowed to infinity
Constant folded undefined addition generated NaN
Constant folded undefined multiplication generated NaN
Constant folded undefined subtraction generated NaN
Constant value cannot be passed for 'out' or 'inout' parameters.
CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination factors in the blend function.
Construct
constructing from a non-dereferenced array
constructing matrix from matrix can only take one argument
constructor
constructor can't be a structure definition
constructor does not have any arguments
Context does not support GL_ANGLE_texture_rectangle
Context has been lost.
Context lost.
continue
continue statement only allowed in loops
cosh(
coshf
Could not create additional swap chains or offscreen surfaces, 
Could not create compute shader.
Could not create depthstencil surface for new swap chain, 
Could not create DXGI factory.
Could not create geometry shader.
Could not create offscreen texture, 
Could not create pixel shader.
Could not create vertex shader.
Could not get offscreen texture shared handle, 
Could not pack varying 
Could not query DXGI device.
Could not query offscreen texture resource, 
Could not read DXGI adaptor description.
Could not retrieve DXGI adapter
Could not retrieve the window dimensions
Could not set thread local storage.
countbits(
CP8GPt
CPH9CX
CPH9CXu|L
CQ8GQu
CreateEventW
CreateMutexExW
CreateSemaphoreExW
CreateThreadpoolTimer
cross
cross product
cross(
CT$(3
CT$(H
CT$(I
CT$(L
CT$@I
CT$XH
Cube_comparison
Cube_float4_
Cube_int4_
Cube_snorm_float4_
Cube_uint4_
Cube_unorm_float4_
Cull mode not recognized.
Current driver does not support transform feedback in binary programs.
Current renderer doesn't support alpha-to-coverage
D$ @B
D$ A;
D$ D8l$!
D$ E3
d$ E3
D$ E3
D$ fA
D$ fD
D$ H#
D$ H;
d$ H;
D$ H;
D$ H9
D$ H9S
D$ H9W
D$ HcH
D$ I;
D$ I9D$(tCH
D$ L;
D$ M+
D$$H9S
D$(C9
D$(E3
d$(E3
D$(E3
d$(E3
D$(E3
d$(E3
D$(E3
d$(E3
D$(H;
D$(H9Q
d$(I;
D$(L;
D$(M#
D$(tQL
D$(tyL
D$(u>M
D$@A;
D$@E3
d$@E3
D$@E3
D$@f90t
D$@fD
D$@H;
d$@H+
D$@H9Q
D$@H9S
D$@H9V
D$@I;
d$@L;
D$@L;E
D$@vT2
D$\D;
D$`A;
d$`A8
D$`D+
D$`E3
D$`H;
D$`H9W
D$`I;
d$`I;
D$`I;
D$`L+
D$`M;F t
D$0=1
D$0A;
d$0A_A^
D$0D9D$ 
D$0D9r
D$0E3
D$0E9g
D$0fD98t
D$0H;
D$0H;C
D$0H;E8t
d$0H+
D$0H+
d$0H+
D$0H+
d$0H+
D$0H9S
D$0H9U
D$0H9W
D$0H9W0
D$0HcH
D$0HcK
D$0I;
D$0L;
D$0L;C0u
D$0t H
D$0t"L
D$8A;
d$8A_A^A]
D$8E3
D$8E9
D$8H;
d$8H+
D$8H9W
D$8HcH
D$8I;
D$8I9D$0
D$8L+D$0I
D$AE3
D$BE3
D$CE3
D$DH9O
D$H@2
D$hD9`
D$HE;
d$HE;
D$hE3
d$HE3
D$hE3
D$HH;
D$hH+
d$HH+
D$HH9S
D$hH9W
D$P@2
D$P@8~
d$pA;
D$PA8h
d$pD8 
D$pD8O
d$PE;
D$pE3
D$PE3
D$pE3
D$PE3
D$pE3
D$PE3
D$PfE
D$PH;
D$PH;C
D$pH9D$ht
D$PH9S
D$PH9T$0t
D$PH9W
D$PI;
D$pI;
D$PI;
D$PL;G 
D$PMcJ
D$pvI
D$t+E
D$T9p
D$TE3
D$tL;
D$x+E
D$X-3
D$X9~
D$XA;
D$XA9
D$XE3
d$XE3
D$xE3
D$XH;
D$xH+
D$xHc
D$XHcH
d$xI;
D$XIc
D$XL9d$huxM
d$xM;
D$XM+
D:L$Pu
D;@ }
D;` s
D;a(|
D;A(v
D;A(w
D;B }
D;C }T
D;c s
D;c t
D;H }
D;H }&H
D;H s
D;I t
D;I,u
D;L$xu^
D;P |
D;P }
D;P s
D;q t
D;T$(r
D;t$<
D;X }
D;X u
D+D$h
d0cdd066eca2
D3D compiler module not found.
D3D11 device creation extension not active
d3d11.dll
D3D11CreateDevice
D3DCompile
d3dcompiler_47.dll
D3DDisassemble
D8 t+H
D8$.u
D8$8u
D8,8u
D8.t;H
D8[st
D8\$(t
D8\$(u=H
D8\$P
D8]Pv
D8]QwFM;
D8|$0
D8<0u
D81t'L
D8APu
D8APv
D8APv;D8AQu5
D8AQu
D8AQwdE2
D8B,A
D8BPv
D8BQu
D8BQv
D8BQw.A:
D8BQw3D8APv$D8AQu
D8BQwYD8APv#D8AQu
D8d$"H
D8d$p
D8d$pu:L
D8g0uJH
D8h8u*
D8hfI
D8hhu%A
D8IquoH
D8MXt
D8MYu
D8odt
D8q(t.L
D8R(t$
D8xat
D8yAusL9y
D9@ }
D9@@u>
D9[ }6H
D9[ }oH
D9\$`
D9`(|
D9|$@t
D9} t,
D9}`t
D9}P|?
D9~HL
D9A }
D9a D
D9B$t
D9B$u
D9b(E
D9B0u
D9B4u
D9C(t
D9d$@
D9d$@t'H
D9d$`
D9d$`tFH
D9d$H
D9d$L
D9ePt
D9H v#H
D9H vT
D9h$u
D9h(u
D9h<A
D9I$w
D9I$w1D9I(w+
D9I(v
D9J t
D9l$@t(H
D9l$@t7H
D9l$p
D9m@tDH
D9mPt!L
D9O H
D9oHt'H
D9P |(H
D9P }
D9P }&H
D9p v#H
D9q tDH
D9S }
D9t$,r
D9t$0
D9t$P
D9w,tDH
D9Y t
DCIScanner
debug
DebugBreak
Declaration
default
Default
default labels need to be inside switch statements
default:
defghijkl
define
defined
degrees
degrees(
DelayLoadFailureHook
DeleteCriticalSection
DEPTH
Depth
depth
depth stencil state
DepthOnlyData
Depth-stencil buffer types are not compatible.
DepthStencilState
DepthStencilView
Desired resource size is greater than max texture size.
Destination internal format and type combination is not valid.
Destination texture a valid texture type.
Destination texture is immutable.
Destination texture is not a valid texture object.
Destination texture level is not valid.
Destination texture not large enough to copy to.
Destination width and height must be equal for cube map textures.
determinant
determinant(transpose(
Device creation extension not active
Device must have been created using eglCreateDevice
Device was lost while querying result of an event query.
Device was lost while waiting for sync.
dimension mismatch
direct index
direct index for interface block
direct index for structure
Direct3D platform is unsupported.
disable
disallowed type in struct
discard
discard supported in fragment shaders only
display had a context loss
display is EGL_NO_DISPLAY.
display is not a valid display.
display is not initialized.
Display type EGL_PLATFORM_ANGLE_TYPE_NULL_ANGLE requires EGL_ANGLE_platform_angle_null.
distance
distance(
divide
Divide by zero during constant folding
Divide by zero error during constant folding
divide second child into first child
division by zero
dot product
'dpy' not a valid EGLDisplay handle
'dpy' not initialized
Draw mode must match current transform feedback object's draw mode.
dummy
duplicate case label
duplicate default label
duplicate field name in structure
duplicate function prototype declarations are not allowed
duplicate macro parameter name
DXBC'
DXBC-
DXBC%8+
DXBC(H
DXBC(PW
DXBC@
DXBC@}n
DXBC\
DXBC\#
DXBC{
DXBC+
DXBC=
DXBC>w=
DXBC0Ta
DXBC2p
DXBC3Z1
DXBCa
DXBCE
DXBCi
DXBCj+
DXBCk
DXBCl
DXBClh
DXBCn
DXBCO
DXBCQ
DXBCR
DXBCT
DXBCu
DXBCU=<$!
DXBCvi
DXBCVy
DXBCY
DXBCY{
DXBCz
dyn_index_
Dynamic recompilation error log: 
E H;E
E(9],u
E(D8Hft
E;.uh
E;X t
E;Y |
E;Y }
E@!uTH
E@H9EHt
E@H9U
E@H9V
E`D8t$PuL
E0F9L
E0H9E(
E8ept
E8H9U
E8Yhv
E8Yhv E8Yit
E8Yiv
E9C(A
E9g`B
E9g`v]
E9Q }0I
E9T$Hu
E9V$v
E9Y |
E9Y |8E;Y |*A
E9Z u
Each cubemap face must have equal width and height.
EdgeAngle
edgeangle.dll
EdgeAngle.dll
edgeangle.pdb
edgeIso.dll
EEGGNNGGGKKP
effffff
efhijklop
egl::`anonymous-namespace'::AllocateCurrentThread
egl::Display::initialize
egl::SurfaceDeleter::operator ()
EGL_ANGLE_create_context_client_arrays
EGL_ANGLE_create_context_webgl_compatibility
EGL_ANGLE_d3d_share_handle_client_buffer
EGL_ANGLE_d3d_texture_client_buffer
EGL_ANGLE_device_d3d
EGL_ANGLE_direct_composition
EGL_ANGLE_display_texture_share_group
EGL_ANGLE_experimental_present_path extension not active
EGL_ANGLE_flexible_surface_compatibility
EGL_ANGLE_keyed_mutex
EGL_ANGLE_platform_angle extension not active
EGL_ANGLE_program_cache_control
EGL_ANGLE_query_surface_pointer
EGL_ANGLE_stream_producer_d3d_texture
EGL_ANGLE_surface_d3d_texture_2d_share_handle
EGL_ANGLE_surface_orientation
EGL_ANGLE_surface_orientation is not enabled.
EGL_ANGLE_window_fixed_size
EGL_CHROMIUM_create_context_bind_generates_resource
EGL_CHROMIUM_sync_control
EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR is not
EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE must be EGL_TRUE or EGL_FALSE.
EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_EXT_create_context_robustness
EGL_EXT_device_query
EGL_EXT_pixel_format_float
EGL_EXT_pixel_format_float is not enabled.
EGL_EXT_swap_buffers_with_damage
EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE cannot be used without EGL_ANGLE_flexible_surface_compatibility support.
EGL_KHR_create_context
EGL_KHR_get_all_proc_addresses
EGL_KHR_gl_renderbuffer_image
EGL_KHR_gl_texture_2D_image
EGL_KHR_gl_texture_3D_image
EGL_KHR_gl_texture_cubemap_image
EGL_KHR_image
EGL_KHR_image_base
EGL_KHR_image_pixmap
EGL_KHR_stream
EGL_KHR_stream_consumer_gltexture
EGL_KHR_surfaceless_context
EGL_NV_post_sub_buffer
EGL_NV_stream_consumer_gltexture_yuv
EGL_PLATFORM_ANGLE_DEBUG_LAYERS_ENABLED_ANGLE must be EGL_TRUE, EGL_FALSE, or EGL_DONT_CARE.
EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE or EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE.
EGL_PLATFORM_ANGLE_DEVICE_TYPE_WARP_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_ENABLE_AUTOMATIC_TRIM_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE currently only supports Vulkan 1.0.
EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE must be either EGL_TRUE or EGL_FALSE.
EHH9V
EHI;EPt
EHI9V8
eikgof
EL$ H
Element value exceeds maximum element index.
else if (
EMAIL.EXE
Embedded struct definitions are not allowed
EmitVertex
empty array declaration needs to specify a size
enable
endif
EndPrimitive
EnterCriticalSection
Enum is not currently supported.
Enum requires GLES 3.1
EOF while in a comment
EoH9U
Ep9E4t
EPH9W
EpI9Eh
EPI9EXu'L
equal
error
Error allocating 
Error compiling dynamic compute executable:
Error compiling dynamic geometry executable:
Error compiling dynamic pixel executable:
Error compiling dynamic vertex executable:
Error during layout qualifier parsing.
Error finding D3DCompile entry point.
Error initializing state manager.
Error querying driver version from DXGI Adapter.
Error reading swap chain description, 
Error resizing buffer in Buffer11::EmulatedIndexedStorage::getBuffer
Error resizing index memory buffer in Buffer11::EmulatedIndexedStorage::getBuffer
Error resizing swap chain buffers, 
error X3531:
error X4014:
ERROR: 
Error: discarding
Error: popping
ES3 texture parameters are not available without GL_OES_EGL_image_external_essl3.
ETC lossy decode formats can't be copied to.
ETC lossy decode formats can't work with this type.
EventWriteEx
EwH9Q
Except for images with the r32f, r32i and r32ui format qualifiers, image variables must be qualified readonly and/or writeonly
Exception
EXI9V0
eXI9VH
exp2(
Expected a program name, but found a shader name.
Expected a shader name, but found a program name.
Expected invariant
Expected loop index
EXPLORER.EXE
expression
Expression too complex.
EXT_blend_func_extended
EXT_draw_buffers
EXT_frag_depth
EXT_geometry_shader
EXT_shader_framebuffer_fetch
EXT_shader_texture_lod
EXT_YUV_target
extension
Extension 
extension cannot have 'enable' behavior
extension cannot have 'require' behavior
extension directive must occur before any non-preprocessor tokens in ESSL3
extension directive should occur before any non-preprocessor tokens
extension is being used
extension is disabled
Extension is not enabled.
extension is not supported
Extension not supported.
External texture extension not enabled
extraneous layout qualifier: only has an effect on matrix types
F ;H4
F A9Ehu
F H+F
F L;G u-
f#J0f;
F$A9El
F(A8Epu%A
F(D9`<
F(HcH
F(I+F L
F)A8Equ
F*A8Eru
F,A8Et
F@H9FH
F@I+F8H
F`9G`t.L
F`H+FXH
F`H+FXL
F`H9FX
F+A8Es
F0@8hpt#
F0D8#ukD8c
F0D8x
F0D9n(~
F0tDI9
F8@8x
F8I+F(H
f94Cu
fA#D$
fA3L$
fA3T$
F-A8Eu
fA9,Qu
faceforward
Failed to allocate internal buffer.
-Failed to allocate mappable internal buffer.
Failed to allocate the streaming vertex buffer.
Failed to create a 32-bit looping index buffer for GL_LINE_LOOP, too many indices required.
Failed to create a scratch index buffer for GL_TRIANGLE_FAN, too many indices required.
Failed to create D3D compute shader.
Failed to create D3D shaders.
Failed to create event query, 
Failed to get event query data, 
Failed to get frame statistics, 
Failed to get query data, 
Failed to get the data of an internal query, 
Failed to load binary from cache: 
Failed to map D3D11 resource.
Failed to open share handle, 
Failed to query ID3D11Texture2D object from share handle.
Failed to resize EmulatedIndexedStorage
Failed to resize internal buffer storage.
Failed to resize SystemMemoryStorage
Failed to retrieve the internal draw render target from the draw framebuffer.
Failed to retrieve the internal read render target from the read framebuffer.
Failed to store binary program in memory cache, program is too large.
Failed to test get query result, device is lost.
FailFast
FAKEVIRTUALSURFACETESTAPP.EXE
false
false case
fatal error - scanner input buffer overflow
fatal flex scanner internal error--end of buffer missed
fatal flex scanner internal error--no action found
fB#D/
fB#D2
fB3\2
fC#D,
fC#D.
fC#D+
fC#D<
fC3L<
fC3T.
FD@8~@u
fD3L7
fD90t,
fD97t
Fd9Gd
fE3\$
fE39fA
fE3D$
fE3T$
Feedback loop formed between Framebuffer and active Texture.
Fetch
fF3\/
fffffff
fG3D<
fG3L,
fG3L+
Fh8Eh
Fh8Ehu
FHH!F@H!FHH
FhH9C
FhH9G 
Fi8Ei
Fi8Eit
FileDescription
FileVersion
findLSB
findMSB
firstbithigh(
firstbitlow(
first-class array
first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
FirstLogonAnim.exe
FirstPixelOffset
FirstSlice
Fl9Gl
flat in
flat out
FLATTEN 
float
float 
float acosh_emu(in float x)
float asinh_emu(in float x)
float atan_emu(float y, float x)
float atanh_emu(in float x)
float faceforward_emu(float N, float I, float Nref)
float frexp_emu(float x, out int exp)
float ldexp_emu(float x, int exp)
float mix_emu(float x, float y, bool a)
float mod_emu(float x, float y)
Float overflow
float overflow
float roundEven_emu(in float x)
float webgl_fromSnorm16(in uint x) {
float webgl_fromSnorm8(in uint x) {
float webgl_fromUnorm16(in uint x) {
float webgl_fromUnorm8(in uint x) {
float2
float2 acosh_emu(in float2 x)
float2 asinh_emu(in float2 x)
float2 atan_emu(float2 y, float2 x)
float2 atanh_emu(in float2 x)
float2 faceforward_emu(float2 N, float2 I, float2 Nref)
float2 frexp_emu(float2 x, out int2 exp)
float2 ldexp_emu(float2 x, int2 exp)
float2 mix_emu(float2 x, float2 y, bool2 a)
float2 mod_emu(float2 x, float y)
float2 mod_emu(float2 x, float2 y)
float2 roundEven_emu(in float2 x)
float2 unpackHalf2x16_emu(in uint u)
float2 unpackSnorm2x16_emu(in uint u)
float2 unpackUnorm2x16_emu(in uint u)
float2x2
float2x2 inverse_emu(in float2x2 m)
float2x2 outerProduct_emu(in float2 c, in float2 r)
float2x3
float2x3 outerProduct_emu(in float3 c, in float2 r)
float2x4
float2x4 outerProduct_emu(in float4 c, in float2 r)
float3
float3 acosh_emu(in float3 x)
float3 asinh_emu(in float3 x)
float3 atan_emu(float3 y, float3 x)
float3 atanh_emu(in float3 x)
float3 faceforward_emu(float3 N, float3 I, float3 Nref)
float3 frexp_emu(float3 x, out int3 exp)
float3 ldexp_emu(float3 x, int3 exp)
float3 mix_emu(float3 x, float3 y, bool3 a)
float3 mod_emu(float3 x, float y)
float3 mod_emu(float3 x, float3 y)
float3 roundEven_emu(in float3 x)
float3x2
float3x2 outerProduct_emu(in float2 c, in float3 r)
float3x3
float3x3 inverse_emu(in float3x3 m)
float3x3 outerProduct_emu(in float3 c, in float3 r)
float3x4
float3x4 outerProduct_emu(in float4 c, in float3 r)
float4
float4 acosh_emu(in float4 x)
float4 asinh_emu(in float4 x)
float4 atan_emu(float4 y, float4 x)
float4 atanh_emu(in float4 x)
float4 faceforward_emu(float4 N, float4 I, float4 Nref)
float4 frexp_emu(float4 x, out int4 exp)
float4 ldexp_emu(float4 x, int4 exp)
float4 mix_emu(float4 x, float4 y, bool4 a)
float4 mod_emu(float4 x, float y)
float4 mod_emu(float4 x, float4 y)
float4 roundEven_emu(in float4 x)
float4 unpackSnorm4x8_emu(in uint u)
float4 unpackUnorm4x8_emu(in uint u)
float4(0, 0, 0, 1)
float4x2
float4x2 outerProduct_emu(in float2 c, in float4 r)
float4x3
float4x3 outerProduct_emu(in float3 c, in float4 r)
float4x4
float4x4 inverse_emu(in float4x4 m)
float4x4 outerProduct_emu(in float4 c, in float4 r)
floatBitsToInt
floatBitsToUint
Floating-point suffix unsupported prior to GLSL ES 3.00
floor
floor(
floorf
Format cannot be GL_DEPTH_COMPONENT or GL_DEPTH_STENCIL if target is GL_TEXTURE_3D
Format must match the internal format of the texture.
FormatMessageW
FPH+FHH
FPH9FHt
FpH9Fxu!L
FpI9FhI
frac(
fract
FragColor
FragCoord
FragData
FragDepth
FRAGMENT
Fragment shader active uniforms exceed MAX_FRAGMENT_UNIFORM_VECTORS (
Fragment shader atomic counter count exceeds MAX_FRAGMENT_ATOMIC_COUNTERS (
Fragment shader image count exceeds MAX_FRAGMENT_IMAGE_UNIFORMS (
Fragment shader output type does not match the bound framebuffer attachment type.
Fragment shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS (
Fragment shader shader storage block count exceeds GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS (
Fragment shader uniform block count exceeds GL_MAX_FRAGMENT_UNIFORM_BLOCKS (
Fragment shader version does not match vertex shader version.
Fragment varying 
FreeLibrary
frexp
FrontFacing
function
function already has a body
Function call discards the 'coherent' qualifier from image
Function call discards the 'readonly' qualifier from image
Function call discards the 'volatile' qualifier from image
Function call discards the 'writeonly' qualifier from image
function cannot take any parameter(s)
Function Definition:
function does not return a value:
Function has too many parameters.
function must have the same parameter qualifiers in all of its declarations
function must have the same return type in all of its declarations
function name expected
function parameter array must be sized at compile time
function parameter array must specify a size
Function parameter type cannot be a structure definition
Function Prototype
function return is not matching type:
fwidth
fwidth(
FXH+F`H
FxH9D$x
FxH9Fpt
G 9C 
G H9G(
G M;D$
G$9C$
G(8C(
G)8C)
G0D8@
G0D8@a
G0D8@lu
G0D8@m
G0D9$
G0H9C
G0tGI9
G8<1u
GEOMETRY SHADER END
Geometry shader input variable must be declared as an array
GeometryShader
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetLastError
GetModuleFileNameA
GetModuleFileNameW
GetModuleHandleExW
GetModuleHandleW
GetProcAddress
GetProcessHeap
GetSystemTimeAsFileTime
gfffffff
gfffffff3
gfffffffH
gfffffffH+
gfffffffI
gfffffffI+NhI
gfffffffJ
gfffffffL
gfffffffL+
Gh@t6H
GHH+G@H
gl::Compiler::~Compiler
gl::MemoryProgramCache::getProgram
gl::MemoryProgramCache::putProgram
gl::MemoryProgramCache::Serialize
gl::RefCountObjectNoID::release
gl::Shader::resolveCompile
gl::ValidateBlendFuncSeparate
gl::ValidateDrawBase
gl::ValidateEnable
gl::VertexAttribDivisorANGLE
GL;L$`
GL_ANGLE_client_arrays
GL_ANGLE_depth_texture
GL_ANGLE_framebuffer_blit
GL_ANGLE_framebuffer_multisample
GL_ANGLE_instanced_arrays
GL_ANGLE_lossy_etc_decode
GL_ANGLE_multiview
GL_ANGLE_MULTIVIEW_ENABLED
GL_ANGLE_pack_reverse_row_order
GL_ANGLE_program_cache_control
GL_ANGLE_request_extension
GL_ANGLE_request_extension is not available.
GL_ANGLE_robust_client_memory
GL_ANGLE_robust_client_memory is not available.
GL_ANGLE_robust_resource_initialization
GL_ANGLE_texture_compression_dxt3
GL_ANGLE_texture_compression_dxt5
GL_ANGLE_texture_rectangle
GL_ANGLE_texture_usage
GL_ANGLE_translated_shader_source
GL_ANGLE_webgl_compatibility
GL_ARB_texture_rectangle
GL_ARM_shader_framebuffer_fetch
GL_BUFFER_MAP_POINTER can only be queried with GetBufferPointerv.
GL_CHROMIUM_bind_generates_resource
GL_CHROMIUM_bind_uniform_location
GL_CHROMIUM_color_buffer_float_rgb
GL_CHROMIUM_color_buffer_float_rgba
GL_CHROMIUM_copy_compressed_texture
GL_CHROMIUM_copy_texture
GL_CHROMIUM_copy_texture extension not available.
GL_CHROMIUM_framebuffer_mixed_samples
GL_CHROMIUM_path_rendering
GL_CHROMIUM_sync_query
gl_Color
gl_Color[
gl_Color[0]
gl_Depth
gl_DepthRange
gl_DepthRangeParameters
GL_ES
GL_EXT_blend_func_extended
GL_EXT_blend_minmax
GL_EXT_color_buffer_float
GL_EXT_color_buffer_half_float
GL_EXT_debug_marker
GL_EXT_discard_framebuffer
GL_EXT_disjoint_timer_query
GL_EXT_draw_buffers
GL_EXT_frag_depth
GL_EXT_geometry_shader
GL_EXT_map_buffer_range
GL_EXT_multisample_compatibility
GL_EXT_occlusion_query_boolean
GL_EXT_read_format_bgra
GL_EXT_robustness
GL_EXT_shader_framebuffer_fetch
GL_EXT_shader_texture_lod
GL_EXT_sRGB
GL_EXT_sRGB_write_control
GL_EXT_texture_anisotropic is not enabled.
GL_EXT_texture_compression_dxt1
GL_EXT_texture_compression_s3tc_srgb
GL_EXT_texture_filter_anisotropic
GL_EXT_texture_format_BGRA8888
GL_EXT_texture_norm16
GL_EXT_texture_rg
GL_EXT_texture_sRGB_decode
GL_EXT_texture_sRGB_decode is not enabled.
GL_EXT_texture_storage
GL_EXT_unpack_subimage
GL_EXT_YUV_target
GL_FIXED is not supported in WebGL.
gl_FragColor
gl_FragCoord
gl_FragCoord can only be declared invariant if and only if gl_Position is declared invariant.
gl_FragData
gl_FragDepth
gl_FragDepthEXT
GL_FRAGMENT_PRECISION_HIGH
gl_FrontFacing
gl_GlobalInvocationID
gl_image
gl_in
gl_InstanceID
gl_InvocationID
GL_KHR_debug
GL_KHR_robust_buffer_access_behavior
GL_KHR_texture_compression_astc_hdr
GL_KHR_texture_compression_astc_ldr
gl_LastFragColor
gl_LastFragColorARM
gl_LastFragData
gl_Layer
gl_LocalInvocationID
gl_LocalInvocationIndex
gl_main(
gl_MaxAtomicCounterBindings
gl_MaxAtomicCounterBufferSize
gl_MaxCombinedAtomicCounterBuffers
gl_MaxCombinedAtomicCounters
gl_MaxCombinedImageUniforms
gl_MaxCombinedShaderOutputResources
gl_MaxCombinedTextureImageUnits
gl_MaxComputeAtomicCounterBuffers
gl_MaxComputeAtomicCounters
gl_MaxComputeImageUniforms
gl_MaxComputeTextureImageUnits
gl_MaxComputeUniformComponents
gl_MaxComputeWorkGroupCount
gl_MaxComputeWorkGroupSize
gl_MaxDrawBuffers
gl_MaxDualSourceDrawBuffersEXT
gl_MaxFragmentAtomicCounterBuffers
gl_MaxFragmentAtomicCounters
gl_MaxFragmentImageUniforms
gl_MaxFragmentInputVectors
gl_MaxFragmentUniformVectors
gl_MaxGeometryAtomicCounterBuffers
gl_MaxGeometryAtomicCounters
gl_MaxGeometryImageUniforms
gl_MaxGeometryInputComponents
gl_MaxGeometryOutputComponents
gl_MaxGeometryOutputVertices
gl_MaxGeometryTextureImageUnits
gl_MaxGeometryTotalOutputComponents
gl_MaxGeometryUniformComponents
gl_MaxImageUnits
gl_MaxProgramTexelOffset
gl_MaxTextureImageUnits
gl_MaxVaryingVectors
gl_MaxVertexAtomicCounterBuffers
gl_MaxVertexAtomicCounters
gl_MaxVertexAttribs
gl_MaxVertexImageUniforms
gl_MaxVertexOutputVectors
gl_MaxVertexTextureImageUnits
gl_MaxVertexUniformVectors
gl_MinProgramTexelOffset
gl_NumWorkGroups
GL_NV_EGL_stream_consumer_external
GL_NV_fence
GL_NV_pack_subimage
GL_NV_pixel_buffer_object
GL_NV_shader_framebuffer_fetch
GL_OES_compressed_ETC1_RGB8_texture
GL_OES_depth32
GL_OES_EGL_image
GL_OES_EGL_image_external
GL_OES_EGL_image_external_essl3
GL_OES_element_index_uint
GL_OES_fbo_render_mipmap
GL_OES_geometry_shader
GL_OES_get_program_binary
GL_OES_mapbuffer
GL_OES_packed_depth_stencil
GL_OES_rgb8_rgba8
GL_OES_standard_derivatives
GL_OES_surfaceless_context
GL_OES_texture_float
GL_OES_texture_float_linear
GL_OES_texture_half_float
GL_OES_texture_half_float_linear
GL_OES_texture_npot
GL_OES_vertex_array_object
GL_OVR_multiview
gl_PerVertex
gl_PointCoord
gl_PointCoord can only be declared invariant if and only if gl_PointSize is declared invariant.
gl_PointSize
gl_Position
gl_PrimitiveID
gl_PrimitiveIDIn
gl_SecondaryFragColorEXT
gl_SecondaryFragDataEXT
gl_texture
GL_USES_DEPTH_RANGE
GL_USES_FRAG_COLOR
GL_USES_FRAG_COORD
GL_USES_FRAG_DATA
GL_USES_FRAG_DEPTH
GL_USES_FRONT_FACING
GL_USES_GLOBAL_INVOCATION_ID
GL_USES_LOCAL_INVOCATION_ID
GL_USES_LOCAL_INVOCATION_INDEX
GL_USES_MRT
GL_USES_POINT_COORD
GL_USES_POINT_SIZE
GL_USES_VIEW_ID
GL_USES_WORK_GROUP_ID
GL_VERTEX_ATTRIB_ARRAY_DIVISOR requires OpenGL ES 3.0 or GL_ANGLE_instanced_arrays.
GL_VERTEX_ATTRIB_ARRAY_INTEGER requires OpenGL ES 3.0.
gl_VertexID
gl_ViewID_OVR
gl_ViewportIndex
gl_WorkGroupID
gl_WorkGroupSize
Global
global variable initializers must be constant expressions
global variable initializers should be constant expressions (uniforms and globals are allowed in global initializers for legacy compatibility)
GlobalInvocationID
Google Inc.
GPH+GHH
GpH9D$0
GPH9GH
GPH9GHt
GPH9GHt2H
GPI9GH
GPI9GHt
gpu.angle
GPU.ANGLE.Buffer11CPUMemoryMB
GPU.ANGLE.D3DCompileMS
GPU.ANGLE.DisplayInitializeMS
GPU.ANGLE.ProgramCache.CacheResult
GPU.ANGLE.ProgramCache.LoadBinarySuccess
GPU.ANGLE.ProgramCache.ProgramBinarySizeBytes
GPU.ANGLE.ProgramCache.ProgramCacheHitTimeUS
GPU.ANGLE.ProgramCache.ProgramCacheMissTimeUS
GPU.ANGLE.Renderer11InitializeDeviceMS
GPU.ANGLE.SupportsDXGI1_2
grad(
greaterThan
greaterThanEqual
groupMemoryBarrier
H 9Mos#H
H SVWH
H UATAUAVAWH
h UAVAWH
H UVWATAUAVAWH
H WATAUAVAWH
H WAVAWH
H!|$0H
H!t$P
H!t$PM
H#CHH
H#CHL
H#EHH
H#F0H
H#F0L
H#FHL
H#G0H
H#n0H
H#OHH
H#oHH
H#SHH
H#T$0
H#u0H
H#w0H
H(HcA
H(I9H
H;\$(t
H;\$`r
H;\$8
H;\$H
H;\$x
H;\$xu!I;
H;]pt
H;{ s
H;|$`
H;|$`t
H;1t!H
H;1t'H
H;A t
H;C(u
H;D$(t
H;D$(t8I
H;D$8r
H;D$Xt
H;H rVH
H;H s
H;H s?L
H;KHv
H;Kpt4H
H;L$`
H;L$8r
H;l$hu%I;
H;l$p
H;l$pu3H;
H;l$pu5H;
H;M@w
H;O(L
H;P s
H;Q r
H;Q s
H;s L
H;t$(t
H;t$(t.H
H;t$@
H;t$8
H;T$8r
H;t$xH
H;t$xL
H;V0L
H;x }7I
H;X r
H;x s7I
H;Y s
H;y@H
H;y0I
H@H)O
H@I;H
h_^][
H+|$xH
H+A H
H+A8H
H+D$8H;L$8H
H+F H
H+F8H
H+FXH
H+GhH
H+GHH
H+GhH
H+GHH
H+L$(H
H+M H
H+S0H
H+T$0
H+z L
h0H;n
H0I9H
H9\$`v!H
H9\$`v9H
H9\$H
H9\$Xt
H9{Hs<
H9{ht
H97s/3
H9A t
H9A uP
H9A(u
H9A@t
H9A0u
H9A8t
H9A8t&H
H9AHt
H9AHu
H9Ahu2D
H9AhuvH
H9C }
H9C s
H9C(u
H9C0u
H9D$ 
H9D$@u
H9D$8v)H
H9D$PH
H9D$Xu
H9Ehs
H9EHt
H9EHwZ
H9F`wAL
H9Fhs
H9G tsH
H9GHt,
H9GhvNH
H9H }
H9H r
H9H s
H9H sCE
H9H u
H9K@H
H9L$8vEH
H9P r
H9p rCH
H9p s
H9Q u
H9Q(u
H9Q0u
H9Q8u
H9S s
H9T$8v,L
H9T$8v.L
H9T$8v1L
H9T$8v7L
H9T$8vBM
H9T$8v'L
H9T$8vPM
H9t$P
H9T$PwSH
H9U(tHH
H9V(tHH
H9V(tKH
H9V(udH
H9W(tEH
H9W(tKH
H9w0u6H
H9X s
H9x(t5
H9ZHtAH
hA^A\_^[]
hA_A^A]A\_^[]
HA_A^A]A\_^[]
hA_A^A]A\_^[]
hA_A^A]A\_^][
HA_A^A]A\_^][
HasIndexRange
Hc@ H
Hc]hH
HcC4H
HcC8I
HcD$PI
HcK4H
HcL$`H
HcL$0HcD$4H
HcL$8
HcL$PH
HcQ ;Q
HcQDB8
HcS4H
HcS8L
HcT$pMc
HcU`H
HcuWM
HeapAlloc
HeapFree
height
HfD9u
highp
highp 
hint requires OES_standard_derivatives.
HLSL compiler had an unexpected failure, 
HLSLCompiler::initialize
HRESULT: 
I#{HH
I#CHM
I#E0H
I#F0H
I#FHM
I#s0L
I(HcA
I;?tq8W
I;@@t]H
I;@`H
I;<$tKH
I;A(u
I;A0u
I;H t
I;L$H
I;q }&I
I@I;I
I+,$I
I+FHH
I+HxI
I+JpH
I+N H
I+N0H
I08AFu
I0I#AHH
I9^ t.I
I9~ t=H
I9A(u
I9A0u
I9D$`I
I9FHI
I9r }EH
I9T$(tHH
I9V(u
I9W(tHH
I9x s
iblock-
IcA,H
IcK I;
IcK@I;
IcK<I;
IcKhI#
IcKLI;
IcKlI;
IcKpI;
IcKPI;
IcKtI;
IcKxI#
identifiers containing two consecutive underscores (__) are reserved as possible future keywords
iertutil.dll
IEUTLAUNCH.EXE
IEXPLORE.EXE
if (!Break
If ctx is EGL_NO_CONTEXT, surfaces must be EGL_NO_SURFACE
If ctx is not EGL_NO_CONTEXT, surfaces must not be EGL_NO_SURFACE
If ctx is not EGL_NOT_CONTEXT, draw or read must both be EGL_NO_SURFACE, or both not
If test
ifdef
ifndef
IH9GHt
IhD8L$(
iim21;
iim2a
iim2a1;
iim31;
iimage2D
iimage2DArray
iimage3D
iimageCube
iimc1;
illegal - vector component fields not from the same set
Illegal character at fieldname start
illegal type argument for default precision qualifier
illegal type for precision qualifier
Illegal use of reserved word
illegal use of type 'void'
illegal vector field selection
im21;
im2a1;
im31;
image
image binding greater than gl_MaxImageUnits
image2D
image2DArray
image3D
imageCube
imageLoad
'imageLoad' cannot be used with images qualified as 'writeonly'
imageSize
imageSize must be 0 if no texture data is provided.
imageSize must be at least 
imageStore
'imageStore' cannot be used with images qualified as 'readonly'
imc1;
implicitly sized array constructor must have at least one argument
implicitly sized array of arrays constructor argument dimensionality is too low
implicitly sized array of arrays constructor argument is not an array
implicitly sized array supported in GLSL ES 3.00 and above only
implicitly sized arrays need to be initialized
imulExtended
'in' can be only used to specify the local group size
in type qualifier supported in GLSL ES 3.10 only
index
Index buffer is mapped.
Index exceeds MAX_DRAW_BUFFERS.
Index exceeds MAX_VERTEX_ATTRIBS.
Index exceeds program active uniform count.
index expression is negative
Index expression must be constant
index must be smaller than MAX_VERTEX_ATTRIB_BINDINGS.
indirect index
Infinity divided by infinity during constant folding generated NaN
init-expression in a switch statement must be a scalar integer
initGlobals
initialize first child with second child
InitializeConditionVariable
InitializeCriticalSectionAndSpinCount
InitializeCriticalSectionEx
InitializeSListHead
InitOnceExecuteOnce
inout
Input buffer overflow
input layout
input.
input.v
InputLayout
Inputted D3D11 device has been lost.
InstanceID
Insufficient buffer size.
int bitfieldExtract_emu(int value, int offset, int bits)
int bitfieldInsert_emu(int base, int insert, int offset, int bits)
int webgl_toSnorm16(in float x) {
int webgl_toSnorm8(in float x) {
int wrapR = (samplerMetadata[samplerIndex].wrapModes >> 4) & 0x3;
int wrapS = samplerMetadata[samplerIndex].wrapModes & 0x3;
int wrapT = (samplerMetadata[samplerIndex].wrapModes >> 2) & 0x3;
int(floor(height * frac(
int(floor(width * frac(
int(max(0, min(layers - 1, floor(0.5 + t.z))))
int2 bitfieldExtract_emu(int2 value, int offset, int bits)
int2 bitfieldInsert_emu(int2 base, int2 insert, int offset, int bits)
int3 bitfieldExtract_emu(int3 value, int offset, int bits)
int3 bitfieldInsert_emu(int3 base, int3 insert, int offset, int bits)
int4 bitfieldExtract_emu(int4 value, int offset, int bits)
int4 bitfieldInsert_emu(int4 base, int4 insert, int offset, int bits)
intBitsToFloat
integer expression required
integer modulus operator supported in GLSL ES 3.00 and above only
integer overflow
Integer overflow
Integer overflow in VertexDataManager::StoreStaticAttrib
Integer overflow on line number
Integer overflow.
interface block
interface block '
interface block has no fields
interface blocks supported in GLSL ES 3.00 and above only
Internal blit shader type mismatch
Internal Error
internal error
Internal error, new vertex buffer write position would overflow.
internal image format requires a floating image type
internal image format requires an integer image type
internal image format requires an unsigned image type
Internal index buffer is not initialized.
Internal rendertarget error: 
internal tokenizer error
Internal vertex buffer is not initialized.
internal\sdk\inc\wil\resource.h
internal\sdk\inc\wil\staging.h
internalformat is not a supported compressed internal format.
InternalName
Interpolation types for 
Invalid Attachment Type.
Invalid attrib_list parameter
Invalid automatic trim attribute
Invalid blend equation.
Invalid blend function.
Invalid buffer target enum.
Invalid buffer usage enum.
Invalid buffer value
invalid character
Invalid combination of format, type and internalFormat.
Invalid combination of type and internalFormat.
Invalid compressed format dimension.
Invalid condition
Invalid Context attribute.
Invalid D3D device passed into EGLDeviceEXT
Invalid device parameter
Invalid device_type parameter
invalid directive name
Invalid draw mode.
Invalid enum.
invalid expression
Invalid expression
invalid extension behavior
invalid extension directive
invalid extension name
invalid file number
Invalid format and type combination.
Invalid format.
Invalid framebuffer operation.
Invalid framebuffer target.
Invalid init declaration
Invalid internal format.
invalid layout qualifier
invalid layout qualifier combination
invalid layout qualifier: cannot be used here
invalid layout qualifier: location requires an argument
invalid layout qualifier: not supported
invalid layout qualifier: only valid on program inputs and outputs
invalid layout qualifier: only valid on program outputs
invalid layout qualifier: only valid on shader inputs, outputs, and uniforms
invalid layout qualifier: only valid when used with atomic counters
invalid layout qualifier: only valid when used with images
invalid layout qualifier: only valid when used with 'in' in a compute shader global layout declaration
invalid layout qualifier: only valid when used with opaque types or blocks
invalid line directive
invalid line number
Invalid mask bits.
invalid method
Invalid name.
invalid number
Invalid operation for arrays
Invalid operation for interface blocks
Invalid operation for structs
Invalid operation for variables with an opaque type
Invalid operation for variables with writeonly
Invalid operation.
Invalid operator
Invalid or unsupported precision type.
Invalid or unsupported texture target.
Invalid parameter for 2D multisampled textures.
Invalid parameter name for framebuffer attachment.
invalid parameter qualifier
Invalid parameter qualifier 
invalid pragma value - 'on' or 'off' expected
invalid primitive type for 'in' layout
invalid primitive type for 'out' layout
Invalid program binary version.
Invalid program binary, device configuration has changed.
Invalid program binary.
invalid qualifier combination
invalid qualifier on interface block member
invalid qualifier on shader storage block member
invalid qualifier on struct member
invalid qualifier on uniform block member
invalid qualifier: can be only used with function parameters
invalid qualifier: global layout can only be set for blocks
invalid qualifier: interface blocks must be uniform in version lower than GLSL ES 3.10
invalid qualifier: interface blocks must be uniform or buffer
Invalid relational operator
Invalid renderbuffer internalformat.
Invalid renderbuffer target.
Invalid shader type.
Invalid stencil.
Invalid texture dimensions.
Invalid texture parameters in share handle texture.
Invalid texture target and format combination.
Invalid type for loop index
Invalid type.
Invalid uniform location
Invalid value for EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE attrib
Invalid value.
invalid value: Value must be at least 1 and no greater than 
invalid version directive
invalid version number
Invalid width.
Invalid wrap mode for texture type.
Invariance for 
invariant
invariant 
invariant declaration specifies layout
invariant declaration specifies precision
invariant declaration specifies qualifier
Invariant Declaration:
invariant varying
inverse
inversesqrt
invocations
invocations can only be declared in 'in' layout in a geometry shader
invocations contradicts to the earlier declaration
is21;
is2a1;
is2ms
is2ms1;
is31;
isampler2D
isampler2DArray
isampler2DMS
isampler3D
isamplerCube
isC1;
IsDebuggerPresent
ISGN,
ISGNh
ISGNl
ISGNL
ISGNP
ISGNt
ISGNT
isinf
isinf(
isnan
isnan(
IsProcessorFeaturePresent
It is a undefined behaviour to render without vertex shader stage or fragment shader stage.
It is an error to use gl_WorkGroupSize before declaring the local group size
It is invalid to change default FBO's attachments
It is undefined behaviour to clear a render buffer which is not normalized fixed point or floating-point to floating point values (color attachment 
It is undefined behaviour to have a used but unbound uniform buffer.
It is undefined behaviour to use a uniform buffer that is too small.
Ith value does not match COLOR_ATTACHMENTi or NONE
itu_601
itu_601_full_range
itu_709
ivec2
ivec3
ivec4
J;D$(u
J0I#BHH
JQVWGEY
jshost.exe
K E9~
K H+K
K s~I
K s=H
K s'H
K sPH
K sSH
K sUH
K sVH
K SVWH
k VWAVH
K@H9Q
K`LcP
k0I;n
K0tCH
kernel32.dll
kernelbase.dll
KKKKKKKKLLRMST
KKKNUUVV
KLNMPQRSTOJ
KpH9Kh
KxH+KpL
KxH9KptDE8
L!|$pI+
L!E/H
L!E?H
L!E7H
L!EGH
L!MHH
L!t$ L
L#e0I
L#G0M
L#K0H
L#S0I
L#SHI
L#u0I
L#v0H
l$ D;
L$ D8l$!
l$ E3
L$ E3
l$ E3
L$ E3
l$ H;
l$ H+
L$ L;
L$ L+
l$ L+
L$ SUVWH
L$ UVWATAUAVAWH
L$ VWATAUAWH
L$ VWATAVAWH
l$ VWATAVAWH
l$ VWAUAVAWH
l$ VWAVH
L$ VWAVH
l$ VWAVH
L$ VWAVH
l$ VWAVH
L$ VWAVH
l$ VWAVH
l$ VWAWH
L$ WH
L$$A+
L$(9H
L$(E3
l$(E3
l$(H+
L$(H3
l$(I;
L$@D:
L$@E3
L$@H;
l$@H+
L$@H3
L$@H9S
L$@I+
l$\E3
L$`D8@a
L$`E3
l$`E3
L$`E3
L$`H;
L$`H3
L$0@8s
l$09l$ t}H
L$0A;
L$0E;
L$0E3
l$0E3
L$0E3
l$0E3
L$0E3
l$0E3
L$0H;
L$0H3
L$0H9H
L$0I;
l$0I+
L$0I+
l$0Ic
L$8E3
l$8E3
L$8E3
L$8H;
l$8H+
L$8H3
L$8L+
L$8L9H s
l$H@8
L$HE;
L$HE3
L$HH;
L$hH3
L$HH3
L$hH3
L$HH3
L$hH3
L$HH3
L$hH3
L$HH3
L$hH3
L$HH3
L$hH3
L$HH3
L$hI;
l$HIi
l$HIk
L$PA9q
L$PA9q 
L$PA9q s#I
L$PA9q t
L$PA9y
L$PA9y } I
L$PA9y s I
L$PD:
l$PD;
L$PD9
l$PE;
L$pE3
L$PE3
l$PE3
L$PE3
L$PfD
L$pH3
L$PH3
L$pH3
L$PH3
L$pH3
L$PH3
L$pH3
L$PH3
L$pH3
L$PH3
L$pH3
L$PI;
L$pI;
L$PI;
L$PI9q }#I
L$PI9y 
L$PI9y s I
L$PL;
L$PL+
l$pM+
L$xA9i
L$XE3
l$XE3
L$xE9Y
L$xE9Y }+I
L$xE9Y }0I
l$xH+
L$xH3
L$XH3
L$xH3
L$XH3
L$xH3
L$XH3
L$xH3
L$xI;
l$XI;
L$xI;
L$xL;
L$xM;
L;@ }
L;@ rLH
L;@ rOH
L;@ rYH
L;@ s
L;@(u
L;A s
L;A s'H
L;A@u&H
L;D$`u
L;D$8r
L;F@u
L;H s[
L;H0u
L;I tYH
L;J t
L;K }#H
L;K t1H
L;K0u
L;L$hu
L;O s^
L;Q s
L;t$@r
L;t$8r
L]X;X v
L+{hI
L+9M+
L+FxH
L+t$PL
L9(tcH
L9(u?H
L9@ s
L9{@u
L9{0t#H
L9|$0
L9d$ t
L9d$`w
L9d$8I
L9D$8v(L
L9D$8v)L
L9D$8vCL
L9D$8vEL
L9H }
L9k s<H
L9P }
L9P s
L9q t
L9s(u 
L9sht*H
L9sHt8H
L9sXt
L9T$ 
L9t$@v>I
L9t$`
L9t$8vDI
L9y t
L9y t$L
label statement nested inside control flow
LastFragColor
LastFragData
LAYER
Layer
layout
'layout'
layout qualifier
layout qualifier only valid for interface blocks
Layout qualifiers differ for interface block '
layout qualifiers supported in GLSL ES 3.00 and above
Lc|$PL
LcD$\HcT$THcL$`A
LcD$4H
Lce`E3
LcE`I
LceHH
LcM_3
LcugD
LcugH
LcugM
LcuWL
ldexp
ldNOM]^egmf
LeaveCriticalSection
LegalCopyright
length
length can only be called on arrays
length(
lerp(
lessThan
lessThanEqual
Level of detail outside of range.
LGPU.ANGLE.D3D11FeatureLevel
line_strip
linear
lines
lines_adjacency
LOADER42.EXE
LoadLibraryW
local function prototype declarations are not allowed
Local variables can only use the const storage qualifier.
Local\SM0:%d:%d:%hs
local_size_x
local_size_y
local_size_z
LocalInvocationID
LocalInvocationIndex
location
Location layout qualifiers for 
Location lengths must not be greater than 1024 characters.
location must not be set for atomic_uint
location must only be specified for a single input or output variable
Location name lengths must not be greater than 256 characters.
Lod0(
log2(
LogHr
logical-and
logical-or
logical-xor
Loop Body
Loop Condition
Loop index cannot be compared with non-constant expression
Loop index cannot be initialized with non-constant expression
Loop index cannot be modified by non-constant expression
Loop index cannot be statically assigned to within the body of the loop
Loop Terminal Expression
Loop with condition 
lstrcmpiW
LubeH
LueeH
l-value required
l-value required (
LXXXXXX
M H1E
M sjI
M;H M
M;H@r
M;N(u
M;O0H
M;P M
M;P u
M;S t`H
M;X M
M;Z8u
M+n H
M+NxI
M+T$0H
M0H+C
M9~ t2I
M9B(u
M9H rbA8Z
M9H ryA8Z
M9H s
M9J0u
M9P s
M9X s
macro invocation chain too deep
macro name is reserved
macro name with a double underscore is reserved - unintented behavior is possible
macro redefined
macro undefined while being invoked
main function cannot return a value
Mapping of internal index buffer would cause an integer overflow.
mat2x3
mat2x4
mat3x2
mat3x4
mat4x2
mat4x3
matrix field selection out of range
matrix mult second child into first child
Matrix packings for 
matrix scale second child into first child
matrixCompMult
matrix-multiply
matrix-scale
matrix-times-vector
Max anisotropy must be at least 1.
max_vertices
max_vertices can only be declared in 'out' layout in a geometry shader
max_vertices contradicts to the earlier declaration
mE9,$
mediump
memchr
memcmp
memcpy
memmove
memory exhausted
memoryBarrier
memoryBarrierAtomicCounter
memoryBarrierBuffer
memoryBarrierImage
memoryBarrierShared
MemProtectHeapCreate
MemProtectHeapDestroy
MemProtectHeapUnrootAndZero
memset
method takes no parameters
methods supported in GLSL ES 3.00 and above only
mf2x2;
mf2x3;
mf2x4;
mf3x2;
mf3x3;
mf3x4;
mf4x2;
mf4x3;
mf4x4;
MhA9q
Microsoft
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
Microsoft Corporation
Microsoft Edge
Microsoft Edge Angle
Microsoft.Web.Platform
microsoftedge.exe
microsoftedgebchost.exe
microsoftedgecp.exe
microsoftedgedevtools.exe
microsoftedgesh.exe
MinLoadLib.exe
Mipmap level must be 0 when attaching a texture.
Mismatched compilation flags.
mismatching ternary operator operand types '
Missing a valid input primitive declaration before declaring an unsized array input
Missing condition
Missing expression
Missing init declaration
missing input primitive declaration before calling length on gl_in
missing input primitive declaration before indexing gl_in.
Missing main()
Missing read attachment.
modf(
modff
modulo
modulo second child into first child
move second child to first child
mp_unspecified
MPH9Q
MPLcu`A
MSFEEDSSYNC.EXE
Msg:[%ws] 
MSHTMPAD.EXE
MSOOBE.EXE
msvcp_win.dll
mul(transpose(
Multiple uniforms bound to location 
multiply second child into first child
multiviewBaseViewLayerIndex
must explicitly specify all locations when using multiple fragment outputs
Must have element array buffer binding.
Must specify major version if you specify a minor version.
must use 'flat' interpolation here
Mx@8>tT
N H+N
n must be 1 when GL is bound to the default framebuffer
N(I+N H
N`L9I 
N9<0t
Name conflicts between a uniform and an attribute: 
Name contains invalid characters.
Name mismatch for field 
Name mismatch for field '
Name of a built-in function cannot be redeclared as function
native_display should be a valid EGL device if platform equals EGL_PLATFORM_DEVICE_EXT
Near value cannot be greater than far.
Negate value
negation
Negative buffer size.
Negative count.
Negative modulus operator operand encountered during constant folding
Negative offset.
Neither NV_EGL_stream_consumer_external nor GL_OES_EGL_image_external extensions enabled
NETPLWIZ.EXE
New vertex buffer size would result in an overflow.
no binding specified
No defined conversion between clear value and attachment format.
No element array buffer and no pointer.
No image internal format specified
No local work group size specified
No loop body
No loop condition
no matching overloaded function found
No num_views specified
No precision specified
No precision specified for (float)
no qualifiers allowed for function return
no statement between the last label and the end of the switch statement
node is still EOpNull!
nointerpolation
non-void function must return a value
normalize
normalize(
not allowed to specify yuv qualifier when using depth or multiple color fragment outputs
Not enough arguments for macro
not enough data provided for construction
Not initialized.
not supported
notEqual
NpI+NhH
ntdll.dll
ntelD
NtQueryWnfStateData
NtUpdateWnfStateData
NULL share handle.
num_config cannot be null.
num_views
num_views greater than the value of GL_MAX_VIEWS_OVR
Number of constructor parameters does not match the number of structure fields
Number of views does not match the previous declaration
NumWorkGroups
NV_EGL_stream_consumer_external
NV_shader_framebuffer_fetch
NV12 tetxures must have even width and height.
O 9H 
O H+O
O I+O
O;T$(t
o\$PH
O`L9I 
O0D8A
O8H+UHL
Object cannot be used because it has not been generated.
oD$ f
OES_EGL_image_external
OES_EGL_image_external_essl3
OES_geometry_shader
OES_standard_derivatives
Offset
offset
Offset = 
Offset layout qualifiers for 
Offset must be a multiple of the passed in datatype.
Offset overlapping
Offset) * 0.5) * 2.0 - 1.0);
Offset)));
Offset)), 0, int(
offset.x
offset.y
offset.z
OIcKHI;
oL$0f
OleSelfRegister
only allowed at global scope
Only allowed with shader storage blocks, variables declared within shader storage blocks and variables declared as image types.
Only NONE or BACK are valid values when drawing to the default framebuffer
Only std140 layout is allowed in WebGL
Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.
opaque types cannot be output parameters
OpenGL ES 
OpenGL ES 3.0 Required.
OpenGL ES 3.1 Required
OpenGL ES GLSL ES 
OpenGL platform is unsupported.
OpenSemaphoreW
operation result is undefined for the values passed in
OPH9OH
OpI+OhH
optimize
OriginalFilename
OSGN,
OSGN`
OSGN|
OSGNd
OSGNL
OSGNl
OSGNL
OSGNP
oT$@f
out of dynamic memory in yy_create_buffer()
out of dynamic memory in yy_get_next_buffer()
out of dynamic memory in yyensure_buffer_stack()
out of memory
Out of memory.
out of range: 
out of range: binding must be non-negative
out of range: invocations must be in the range of [1, MAX_GEOMETRY_SHADER_INVOCATIONS_OES]
out of range: location must be non-negative
out of range: max_vertices must be in the range of [0, gl_MaxGeometryOutputVertices]
out of range: num_views must be positive
out of range: offset must be non-negative
out type qualifier supported in GLSL ES 3.10 only
outerProduct
output array locations would exceed MAX_DRAW_BUFFERS
Output layout location specified multiple times.
output location must be < MAX_DRAW_BUFFERS
OutputDebugStringW
Overflowed the 
OVR_multiview
p ATAVAWH
p AWH
p AWL
p D9w$tDH
p D9w(
p D9w0
P s\H
P s_H
P saH
P sDH
P sFI
P sqH
P sWH
P szH
p UWATAVAWH
p WATAUAVAWH
p WAVAWH
p WAVL
P@I;P
pA^_^
PA^_^
pA^_^[]
pA^_^][
PA_A^_^]
pA_A^_^]
PA_A^_^]
pA_A^_^]
PA_A^_^]
pA_A^_^]
PA_A^_^]
pA_A^_^]
PA_A^_^]
pA_A^A\_^[]
pA_A^A\_^][
PA_A^A]A\_^]
pA_A^A]A\_^]
PA_A^A]A\_^]
pA_A^A]A\_^]
PA_A^A]A\_^]
pA_A^A]A\_^]
PA_A^A]A\_^]
pA_A^A]A\_^]
PA_A^A]A\_^]
packed
packHalf2x16
packSnorm2x16
packSnorm4x8
packUnorm2x16
packUnorm4x8
Passed in texture target and format must match the one originally used to define the texture.
PathFindFileNameW
Performance: dynamic indexing of vectors and matrices is emulated and can be slow.
Performance: non-empty fall-through cases in switch statements generate extra code.
Phv$A
pickerhost.exe
Pixel data must be null.
Pixel pack buffer is mapped.
Pixel unpack buffer is mapped.
PixelShader
PixelsPerRow
Plane out of range
Platform ANGLE extension is not active
Platform Device extension is not active
pLc}@L
pname requires OpenGL ES 3.0 or GL_EXT_map_buffer_range.
pname requires OpenGL ES 3.0 or GL_OES_mapbuffer.
pname requires OpenGL ES 3.0, GL_OES_mapbuffer or GL_EXT_map_buffer_range.
pname requires OpenGL ES 3.0.
Point
point
Point rendering without writing to gl_PointSize.
PointCoord
points
PointSize
POSITION
Position
POSITION
PositionOffset
PositionScale
Positive sign
Post-Decrement
Post-Increment
PPPWWW
pragma
Precision emulation not supported for this output type.
precision is not supported in fragment shader
Precision qualifiers have to be after interpolation qualifiers.
Precision qualifiers have to be after layout qualifiers.
Precision qualifiers have to be after memory qualifiers.
Precision qualifiers have to be after storage qualifiers.
Precisions for 
Pre-Decrement
predefined macro redefined
predefined macro undefined
Pre-Increment
Present failed with 
Present failed: the D3D11 device was removed, 
Present failed: the D3D11 device was reset from a bad command.
Primcount must be greater than or equal to zero.
primitive doesn't match earlier input primitive declaration
primitive doesn't match earlier output primitive declaration
ProductName
ProductVersion
Program has not been successfully linked.
Program not linked.
Program object expected.
PS_OUTPUT generateOutput()
PS_OUTPUT main(PS_INPUT input)
PS_OUTPUT main(PS_INPUT input, bool isFrontFace : SV_IsFrontFace)
PS_OUTPUT main(PS_INPUT input, float vFace : VFACE)
PSIZE
Q H;Q
Q@H9QHt*
Q7Tbn5=
QLL;I@sqH
QLL;I@suH
qualifier sequence
qualifier supported in GLSL ES 3.00 and above only
Query
Querying GL_PROGRAM_BINARY_LENGTH requires GL_OES_get_program_binary or ES 3.0.
QueryPerformanceCounter
QueryPerformanceFrequency
r H;s
r L;s
r"H;\$Pw
r"H;^
r"H;w
r"L;~
r"L;f
r$L;t$Pw
r%H;\$Pw
r%H;{
r%L;t$Pw
r(L;n
r};A(wxH
r32ui
radians
radians(
RaiseException
RaiseFailFastException
rasterizer state
RasterizerState
RDEF(
RDEF,
RDEF|
RDEFP
RDEFt
RDEFx
Reaching warning limit for cache load failures, silencing subsequent warnings.
read and draw must both be valid surfaces, or both be EGL_NO_SURFACE
Read buffer is GL_NONE.
readonly
Reads would overflow the pixel unpack buffer.
Rectangle texture cannot have a compressed format.
Recursive function call in the following call chain:
redeclaration of gl_LastFragData as an array of arrays
redeclaration of gl_LastFragData with size != gl_MaxDrawBuffers
redefinition
redefinition of a function
redefinition of a struct
redefinition of an interface block instance name
redefinition of an interface block member name
redefinition of an interface block name
Reference of struct type 
reflect
reflect(
refract
refract(
register(
ReleaseMutex
ReleaseSemaphore
ReleaseSRWLockExclusive
ReleaseSRWLockShared
Renderbuffer format does not support 
Renderbuffer width and height cannot be negative and cannot exceed maximum texture size.
Renderer11::initialize (ComQueries)
Renderer11::initialize (HideWarnings)
Renderer11::initializeDevice
RenderTargetView
Requested GLES version is not supported.
require
Requires both binding and offset
reserved built-in name
Reserving 
ResetEvent
ResolveDelayLoadedAPI
RESTOREOPTIN.EXE
restrict
return
return 
ReturnHr
reversebits(
rgb_2_yuv
rgba16f
rgba16i
rgba16ui
rgba32f
rgba32i
rgba32ui
rgba8
rgba8_snorm
rgba8i
rgba8ui
rJIc>I
rMfD97w
round
round(
roundEven
row_major
RowsPerSlice
RowStride
rPH+rHH
rsqrt(
RSTUVWXYZ[\]^_`ab
RSTUVWXYZ[\]^_`abcd
RSTUVWXYZ[\]^_`abcdefghijkl
RtlCaptureContext
RtlDllShutdownInProgress
RtlGetSuiteMask
RtlIsMultiSessionSku
RtlLookupFunctionEntry
RtlNtStatusToDosErrorNoTeb
RtlSubscribeWnfStateChangeNotification
RtlUnsubscribeWnfNotificationWaitForCompletion
RtlVirtualUnwind
RWCube_float4_
RWCube_int4_
RWCube_uint4_
RWCube_unorm_float4_
RWTexture2D<float4>
RWTexture2D<int4>
RWTexture2D<snorm float4>
RWTexture2D<uint4>
RWTexture2D<unorm float4>
RWTexture2DArray<float4>
RWTexture2DArray<int4>
RWTexture2DArray<snorm float4>
RWTexture2DArray<uint4>
RWTexture2DArray<unorm float4>
RWTexture3D<float4>
RWTexture3D<int4>
RWTexture3D<snorm float4>
RWTexture3D<uint4>
RWTexture3D<unorm float4>
rx::`anonymous-namespace'::DirectStoragePossible
rx::`anonymous-namespace'::UpdateCachedRenderTarget
rx::Clear11::clearFramebuffer
rx::Context11::onMakeCurrent
rx::Context11::triggerDrawCallProgramRecompilation
rx::FramebufferD3D::getColorAttachmentsForRender
rx::HLSLCompiler::compileToBinary
rx::HLSLCompiler::ensureInitialized
rx::IncompleteTextureSet::onDestroy
rx::ProgramD3D::compileComputeExecutable
rx::ProgramD3D::getGeometryExecutableForPrimitiveType
rx::ProgramD3D::getPixelExecutableForCachedOutputLayout
rx::ProgramD3D::getVertexExecutableForCachedInputLayout
rx::Renderer11::applyPrimitiveType
rx::Renderer11::populateRenderer11DeviceCaps
rx::Renderer11::testDeviceLost
rx::StreamingVertexBufferInterface::StreamingVertexBufferInterface
rx::StreamProducerD3DTexture::getGLFrameDescription
rx::SurfaceD3D::SurfaceD3D
rx::SwapChain11::present
rx::SwapChain11::reset
rx::SwapChain11::resetOffscreenColorBuffer
rx::SwapChain11::resetOffscreenDepthBuffer
rx::SwapChain11::resize
s can't be function return values
S H+S
s L+s
s must be uniform
s WAVAWH
S*P}y
s[UPIC>
s^L;c u
S0I#CHM
s0u6H
s2a1;
s2as1;
s2ms1;
s2r1;
s2s1;
s8u6H
Sampler
sampler binding greater than maximum texture units
sampler state
sampler uniform value out of range
sampler2D
sampler2D s
sampler2DArray
sampler2DArrayShadow
sampler2DMS
sampler2DRect
sampler2DShadow
sampler3D
SamplerComparisonState
samplerCUBE
samplerCube
samplerCUBE s
samplerCubeShadow
samplerExternalOES
samplers
SamplerState
Saving program binary with transform feedback, which is not supported on this driver.
sCs1;
SecondaryFragColorEXT
SecondaryFragDataEXT
sequence operator is not allowed for void, arrays, or structs containing arrays
SetEvent
SetLastError
SetThreadpoolTimer
SetUnhandledExceptionFilter
sext1;
sext2y2y
sext2y2y1;
Shader attachment already has a shader.
Shader object expected.
Shader source contains invalid characters.
shader storage block binding greater than MAX_SHADER_STORAGE_BUFFER_BINDINGS
Shader to be detached must be currently attached to the program.
ShaderResourceView
shared
Shared memory declarations cannot have layout specified
SHDR$
SHDR,
SHDR@
SHDR\
SHDR`
SHDR<
SHDR4
SHDR8
SHDRd
SHDRL
SHDRP
SHDRp
SHDRX
SHDRx
SHDRX
shift exponent is negative or undefined
sign(
Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR not supported by this implementation.
sinh(
sinhf
Sized GL_RGB32F internal format requires GL_CHROMIUM_color_buffer_float_rgb
Sized GL_RGBA32F internal format requires GL_CHROMIUM_color_buffer_float_rgba
skip optimization
skip validation
Sleep
SleepConditionVariableCS
smooth
smooth centroid in
smooth centroid out
smooth in
smooth out
smoothstep
smoothstep(
Software Adapter
soN9$
Source texture a valid texture type.
Source texture internal format is invalid.
Source texture is not a valid texture object.
Source texture level is not valid.
spL9sxt/I
SPRITEPOSITION
SPRITETEXCOORD
sqrt(
sqrtf
Stack overflow.
Stack underflow.
statement before the first label
static 
static bool gl_FrontFacing = false;
static const uint 
static const uint samplerIndexOffset
static const uint textureIndexOffset
static float gl_Depth = 0.0;
static float gl_PointSize = float(1);
static float maxPointSize = 
static float minPointSize = 
static float2 gl_PointCoord = float2(0.5, 0.5);
static float2 pointSpriteCorners[] = 
static float2 pointSpriteTexcoords[] = 
static float4 gl_Color[
static float4 gl_FragCoord = float4(0, 0, 0, 0);
static float4 gl_Position = float4(0, 0, 0, 0);
static gl_DepthRangeParameters gl_DepthRange = {dx_DepthRange.x, dx_DepthRange.y, dx_DepthRange.z};
static int gl_InstanceID;
static int gl_VertexID;
static uint gl_LocalInvocationIndex = uint(0);
static uint3 gl_GlobalInvocationID = uint3(0, 0, 0);
static uint3 gl_LocalInvocationID = uint3(0, 0, 0);
static uint3 gl_WorkGroupID = uint3(0, 0, 0);
STATt
std140
std430
STDGL
Stencil
Stencil reference and mask values must be the same for front facing and back facing triangles.
step(
storage qualifier isn't supported in compute shaders
storage qualifier supported in GLSL ES 3.00 and above only
storage qualifier supported in GLSL ES 3.10 only
Storage qualifiers have to be after interpolation qualifiers.
Storage qualifiers have to be after layout qualifiers.
Store
strcmp
StrCmpICW
Stream<GS_OUTPUT> outStream)
stride cannot be greater than MAX_VERTEX_ATTRIB_STRIDE.
Stride is over the maximum stride allowed by WebGL.
Stride must be a multiple of the passed in datatype.
StringFileInfo
strncmp
strstr
StrStrIW
struct
struct-
struct 
struct CS_INPUT
struct gl_DepthRangeParameters
struct GS_INPUT
struct GS_OUTPUT
struct PS_INPUT
struct PS_OUTPUT
struct VS_INPUT
struct VS_OUTPUT
structure
Structure constructor arguments do not match structure fields
structure has no fields
Structure lengths for 
Structure names for 
structures containing arrays can't be function return values
structures containing arrays may not be declared constant since they cannot be initialized
subtract
subtract second child into first child
Surface types are not compatible.
SUVWATAUAVAWH
SV_Depth
SV_DEPTH
SV_Depth
SV_DEPTH
SV_DispatchThreadID;
SV_GroupID;
SV_GroupIndex;
SV_GroupThreadID;
SV_InstanceID
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_Position
SV_POSITION
SV_RENDERTARGETARRAYINDEX
SV_RenderTargetArrayIndex
SV_RENDERTARGETARRAYINDEX
SV_RenderTargetArrayIndex
SV_RENDERTARGETARRAYINDEX
SV_RenderTargetArrayIndex
SV_RENDERTARGETARRAYINDEX
SV_SAMPLEINDEX
SV_TARGET
SV_Target
SV_TARGET
SV_Target
SV_TARGET
SV_Target
SV_TARGET
SV_Target
SV_TARGET
SV_VertexID
SV_ViewportArrayIndex
SVWATAUAVAWH
SVWATAWH
Swap chain uninitialized
SwapChain11::initPassThroughResources
SwapChain11::reset
SwapChain11::resetOffscreenTexture
SwapChain11::resize
Switch
switch
switch (
Swizzle shader type not found
SwizzleIndices
SwizzleProperties
syntax error
SYSPREP.EXE
t E8Y
t!9C4t
t"9C8t
t"9K0t
t"D8=
t"D8Y
t$ ;^
t$ AVAWH
t$ AWD
T$ D9H 
T$ E+
T$ E3
t$ E3
T$ E3
t$ E3
t$ H;
t$ H+
t$ H9Q
T$ I;
T$ L+
t$ UH
t$ UWATAUAVH
t$ UWATAUAWH
t$ UWATAVAWH
t$ UWAVH
t$ WATAUAVAWH
t$ WAVAWH
t$ WAVI
t$ WH
t$$fD
T$(@8i
t$(A_
T$(D8~A
t$(D8a
T$(E3
t$(E3
T$(E3
t$(E3
T$(E3
t$@@8y@t
T$@E3
T$@H!EhH
T$@H;
t$@H+
T$@H+
t$@H9O
T$@L#^0H
t$@L9T$0
T$`!uP
t$`D80
T$`E3
t$`I+
T$`I+
T$`L#v0H
T$09K
t$09t$ t&
t$0A^_
t$0A_A^
T$0E3
t$0E3
T$0fD
T$0H)C
t$0H;
T$0H+T$ H
t$0H9O
T$0I;
t$0I;
T$0L#
T$0L+
T$49P }
t$8E3
T$8H+
t$8H9A
T$8Hc
t$8L#
T$AE3
t$hA;
t$HA_A^A]A\_
t$HD;
T$HE3
T$hE3
t$HE3
t$hE3
T$HE3
t$hE3
T$hH;
t$HH+
t$HH9S
T$hI;
t$hL;
T$HM;
T$P!u4
T$P9O
T$PD!u
T$PD!u4
t$PD80
t$PE;
T$PE3
T$pE3
t$PE3
T$PE3
T$PH#u0H
t$pH+
t$PH+
t$PH9S
t$PI;
T$PI;
T$PKc
T$PL#^0H
T$PL;
T$PLc
t$XE2
t$XE3
T$xE3
T$XE3
T$XH;
t$XH9
T$XM+
t%9w L
t&@8s
T(+-,)/.0*
t(9)t
t(D8Y
t*9wHt%H
t:D9o
t:L;@
t:L;H
t;y#H
t?D8Y
t?H9^
t?y&I
t@L;H
t[Lcm
t^@8=|e
t^L;H
t+I;}
t<H;q r6H;
t=D8@
t=L;H
t>L;H
t4LcJ
t7HcU
t9D9o
tAH;L$`t:H
tanh(
tanhf
tAy&I
tcD8Y
t'D;s
TE.EXE
Te.ProcessHost.exe
Temporary
TerminateProcess
ternary operator is not allowed for interface blocks
ternary operator is not allowed for opaque types
ternary operator is not allowed for structures or arrays
ternary operator is not allowed for variables with writeonly
ternary operator is not allowed for void
Ternary selection
tested first
tex2D
TEXCOORD
TEXCORD
texCUBE
texelFetch
texelFetchOffset
TexLocationOffset
TexLocationScale
Textarget must match the texture target type.
texture
Texture component must be a constant expression
Texture filter not recognized.
Texture format does not support mipmap generation.
Texture is not cubemap complete. All cubemaps faces must be defined and be the same size.
Texture is null
Texture level does not exist.
Texture level must be zero.
Texture not created on ANGLE D3D device
Texture offset must be a constant expression
Texture offset value out of valid range
Texture only supports NEAREST and LINEAR filtering.
Texture was not generated
Texture wrap mode not recognized.
texture_
Texture2D
texture2D
Texture2D<float4>
Texture2D<int4>
Texture2D<snorm float4>
Texture2D<uint4>
Texture2D<unorm float4>
Texture2DArray
Texture2DArray<float4>
Texture2DArray<int4>
Texture2DArray<snorm float4>
Texture2DArray<uint4>
Texture2DArray<unorm float4>
texture2DGradEXT
texture2DLod
texture2DLodEXT
Texture2DMS<float4>
Texture2DMS<int4>
Texture2DMS<uint4>
texture2DProj
texture2DProjGradEXT
texture2DProjLod
texture2DProjLodEXT
texture2DRect
texture2DRectProj
Texture3D
Texture3D<float4>
Texture3D<int4>
Texture3D<snorm float4>
Texture3D<uint4>
Texture3D<unorm float4>
textureCube
TextureCube
TextureCube<float4>
TextureCube<snorm float4>
TextureCube<unorm float4>
textureCubeGradEXT
textureCubeLod
textureCubeLodEXT
TextureF
TextureF_MS
TextureF2D
TextureF2DArray
TextureF3D
textureGather
textureGatherOffset
textureGrad
textureGradOffset
TextureI
TextureI2D
TextureI2DArray
TextureI3D
textureLod
textureLodOffset
textureOffset
textureProj
textureProjGrad
textureProjGradOffset
textureProjLod
textureProjLodOffset
textureProjOffset
textures
Texture's device does not match.
Texture's sample count does not match.
textureSize
TextureUI
TextureUI2D
TextureUI2DArray
TextureUI3D
tf=Pw
tGA;q t
t'H9w
t-HcA$B
t'HcH
The active read framebuffer object has multiview attachments.
The current context doesn't support setting a non-zero divisor on the attribute with index zero. Please reorder the attributes in your vertex shader so that attribute zero can have a zero divisor.
The current renderer doesn't support gl_FrontFacing
The D3D11 device was removed, 
The destination level of the destination texture must be defined.
The interpolation qualifier specified multiple times.
The invariant qualifier has to be first in the expression.
The invariant qualifier specified multiple times.
The layout qualifier and invariant qualifier cannot coexist in the same declaration according to the grammar.
The layout qualifier specified multiple times.
The number of views in the active program and draw framebuffer does not match.
The precision qualifier specified multiple times.
The provided parameters overflow with the provided buffer.
The source level of the source texture must be defined.
The specified dimensions are outside of the bounds of the texture.
The std430 layout is supported only for shader storage blocks.
The texture is a non-power-of-two texture.
The value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable.
There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1.
There is an active transform feedback object when the number of views in the active draw framebuffer is greater than 1.
This ANGLE implementation does not support separate front/back stencil writemasks, reference values, or stencil mask values.
This type of loop is not allowed
tjA9r
tKD8I4uE
tLD;H rFH
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
tmD8@
token too long
Too many active attributes (
too many arguments
Too many arguments for macro
too many uniforms
Too many vertex attributes.
tqI;}
Transform feedback varying 
Transform feedback varying total components (
Transform feedback varying's 
Translation
transpose
transpose(
transpose(input.
transpose(mul(transpose(
triangle
Triangle
triangle_strip
triangles
triangles_adjacency
true case
true case is null
trunc
trunc(
truncf
ts=Pw
tsI;?u'A
ttD8H
ttI;}
tuI;}
TUUUUUU
tvH;}
tWE8f
twI;}
Two transform feedback varyings include the same array element (
Two transform feedback varyings specify the same output variable (
txI;?u/A
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Types for 
Types for interface block '
tZD8Y
u A8Y
u A8z
u!D;{
u!D9>u
u!L;e
u#D9A }
u#D9a s
u$A8Y
u%A8j
u%A8z
u(D9t$ tJH
u(H9+t
U(H9U0
u)A8j
u)D;e
u,A8j
u,A8r
u.D9A
u:D8A,u4D9A
u_H9D$(uXH
U0H9P0t`L
u38Egt"H
u48Egt/H
u4Hcr
uaddCarry
UATAUAVAWH
UATAVH
UATAWH
UAUAWH
UAVAWH
ub'vb'v
ueH9D$(u^H
ueM;Z8t+H
uH+u@D
uHD8d$H
uIL;y`rCH
uim21;
uim2a
uim2a1;
uim31;
uimage2D
uimage2DArray
uimage3D
uimageCube
uimc1;
uint bitfieldExtract_emu(uint value, int offset, int bits)
uint bitfieldInsert_emu(uint base, uint insert, int offset, int bits)
uint packHalf2x16_emu(in float2 v)
uint packSnorm2x16_emu(in float2 v)
uint packSnorm4x8_emu(in float4 v)
uint packUnorm2x16_emu(in float2 v)
uint packUnorm4x8_emu(in float4 v)
uint primitiveID : SV_PrimitiveID, 
uint samplerIndex
uint uaddCarry_emu(uint x, uint y, out uint carry)
uint usubBorrow_emu(uint x, uint y, out uint borrow)
uint webgl_toUnorm16(in float x) {
uint webgl_toUnorm8(in float x) {
uint2
uint2 bitfieldExtract_emu(uint2 value, int offset, int bits)
uint2 bitfieldInsert_emu(uint2 base, uint2 insert, int offset, int bits)
uint2 uaddCarry_emu(uint2 x, uint2 y, out uint2 carry)
uint2 usubBorrow_emu(uint2 x, uint2 y, out uint2 borrow)
uint3
uint3 bitfieldExtract_emu(uint3 value, int offset, int bits)
uint3 bitfieldInsert_emu(uint3 base, uint3 insert, int offset, int bits)
uint3 uaddCarry_emu(uint3 x, uint3 y, out uint3 carry)
uint3 usubBorrow_emu(uint3 x, uint3 y, out uint3 borrow)
uint4
uint4 bitfieldExtract_emu(uint4 value, int offset, int bits)
uint4 bitfieldInsert_emu(uint4 base, uint4 insert, int offset, int bits)
uint4 uaddCarry_emu(uint4 x, uint4 y, out uint4 carry)
uint4 usubBorrow_emu(uint4 x, uint4 y, out uint4 borrow)
uintBitsToFloat
uLD+uD
umulExtended
Unable to reserve 
uND9w
undeclared identifier
undeclared identifier declared as invariant
undef
Undefined function '
undefined operation for structs containing arrays
undefined operation for structs containing samplers
Undefined shift (operand out of range)
unexpected #elif found after #else
unexpected #elif found without a matching #if
unexpected #else found after another #else
unexpected #else found without a matching #if
unexpected #endif found without a matching #if
unexpected end of file found in comment
unexpected end of file found in conditional block
unexpected end of file found in directive
unexpected token
unexpected token after conditional expression
unH9A
Unhandled internal error: 
UnhandledExceptionFilter
uniform
uniform 
uniform '
uniform block binding greater than MAX_UNIFORM_BUFFER_BINDINGS
uniform float2 dx_ViewCoords : register(c2);
uniform float3 dx_DepthFront : register(c2);
uniform float3 dx_DepthRange : register(c0);
uniform float4 dx_ViewAdjust : register(c1);
uniform float4 dx_ViewCoords : register(c1);
Uniform location out of range
Uniform size does not match uniform method.
Unknown attribute.
Unknown client buffer texture format: 
Unknown constant
Unknown parameter value.
Unknown platform type.
UNKOWN ERROR: 
Unlogged error in DirectStoragePossible.
Unpack alignment must be 1, 2, 4, or 8.
unpackHalf2x16
unpackSnorm2x16
unpackSnorm4x8
unpackUnorm2x16
unpackUnorm4x8
unrecognized pragma
unrecognized token
Unsigned integers are unsupported prior to GLSL ES 3.00
Unsupported format
Unsupported internal format.
unsupported shader version
unsupported type
unsupported type - 
unsupported value
unterminated macro invocation
us21;
us2a1;
us2ms
us2ms1;
us31;
usampler2D
usampler2DArray
usampler2DMS
usampler3D
usamplerCube
USATAUH
usC1;
USERACCOUNTBROKER.EXE
usubBorrow
USVWATAUAVAWH
USVWATAVAWH
USVWAVH
USWATAVH
UUUU3
UUUUUUU
UVATAUAVH
UVATAVAWH
uvec2
uvec3
uvec4
UVWATAUAVAWH
UVWATAVH
UVWATAWH
UVWAVAWH
UWATAUAVH
UWATAVAWH
UWAUAVAWH
UWAVH
UWAWH
V(H+V L
v:D8AQu'
V0H+V(H
v'8Kiv
value
VarFileInfo
variable expected
variables with qualifier 'const' must be initialized
varying
VATAUAVAWH
vector field selection out of range
vector scale second child into first child
vector swizzle (
vector-scale
vector-times-matrix
VerifyVersionInfoW
VerSetConditionMask
version
version number not supported
VERTEX
Vertex Attrib Bindings require OpenGL ES 3.1.
Vertex attribute size must be 1, 2, 3, or 4.
Vertex buffer is not big enough for the draw call
Vertex buffer is not big enough for the draw call.
Vertex buffer overflow in VertexBufferInterface::getSpaceRequired.
Vertex shader active uniforms exceed MAX_VERTEX_UNIFORM_VECTORS (
Vertex shader atomic counter count exceeds MAX_VERTEX_ATOMIC_COUNTERS (
Vertex shader image count exceeds MAX_VERTEX_IMAGE_UNIFORMS (
Vertex shader input type does not match the type of the bound vertex attribute.
Vertex shader sampler count exceeds MAX_VERTEX_TEXTURE_IMAGE_UNITS (
Vertex shader shader storage block count exceeds GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS (
Vertex shader uniform block count exceeds GL_MAX_VERTEX_UNIFORM_BLOCKS (
Vertex type not supported before OpenGL ES 3.0.
VertexID
VertexShader
ViewID_OVR
ViewIDOVR
Viewport size cannot be negative.
ViewportIndex
void 
void copyVertex(inout GS_OUTPUT output, GS_INPUT input, GS_INPUT flatinput)
void function cannot return a value
void imulExtended_emu(int x, int y, out int msb, out int lsb)
void imulExtended_emu(int2 x, int2 y, out int2 msb, out int2 lsb)
void imulExtended_emu(int3 x, int3 y, out int3 msb, out int3 lsb)
void imulExtended_emu(int4 x, int4 y, out int4 msb, out int4 lsb)
void initAttributes(VS_INPUT input)
void main(
void main(CS_INPUT input)
void selectView(inout GS_OUTPUT output, GS_INPUT input)
void umulExtended_emu(uint x, uint y, out uint msb, out uint lsb)
void umulExtended_emu(uint2 x, uint2 y, out uint2 msb, out uint2 lsb)
void umulExtended_emu(uint3 x, uint3 y, out uint3 msb, out uint3 lsb)
void umulExtended_emu(uint4 x, uint4 y, out uint4 msb, out uint4 lsb)
volatile
VS_OUTPUT main(VS_INPUT input)
VS_VERSION_INFO
Vulkan platform is unsupported.
VWATAUAVH
VWATAUAWH
VWATAVAWH
VWAUAVAWH
VWAVH
VWAWH
W H+W
w IcA
w^tMA
w^tWA
WaitForSingleObject
WaitForSingleObjectEx
WaitForThreadpoolTimerCallbacks
WakeAllConditionVariable
WARNING: 
Warning: D3D shader compilation failed with 
WATAUAVAWH
WATAUAVAWL
WATAWH
WAUAVH
WAVAWH
webgl_
webgl_debug_shader_precision
wED9`
while
while (
width
Width or height < 1
WilError_02
WilStaging_02
wit[-t
Work group size does not match the previous declaration
Work group size is not specified.
WorkGroupID
WorkGroupSize
wotcA
wqD9`
wrapR
wrapS
wrapT
wRIcA
write_
writeonly
Writeonly value cannot be passed for 'in' or 'inout' parameters.
wrong operand type - no operation '
wrong operand types - no operation '
wrong type of value for uniform
wTtF-
WWAHOST.EXE
wXtQA
x and y cannot be negative.
x ATAUAVAWH
x ATAUAVAWL
x ATAUAVH
x ATAVAWH
x ATH
x AUAVAWH
x AVAWL
x AVH
x AVL
x AWH
x UATAUAVAWH
x UATAVH
x UAVAWH
X UVWATAUAVAWH
X UVWAVAWH
x@8t$!t$I
X_^[]
X_^][
xA_A^_^[]
XA_A^A]A\_^[]
xA_A^A]A\_^[]
XA_A^A]A\_^][
XIcK8I#
xkLcL$XE
xuLcD$PE
xyz{|}~
ycs1;
yJH!s
yuv_2_rgb
yuvCscStandardEXT
yyset_column called with no buffer
yyset_lineno called with no buffer
YZ[wxy\]^_`abcdef
z*u(H
Z_\`NMabck
Z_____a
Zero divided by zero during constant folding generated NaN
zHHzzJJzpz
zValue_Depth
zValueF_Float
zValueF_Sint
zValueF_Uint
